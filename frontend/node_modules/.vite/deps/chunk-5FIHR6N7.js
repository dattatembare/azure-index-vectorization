import {
  require_react_dom
} from "./chunk-5LW6CXX4.js";
import {
  Async,
  Customizations,
  Customizer,
  EventGroup,
  FocusRects,
  FocusRectsContext,
  FocusRectsProvider,
  GlobalSettings,
  IsFocusVisibleClassName,
  KeyCodes,
  Rectangle,
  Stylesheet,
  WindowContext,
  __assign,
  __decorate,
  __extends,
  __rest,
  __spreadArray,
  addElementAtIndex,
  allowOverscrollOnElement,
  allowScrollOnElement,
  anchorProperties,
  assign,
  buttonProperties,
  classNamesFunction,
  composeComponentAs,
  composeRenderFunction,
  concatStyleSets,
  concatStyleSetsWithProps,
  createMergedRef,
  css,
  customizable,
  disableBodyScroll,
  divProperties,
  doesElementContainFocus,
  elementContains,
  enableBodyScroll,
  find,
  findIndex,
  findScrollableParent,
  focusAsync,
  focusFirstChild,
  fontFace,
  getDocument,
  getElementIndexPath,
  getFirstFocusable,
  getFirstTabbable,
  getFocusableByIndexPath,
  getId,
  getLanguage,
  getLastFocusable,
  getLastTabbable,
  getNativeProps,
  getNextElement,
  getParent,
  getPreviousElement,
  getPropsWithDefaults,
  getRTL,
  getScrollbarWidth,
  getWindow,
  hoistMethods,
  hoistStatics,
  htmlElementProperties,
  imgProperties,
  initializeComponentRef,
  isElementFocusSubZone,
  isElementFocusZone,
  isElementTabbable,
  isElementVisibleAndNotHidden,
  isIOS,
  isMac,
  keyframes,
  memoizeFunction,
  merge,
  mergeAriaAttributeValues,
  mergeSettings,
  mergeStyleSets,
  mergeStyles,
  modalize,
  nullRender,
  on,
  portalContainsElement,
  safeRequestAnimationFrame,
  setFocusVisibility,
  setPortalAttribute,
  setVersion,
  setVirtualParent,
  shallowCompare,
  shouldWrapFocus,
  styled,
  unhoistMethods,
  useAsync,
  useConst,
  useControllableValue,
  useDocument,
  useEventCallback,
  useFocusRects,
  useId,
  useIsomorphicLayoutEffect,
  useMergedRefs,
  useOnEvent,
  usePrevious,
  useTarget,
  useUnmount,
  useWarnings,
  useWindow,
  warn,
  warnConditionallyRequiredProps,
  warnDeprecations,
  warnMutuallyExclusive
} from "./chunk-WP4MVZZD.js";
import {
  require_react
} from "./chunk-YN3MIK7E.js";
import {
  __toESM
} from "./chunk-4EOJPDL2.js";

// node_modules/@fluentui/react/lib/version.js
setVersion("@fluentui/react", "8.110.2");

// node_modules/@fluentui/react/lib/components/Dropdown/Dropdown.base.js
var React42 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Callout/Callout.js
var React7 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.base.js
var React2 = __toESM(require_react());

// node_modules/@fluentui/react/lib/common/DirectionalHint.js
var DirectionalHint = {
  /**
   * Appear above the target element, with the left edges of the callout and target aligning.
   */
  topLeftEdge: 0,
  /**
   * Appear above the target element, with the centers of the callout and target aligning.
   */
  topCenter: 1,
  /**
   * Appear above the target element, with the right edges of the callout and target aligning.
   */
  topRightEdge: 2,
  /**
   * Appear above the target element, aligning with the target element such that the callout tends toward
   * the center of the screen.
   */
  topAutoEdge: 3,
  /**
   * Appear below the target element, with the left edges of the callout and target aligning.
   */
  bottomLeftEdge: 4,
  /**
   * Appear below the target element, with the centers of the callout and target aligning.
   */
  bottomCenter: 5,
  /**
   * Appear below the target element, with the right edges of the callout and target aligning.
   */
  bottomRightEdge: 6,
  /**
   * Appear below the target element, aligning with the target element such that the callout tends toward
   * the center of the screen.
   */
  bottomAutoEdge: 7,
  /**
   * Appear to the left of the target element, with the top edges of the callout and target aligning.
   */
  leftTopEdge: 8,
  /**
   * Appear to the left of the target element, with the centers of the callout and target aligning.
   */
  leftCenter: 9,
  /**
   * Appear to the left of the target element, with the bottom edges of the callout and target aligning.
   */
  leftBottomEdge: 10,
  /**
   * Appear to the right of the target element, with the top edges of the callout and target aligning.
   */
  rightTopEdge: 11,
  /**
   * Appear to the right of the target element, with the centers of the callout and target aligning.
   */
  rightCenter: 12,
  /**
   * Appear to the right of the target element, with the bottom edges of the callout and target aligning.
   */
  rightBottomEdge: 13
};

// node_modules/@fluentui/react/lib/utilities/positioning/positioning.types.js
var RectangleEdge;
(function(RectangleEdge2) {
  RectangleEdge2[RectangleEdge2["top"] = 1] = "top";
  RectangleEdge2[RectangleEdge2["bottom"] = -1] = "bottom";
  RectangleEdge2[RectangleEdge2["left"] = 2] = "left";
  RectangleEdge2[RectangleEdge2["right"] = -2] = "right";
})(RectangleEdge || (RectangleEdge = {}));
var Position;
(function(Position2) {
  Position2[Position2["top"] = 0] = "top";
  Position2[Position2["bottom"] = 1] = "bottom";
  Position2[Position2["start"] = 2] = "start";
  Position2[Position2["end"] = 3] = "end";
})(Position || (Position = {}));

// node_modules/@fluentui/react/lib/utilities/positioning/positioning.js
var _a;
function _createPositionData(targetEdge, alignmentEdge, isAuto) {
  return {
    targetEdge,
    alignmentEdge,
    isAuto
  };
}
var DirectionalDictionary = (_a = {}, _a[DirectionalHint.topLeftEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.left), _a[DirectionalHint.topCenter] = _createPositionData(RectangleEdge.top), _a[DirectionalHint.topRightEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.right), _a[DirectionalHint.topAutoEdge] = _createPositionData(RectangleEdge.top, void 0, true), _a[DirectionalHint.bottomLeftEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.left), _a[DirectionalHint.bottomCenter] = _createPositionData(RectangleEdge.bottom), _a[DirectionalHint.bottomRightEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.right), _a[DirectionalHint.bottomAutoEdge] = _createPositionData(RectangleEdge.bottom, void 0, true), _a[DirectionalHint.leftTopEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.top), _a[DirectionalHint.leftCenter] = _createPositionData(RectangleEdge.left), _a[DirectionalHint.leftBottomEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.bottom), _a[DirectionalHint.rightTopEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.top), _a[DirectionalHint.rightCenter] = _createPositionData(RectangleEdge.right), _a[DirectionalHint.rightBottomEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.bottom), _a);
function _isRectangleWithinBounds(rect, boundingRect) {
  if (rect.top < boundingRect.top) {
    return false;
  }
  if (rect.bottom > boundingRect.bottom) {
    return false;
  }
  if (rect.left < boundingRect.left) {
    return false;
  }
  if (rect.right > boundingRect.right) {
    return false;
  }
  return true;
}
function _getOutOfBoundsEdges(rect, boundingRect) {
  var outOfBounds = [];
  if (rect.top < boundingRect.top) {
    outOfBounds.push(RectangleEdge.top);
  }
  if (rect.bottom > boundingRect.bottom) {
    outOfBounds.push(RectangleEdge.bottom);
  }
  if (rect.left < boundingRect.left) {
    outOfBounds.push(RectangleEdge.left);
  }
  if (rect.right > boundingRect.right) {
    outOfBounds.push(RectangleEdge.right);
  }
  return outOfBounds;
}
function _getEdgeValue(rect, edge) {
  return rect[RectangleEdge[edge]];
}
function _setEdgeValue(rect, edge, value) {
  rect[RectangleEdge[edge]] = value;
  return rect;
}
function _getCenterValue(rect, edge) {
  var edges = _getFlankingEdges(edge);
  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;
}
function _getRelativeEdgeValue(edge, value) {
  if (edge > 0) {
    return value;
  } else {
    return value * -1;
  }
}
function _getRelativeRectEdgeValue(edge, rect) {
  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));
}
function _getRelativeEdgeDifference(rect, hostRect, edge) {
  var edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);
  return _getRelativeEdgeValue(edge, edgeDifference);
}
function _moveEdge(rect, edge, newValue, maintainSize) {
  if (maintainSize === void 0) {
    maintainSize = true;
  }
  var difference = _getEdgeValue(rect, edge) - newValue;
  var returnRect = _setEdgeValue(rect, edge, newValue);
  if (maintainSize) {
    returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);
  }
  return returnRect;
}
function _alignEdges(rect, target, edge, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));
}
function _alignOppositeEdges(rect, target, targetEdge, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  var oppositeEdge = targetEdge * -1;
  var adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);
  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);
}
function _isEdgeInBounds(rect, bounds, edge) {
  var adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);
  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);
}
function _getOutOfBoundsDegree(rect, bounds) {
  var breakingEdges = _getOutOfBoundsEdges(rect, bounds);
  var total = 0;
  for (var _i = 0, breakingEdges_1 = breakingEdges; _i < breakingEdges_1.length; _i++) {
    var edge = breakingEdges_1[_i];
    total += Math.pow(_getRelativeEdgeDifference(rect, bounds, edge), 2);
  }
  return total;
}
function _flipToFit(rect, target, bounding, positionData, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  var directions = [
    RectangleEdge.left,
    RectangleEdge.right,
    RectangleEdge.bottom,
    RectangleEdge.top
  ];
  if (getRTL()) {
    directions[0] *= -1;
    directions[1] *= -1;
  }
  var currentEstimate = rect;
  var currentEdge = positionData.targetEdge;
  var currentAlignment = positionData.alignmentEdge;
  var oobDegree;
  var bestEdge = currentEdge;
  var bestAlignment = currentAlignment;
  for (var i = 0; i < 4; i++) {
    if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {
      var currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);
      if (!oobDegree || currentOOBDegree < oobDegree) {
        oobDegree = currentOOBDegree;
        bestEdge = currentEdge;
        bestAlignment = currentAlignment;
      }
      directions.splice(directions.indexOf(currentEdge), 1);
      if (directions.length > 0) {
        if (directions.indexOf(currentEdge * -1) > -1) {
          currentEdge = currentEdge * -1;
        } else {
          currentAlignment = currentEdge;
          currentEdge = directions.slice(-1)[0];
        }
        currentEstimate = _estimatePosition(rect, target, { targetEdge: currentEdge, alignmentEdge: currentAlignment }, gap);
      }
    } else {
      return {
        elementRectangle: currentEstimate,
        targetEdge: currentEdge,
        alignmentEdge: currentAlignment
      };
    }
  }
  currentEstimate = _estimatePosition(rect, target, { targetEdge: bestEdge, alignmentEdge: bestAlignment }, gap);
  return {
    elementRectangle: currentEstimate,
    targetEdge: bestEdge,
    alignmentEdge: bestAlignment
  };
}
function _flipAlignmentEdge(elementEstimate, target, gap, coverTarget) {
  var alignmentEdge = elementEstimate.alignmentEdge, targetEdge = elementEstimate.targetEdge, elementRectangle = elementEstimate.elementRectangle;
  var oppositeEdge = alignmentEdge * -1;
  var newEstimate = _estimatePosition(elementRectangle, target, { targetEdge, alignmentEdge: oppositeEdge }, gap, coverTarget);
  return {
    elementRectangle: newEstimate,
    targetEdge,
    alignmentEdge: oppositeEdge
  };
}
function _adjustFitWithinBounds(element, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
  if (gap === void 0) {
    gap = 0;
  }
  var alignmentEdge = positionData.alignmentEdge, alignTargetEdge = positionData.alignTargetEdge;
  var elementEstimate = {
    elementRectangle: element,
    targetEdge: positionData.targetEdge,
    alignmentEdge
  };
  if (!directionalHintFixed && !coverTarget) {
    elementEstimate = _flipToFit(element, target, bounding, positionData, gap);
  }
  var outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);
  var fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : void 0;
  if (outOfBounds.length > 0) {
    if (alignTargetEdge) {
      if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {
        var flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);
        if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {
          return flippedElementEstimate;
        } else {
          elementEstimate = _alignOutOfBoundsEdges(_getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding), elementEstimate, bounding, fixedEdge);
        }
      } else {
        elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
      }
    } else {
      elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
    }
  }
  return elementEstimate;
}
function _alignOutOfBoundsEdges(outOfBoundsEdges, elementEstimate, bounding, preserveEdge) {
  for (var _i = 0, outOfBoundsEdges_1 = outOfBoundsEdges; _i < outOfBoundsEdges_1.length; _i++) {
    var direction = outOfBoundsEdges_1[_i];
    var edgeAttempt = void 0;
    if (preserveEdge && preserveEdge === direction * -1) {
      edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);
      elementEstimate.forcedInBounds = true;
    } else {
      edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);
      var inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);
      if (!inBounds) {
        edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);
        elementEstimate.forcedInBounds = true;
      }
    }
    elementEstimate.elementRectangle = edgeAttempt;
  }
  return elementEstimate;
}
function _centerEdgeToPoint(rect, edge, point) {
  var positiveEdge = _getFlankingEdges(edge).positiveEdge;
  var elementMiddle = _getCenterValue(rect, edge);
  var distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);
  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);
}
function _estimatePosition(elementToPosition, target, positionData, gap, coverTarget) {
  if (gap === void 0) {
    gap = 0;
  }
  var estimatedElementPosition = new Rectangle(elementToPosition.left, elementToPosition.right, elementToPosition.top, elementToPosition.bottom);
  var alignmentEdge = positionData.alignmentEdge, targetEdge = positionData.targetEdge;
  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
  estimatedElementPosition = coverTarget ? _alignEdges(estimatedElementPosition, target, targetEdge, gap) : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap);
  if (!alignmentEdge) {
    var targetMiddlePoint = _getCenterValue(target, targetEdge);
    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);
  } else {
    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);
  }
  return estimatedElementPosition;
}
function _getFlankingEdges(edge) {
  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {
    return {
      positiveEdge: RectangleEdge.left,
      negativeEdge: RectangleEdge.right
    };
  } else {
    return {
      positiveEdge: RectangleEdge.top,
      negativeEdge: RectangleEdge.bottom
    };
  }
}
function _finalizeReturnEdge(elementRectangle, returnEdge, bounds) {
  if (bounds && Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) > Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))) {
    return returnEdge * -1;
  }
  return returnEdge;
}
function _isEdgeOnBounds(elementRectangle, edge, bounds) {
  return bounds !== void 0 && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);
}
function _finalizeElementPosition(elementRectangle, hostElement, targetEdge, bounds, alignmentEdge, coverTarget, doNotFinalizeReturnEdge, forceWithinBounds) {
  var returnValue = {};
  var hostRect = _getRectangleFromElement(hostElement);
  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
  var returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;
  if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {
    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);
  }
  returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);
  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);
  if (forceWithinBounds) {
    returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge * -1);
    returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge * -1);
  }
  return returnValue;
}
function _calculateActualBeakWidthInPixels(beakWidth) {
  return Math.sqrt(beakWidth * beakWidth * 2);
}
function _getPositionData(directionalHint, directionalHintForRTL, previousPositions) {
  if (directionalHint === void 0) {
    directionalHint = DirectionalHint.bottomAutoEdge;
  }
  if (previousPositions) {
    return {
      alignmentEdge: previousPositions.alignmentEdge,
      isAuto: previousPositions.isAuto,
      targetEdge: previousPositions.targetEdge
    };
  }
  var positionInformation = __assign({}, DirectionalDictionary[directionalHint]);
  if (getRTL()) {
    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {
      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;
    }
    return directionalHintForRTL !== void 0 ? DirectionalDictionary[directionalHintForRTL] : positionInformation;
  }
  return positionInformation;
}
function _getAlignmentData(positionData, target, boundingRect, coverTarget, alignTargetEdge) {
  if (positionData.isAuto) {
    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);
  }
  positionData.alignTargetEdge = alignTargetEdge;
  return positionData;
}
function getClosestEdge(targetEdge, target, boundingRect) {
  var targetCenter = _getCenterValue(target, targetEdge);
  var boundingCenter = _getCenterValue(boundingRect, targetEdge);
  var _a5 = _getFlankingEdges(targetEdge), positiveEdge = _a5.positiveEdge, negativeEdge = _a5.negativeEdge;
  if (targetCenter <= boundingCenter) {
    return positiveEdge;
  } else {
    return negativeEdge;
  }
}
function _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
  var estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);
  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {
    return {
      elementRectangle: estimatedElementPosition,
      targetEdge: positionData.targetEdge,
      alignmentEdge: positionData.alignmentEdge
    };
  } else {
    return _adjustFitWithinBounds(estimatedElementPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget);
  }
}
function _finalizeBeakPosition(elementPosition, positionedBeak, bounds) {
  var targetEdge = elementPosition.targetEdge * -1;
  var actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);
  var returnValue = {};
  var returnEdge = _finalizeReturnEdge(elementPosition.elementRectangle, elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge, bounds);
  var beakEdgeDifference = _getRelativeEdgeDifference(elementPosition.elementRectangle, elementPosition.targetRectangle, targetEdge);
  var showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));
  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);
  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);
  return {
    elementPosition: __assign({}, returnValue),
    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),
    targetEdge,
    hideBeak: !showBeak
  };
}
function _positionBeak(beakWidth, elementPosition) {
  var target = elementPosition.targetRectangle;
  var _a5 = _getFlankingEdges(elementPosition.targetEdge), positiveEdge = _a5.positiveEdge, negativeEdge = _a5.negativeEdge;
  var beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);
  var elementBounds = new Rectangle(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);
  var beakPosition = new Rectangle(0, beakWidth, 0, beakWidth);
  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);
  beakPosition = _centerEdgeToPoint(beakPosition, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));
  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {
    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);
  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {
    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);
  }
  return beakPosition;
}
function _getRectangleFromElement(element) {
  var clientRect = element.getBoundingClientRect();
  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);
}
function _getRectangleFromIRect(rect) {
  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);
}
function _getTargetRect(bounds, target) {
  var targetRectangle;
  if (target) {
    if (!!target.preventDefault) {
      var ev = target;
      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);
    } else if (!!target.getBoundingClientRect) {
      targetRectangle = _getRectangleFromElement(target);
    } else {
      var rectOrPoint = target;
      var left = rectOrPoint.left || rectOrPoint.x;
      var top_1 = rectOrPoint.top || rectOrPoint.y;
      var right = rectOrPoint.right || left;
      var bottom = rectOrPoint.bottom || top_1;
      targetRectangle = new Rectangle(left, right, top_1, bottom);
    }
    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {
      var outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);
      for (var _i = 0, outOfBounds_1 = outOfBounds; _i < outOfBounds_1.length; _i++) {
        var direction = outOfBounds_1[_i];
        targetRectangle[RectangleEdge[direction]] = bounds[RectangleEdge[direction]];
      }
    }
  } else {
    targetRectangle = new Rectangle(0, 0, 0, 0);
  }
  return targetRectangle;
}
function _getMaxHeightFromTargetRectangle(targetRectangle, targetEdge, gapSpace, bounds, coverTarget) {
  var maxHeight = 0;
  var directionalHint = DirectionalDictionary[targetEdge];
  var target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;
  if (target === RectangleEdge.top) {
    maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;
  } else if (target === RectangleEdge.bottom) {
    maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;
  } else {
    maxHeight = bounds.bottom - targetRectangle.top - gapSpace;
  }
  return maxHeight > 0 ? maxHeight : bounds.height;
}
function _positionElementRelative(props, elementToPosition, boundingRect, previousPositions) {
  var gap = props.gapSpace ? props.gapSpace : 0;
  var targetRect = _getTargetRect(boundingRect, props.target);
  var positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions), targetRect, boundingRect, props.coverTarget, props.alignTargetEdge);
  var positionedElement = _positionElementWithinBounds(_getRectangleFromElement(elementToPosition), targetRect, boundingRect, positionData, gap, props.directionalHintFixed, props.coverTarget);
  return __assign(__assign({}, positionedElement), { targetRectangle: targetRect });
}
function _finalizePositionData(positionedElement, hostElement, bounds, coverTarget, doNotFinalizeReturnEdge) {
  var finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, bounds, positionedElement.alignmentEdge, coverTarget, doNotFinalizeReturnEdge, positionedElement.forcedInBounds);
  return {
    elementPosition: finalizedElement,
    targetEdge: positionedElement.targetEdge,
    alignmentEdge: positionedElement.alignmentEdge
  };
}
function _positionElement(props, hostElement, elementToPosition, previousPositions) {
  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
  var positionedElement = _positionElementRelative(props, elementToPosition, boundingRect, previousPositions);
  return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);
}
function _positionCallout(props, hostElement, callout, previousPositions, doNotFinalizeReturnEdge) {
  var beakWidth = props.isBeakVisible ? props.beakWidth || 0 : 0;
  var gap = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);
  var positionProps = props;
  positionProps.gapSpace = gap;
  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
  var positionedElement = _positionElementRelative(positionProps, callout, boundingRect, previousPositions);
  var beakPositioned = _positionBeak(beakWidth, positionedElement);
  var finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned, boundingRect);
  return __assign(__assign({}, _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge)), { beakPosition: finalizedBeakPosition });
}
function _positionCard(props, hostElement, callout, previousPositions) {
  return _positionCallout(props, hostElement, callout, previousPositions, true);
}
function positionElement(props, hostElement, elementToPosition, previousPositions) {
  return _positionElement(props, hostElement, elementToPosition, previousPositions);
}
function positionCallout(props, hostElement, elementToPosition, previousPositions) {
  return _positionCallout(props, hostElement, elementToPosition, previousPositions);
}
function positionCard(props, hostElement, elementToPosition, previousPositions) {
  return _positionCard(props, hostElement, elementToPosition, previousPositions);
}
function getMaxHeight(target, targetEdge, gapSpace, bounds, coverTarget) {
  if (gapSpace === void 0) {
    gapSpace = 0;
  }
  var mouseTarget = target;
  var elementTarget = target;
  var rectOrPointTarget = target;
  var targetRect;
  var boundingRectangle = bounds ? _getRectangleFromIRect(bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
  var left = rectOrPointTarget.left || rectOrPointTarget.x;
  var top = rectOrPointTarget.top || rectOrPointTarget.y;
  var right = rectOrPointTarget.right || left;
  var bottom = rectOrPointTarget.bottom || top;
  if (!!mouseTarget.stopPropagation) {
    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);
  } else if (left !== void 0 && top !== void 0) {
    targetRect = new Rectangle(left, right, top, bottom);
  } else {
    targetRect = _getRectangleFromElement(elementTarget);
  }
  return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);
}
function getOppositeEdge(edge) {
  return edge * -1;
}
function _getBoundsFromTargetWindow(target, targetWindow) {
  var segments = void 0;
  if (targetWindow.getWindowSegments) {
    segments = targetWindow.getWindowSegments();
  }
  if (segments === void 0 || segments.length <= 1) {
    return {
      top: 0,
      left: 0,
      right: targetWindow.innerWidth,
      bottom: targetWindow.innerHeight,
      width: targetWindow.innerWidth,
      height: targetWindow.innerHeight
    };
  }
  var x = 0;
  var y = 0;
  if (target !== null && !!target.getBoundingClientRect) {
    var clientRect = target.getBoundingClientRect();
    x = (clientRect.left + clientRect.right) / 2;
    y = (clientRect.top + clientRect.bottom) / 2;
  } else if (target !== null) {
    x = target.left || target.x;
    y = target.top || target.y;
  }
  var bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };
  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
    var segment = segments_1[_i];
    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {
      bounds = {
        top: segment.top,
        left: segment.left,
        right: segment.right,
        bottom: segment.bottom,
        width: segment.width,
        height: segment.height
      };
    }
  }
  return bounds;
}
function getBoundsFromTargetWindow(target, targetWindow) {
  return _getBoundsFromTargetWindow(target, targetWindow);
}

// node_modules/@fluentui/react/lib/components/Popup/Popup.js
var React = __toESM(require_react());
function useScrollbarAsync(props, root) {
  var async = useAsync();
  var _a5 = React.useState(false), needsVerticalScrollBarState = _a5[0], setNeedsVerticalScrollBar = _a5[1];
  React.useEffect(function() {
    async.requestAnimationFrame(function() {
      var _a6;
      if (props.style && props.style.overflowY) {
        return;
      }
      var needsVerticalScrollBar = false;
      if (root && root.current && ((_a6 = root.current) === null || _a6 === void 0 ? void 0 : _a6.firstElementChild)) {
        var rootHeight = root.current.clientHeight;
        var firstChildHeight = root.current.firstElementChild.clientHeight;
        if (rootHeight > 0 && firstChildHeight > rootHeight) {
          needsVerticalScrollBar = firstChildHeight - rootHeight > 1;
        }
      }
      if (needsVerticalScrollBarState !== needsVerticalScrollBar) {
        setNeedsVerticalScrollBar(needsVerticalScrollBar);
      }
    });
    return function() {
      return async.dispose();
    };
  });
  return needsVerticalScrollBarState;
}
function defaultFocusRestorer(options) {
  var originalElement = options.originalElement, containsFocus = options.containsFocus;
  if (originalElement && containsFocus && originalElement !== getWindow()) {
    setTimeout(function() {
      var _a5;
      (_a5 = originalElement.focus) === null || _a5 === void 0 ? void 0 : _a5.call(originalElement);
    }, 0);
  }
}
function useRestoreFocus(props, root) {
  var _a5 = props.onRestoreFocus, onRestoreFocus = _a5 === void 0 ? defaultFocusRestorer : _a5;
  var originalFocusedElement = React.useRef();
  var containsFocus = React.useRef(false);
  React.useEffect(function() {
    originalFocusedElement.current = getDocument().activeElement;
    if (doesElementContainFocus(root.current)) {
      containsFocus.current = true;
    }
    return function() {
      var _a6;
      onRestoreFocus === null || onRestoreFocus === void 0 ? void 0 : onRestoreFocus({
        originalElement: originalFocusedElement.current,
        containsFocus: containsFocus.current,
        documentContainsFocus: ((_a6 = getDocument()) === null || _a6 === void 0 ? void 0 : _a6.hasFocus()) || false
      });
      originalFocusedElement.current = void 0;
    };
  }, []);
  useOnEvent(root, "focus", React.useCallback(function() {
    containsFocus.current = true;
  }, []), true);
  useOnEvent(root, "blur", React.useCallback(function(ev) {
    if (root.current && ev.relatedTarget && !root.current.contains(ev.relatedTarget)) {
      containsFocus.current = false;
    }
  }, []), true);
}
function useHideSiblingNodes(props, root) {
  var shouldHideSiblings = String(props["aria-modal"]).toLowerCase() === "true" && props.enableAriaHiddenSiblings;
  React.useEffect(function() {
    if (!(shouldHideSiblings && root.current)) {
      return;
    }
    var unmodalize = modalize(root.current);
    return unmodalize;
  }, [root, shouldHideSiblings]);
}
var Popup = React.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults({ shouldRestoreFocus: true, enableAriaHiddenSiblings: true }, propsWithoutDefaults);
  var root = React.useRef();
  var mergedRootRef = useMergedRefs(root, forwardedRef);
  useHideSiblingNodes(props, root);
  useRestoreFocus(props, root);
  var role = props.role, className = props.className, ariaLabel = props.ariaLabel, ariaLabelledBy = props.ariaLabelledBy, ariaDescribedBy = props.ariaDescribedBy, style = props.style, children = props.children, onDismiss = props.onDismiss;
  var needsVerticalScrollBar = useScrollbarAsync(props, root);
  var onKeyDown = React.useCallback(function(ev) {
    switch (ev.which) {
      case KeyCodes.escape:
        if (onDismiss) {
          onDismiss(ev);
          ev.preventDefault();
          ev.stopPropagation();
        }
        break;
    }
  }, [onDismiss]);
  var win = useWindow();
  useOnEvent(win, "keydown", onKeyDown);
  return React.createElement("div", __assign({ ref: mergedRootRef }, getNativeProps(props, divProperties), { className, role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, onKeyDown, style: __assign({ overflowY: needsVerticalScrollBar ? "scroll" : void 0, outline: "none" }, style) }), children);
});
Popup.displayName = "Popup";

// node_modules/@fluentui/style-utilities/lib/utilities/buildClassMap.js
function buildClassMap(styles) {
  var classes = {};
  var _loop_1 = function(styleName2) {
    if (styles.hasOwnProperty(styleName2)) {
      var className_1;
      Object.defineProperty(classes, styleName2, {
        get: function() {
          if (className_1 === void 0) {
            className_1 = mergeStyles(styles[styleName2]).toString();
          }
          return className_1;
        },
        enumerable: true,
        configurable: true
      });
    }
  };
  for (var styleName in styles) {
    _loop_1(styleName);
  }
  return classes;
}

// node_modules/@fluentui/style-utilities/lib/utilities/icons.js
var ICON_SETTING_NAME = "icons";
var _iconSettings = GlobalSettings.getValue(ICON_SETTING_NAME, {
  __options: {
    disableWarnings: false,
    warnOnMissingIcons: true
  },
  __remapped: {}
});
var stylesheet = Stylesheet.getInstance();
if (stylesheet && stylesheet.onReset) {
  stylesheet.onReset(function() {
    for (var name_1 in _iconSettings) {
      if (_iconSettings.hasOwnProperty(name_1) && !!_iconSettings[name_1].subset) {
        _iconSettings[name_1].subset.className = void 0;
      }
    }
  });
}
var normalizeIconName = function(name) {
  return name.toLowerCase();
};
function registerIcons(iconSubset, options) {
  var subset = __assign(__assign({}, iconSubset), { isRegistered: false, className: void 0 });
  var icons = iconSubset.icons;
  options = options ? __assign(__assign({}, _iconSettings.__options), options) : _iconSettings.__options;
  for (var iconName in icons) {
    if (icons.hasOwnProperty(iconName)) {
      var code = icons[iconName];
      var normalizedIconName = normalizeIconName(iconName);
      if (_iconSettings[normalizedIconName]) {
        _warnDuplicateIcon(iconName);
      } else {
        _iconSettings[normalizedIconName] = {
          code,
          subset
        };
      }
    }
  }
}
function unregisterIcons(iconNames) {
  var options = _iconSettings.__options;
  var _loop_1 = function(iconName2) {
    var normalizedIconName = normalizeIconName(iconName2);
    if (_iconSettings[normalizedIconName]) {
      delete _iconSettings[normalizedIconName];
    } else {
      if (!options.disableWarnings) {
        warn('The icon "'.concat(iconName2, '" tried to unregister but was not registered.'));
      }
    }
    if (_iconSettings.__remapped[normalizedIconName]) {
      delete _iconSettings.__remapped[normalizedIconName];
    }
    Object.keys(_iconSettings.__remapped).forEach(function(key) {
      if (_iconSettings.__remapped[key] === normalizedIconName) {
        delete _iconSettings.__remapped[key];
      }
    });
  };
  for (var _i = 0, iconNames_1 = iconNames; _i < iconNames_1.length; _i++) {
    var iconName = iconNames_1[_i];
    _loop_1(iconName);
  }
}
function registerIconAlias(iconName, mappedToName) {
  _iconSettings.__remapped[normalizeIconName(iconName)] = normalizeIconName(mappedToName);
}
function getIcon(name) {
  var icon = void 0;
  var options = _iconSettings.__options;
  name = name ? normalizeIconName(name) : "";
  name = _iconSettings.__remapped[name] || name;
  if (name) {
    icon = _iconSettings[name];
    if (icon) {
      var subset = icon.subset;
      if (subset && subset.fontFace) {
        if (!subset.isRegistered) {
          fontFace(subset.fontFace);
          subset.isRegistered = true;
        }
        if (!subset.className) {
          subset.className = mergeStyles(subset.style, {
            fontFamily: subset.fontFace.fontFamily,
            fontWeight: subset.fontFace.fontWeight || "normal",
            fontStyle: subset.fontFace.fontStyle || "normal"
          });
        }
      }
    } else {
      if (!options.disableWarnings && options.warnOnMissingIcons) {
        warn('The icon "'.concat(name, '" was used but not registered. See https://github.com/microsoft/fluentui/wiki/Using-icons for more information.'));
      }
    }
  }
  return icon;
}
function setIconOptions(options) {
  _iconSettings.__options = __assign(__assign({}, _iconSettings.__options), options);
}
var _missingIcons = [];
var _missingIconsTimer = void 0;
function _warnDuplicateIcon(iconName) {
  var options = _iconSettings.__options;
  var warningDelay = 2e3;
  var maxIconsInMessage = 10;
  if (!options.disableWarnings) {
    _missingIcons.push(iconName);
    if (_missingIconsTimer === void 0) {
      _missingIconsTimer = setTimeout(function() {
        warn("Some icons were re-registered. Applications should only call registerIcons for any given icon once. Redefining what an icon is may have unintended consequences. Duplicates include: \n" + _missingIcons.slice(0, maxIconsInMessage).join(", ") + (_missingIcons.length > maxIconsInMessage ? " (+ ".concat(_missingIcons.length - maxIconsInMessage, " more)") : ""));
        _missingIconsTimer = void 0;
        _missingIcons = [];
      }, warningDelay);
    }
  }
}

// node_modules/@fluentui/style-utilities/lib/utilities/getIconClassName.js
var defaultIconStyles = {
  display: "inline-block"
};
function getIconClassName(name) {
  var className = "";
  var icon = getIcon(name);
  if (icon) {
    className = mergeStyles(icon.subset.className, defaultIconStyles, {
      selectors: {
        "::before": {
          content: '"'.concat(icon.code, '"')
        }
      }
    });
  }
  return className;
}

// node_modules/@fluentui/theme/lib/utilities/makeSemanticColors.js
function makeSemanticColors(p, e, s, isInverted, depComments) {
  if (depComments === void 0) {
    depComments = false;
  }
  var semanticColors = __assign({
    primaryButtonBorder: "transparent",
    errorText: !isInverted ? "#a4262c" : "#F1707B",
    messageText: !isInverted ? "#323130" : "#F3F2F1",
    messageLink: !isInverted ? "#005A9E" : "#6CB8F6",
    messageLinkHovered: !isInverted ? "#004578" : "#82C7FF",
    infoIcon: !isInverted ? "#605e5c" : "#C8C6C4",
    errorIcon: !isInverted ? "#A80000" : "#F1707B",
    blockingIcon: !isInverted ? "#FDE7E9" : "#442726",
    warningIcon: !isInverted ? "#797775" : "#C8C6C4",
    severeWarningIcon: !isInverted ? "#D83B01" : "#FCE100",
    successIcon: !isInverted ? "#107C10" : "#92C353",
    infoBackground: !isInverted ? "#f3f2f1" : "#323130",
    errorBackground: !isInverted ? "#FDE7E9" : "#442726",
    blockingBackground: !isInverted ? "#FDE7E9" : "#442726",
    warningBackground: !isInverted ? "#FFF4CE" : "#433519",
    severeWarningBackground: !isInverted ? "#FED9CC" : "#4F2A0F",
    successBackground: !isInverted ? "#DFF6DD" : "#393D1B",
    // deprecated
    warningHighlight: !isInverted ? "#ffb900" : "#fff100",
    successText: !isInverted ? "#107C10" : "#92c353"
  }, s);
  var fullSemanticColors = getSemanticColors(p, e, semanticColors, isInverted);
  return _fixDeprecatedSlots(fullSemanticColors, depComments);
}
function getSemanticColors(p, e, s, isInverted, depComments) {
  if (depComments === void 0) {
    depComments = false;
  }
  var result = {};
  var _a5 = p || {}, white = _a5.white, black = _a5.black, themePrimary = _a5.themePrimary, themeDark = _a5.themeDark, themeDarker = _a5.themeDarker, themeDarkAlt = _a5.themeDarkAlt, themeLighter = _a5.themeLighter, neutralLight = _a5.neutralLight, neutralLighter = _a5.neutralLighter, neutralDark = _a5.neutralDark, neutralQuaternary = _a5.neutralQuaternary, neutralQuaternaryAlt = _a5.neutralQuaternaryAlt, neutralPrimary = _a5.neutralPrimary, neutralSecondary = _a5.neutralSecondary, neutralSecondaryAlt = _a5.neutralSecondaryAlt, neutralTertiary = _a5.neutralTertiary, neutralTertiaryAlt = _a5.neutralTertiaryAlt, neutralLighterAlt = _a5.neutralLighterAlt, accent = _a5.accent;
  if (white) {
    result.bodyBackground = white;
    result.bodyFrameBackground = white;
    result.accentButtonText = white;
    result.buttonBackground = white;
    result.primaryButtonText = white;
    result.primaryButtonTextHovered = white;
    result.primaryButtonTextPressed = white;
    result.inputBackground = white;
    result.inputForegroundChecked = white;
    result.listBackground = white;
    result.menuBackground = white;
    result.cardStandoutBackground = white;
  }
  if (black) {
    result.bodyTextChecked = black;
    result.buttonTextCheckedHovered = black;
  }
  if (themePrimary) {
    result.link = themePrimary;
    result.primaryButtonBackground = themePrimary;
    result.inputBackgroundChecked = themePrimary;
    result.inputIcon = themePrimary;
    result.inputFocusBorderAlt = themePrimary;
    result.menuIcon = themePrimary;
    result.menuHeader = themePrimary;
    result.accentButtonBackground = themePrimary;
  }
  if (themeDark) {
    result.primaryButtonBackgroundPressed = themeDark;
    result.inputBackgroundCheckedHovered = themeDark;
    result.inputIconHovered = themeDark;
  }
  if (themeDarker) {
    result.linkHovered = themeDarker;
  }
  if (themeDarkAlt) {
    result.primaryButtonBackgroundHovered = themeDarkAlt;
  }
  if (themeLighter) {
    result.inputPlaceholderBackgroundChecked = themeLighter;
  }
  if (neutralLight) {
    result.bodyBackgroundChecked = neutralLight;
    result.bodyFrameDivider = neutralLight;
    result.bodyDivider = neutralLight;
    result.variantBorder = neutralLight;
    result.buttonBackgroundCheckedHovered = neutralLight;
    result.buttonBackgroundPressed = neutralLight;
    result.listItemBackgroundChecked = neutralLight;
    result.listHeaderBackgroundPressed = neutralLight;
    result.menuItemBackgroundPressed = neutralLight;
    result.menuItemBackgroundChecked = neutralLight;
  }
  if (neutralLighter) {
    result.bodyBackgroundHovered = neutralLighter;
    result.buttonBackgroundHovered = neutralLighter;
    result.buttonBackgroundDisabled = neutralLighter;
    result.buttonBorderDisabled = neutralLighter;
    result.primaryButtonBackgroundDisabled = neutralLighter;
    result.disabledBackground = neutralLighter;
    result.listItemBackgroundHovered = neutralLighter;
    result.listHeaderBackgroundHovered = neutralLighter;
    result.menuItemBackgroundHovered = neutralLighter;
  }
  if (neutralQuaternary) {
    result.primaryButtonTextDisabled = neutralQuaternary;
    result.disabledSubtext = neutralQuaternary;
  }
  if (neutralQuaternaryAlt) {
    result.listItemBackgroundCheckedHovered = neutralQuaternaryAlt;
  }
  if (neutralTertiary) {
    result.disabledBodyText = neutralTertiary;
    result.variantBorderHovered = (s === null || s === void 0 ? void 0 : s.variantBorderHovered) || neutralTertiary;
    result.buttonTextDisabled = neutralTertiary;
    result.inputIconDisabled = neutralTertiary;
    result.disabledText = neutralTertiary;
  }
  if (neutralPrimary) {
    result.bodyText = neutralPrimary;
    result.actionLink = neutralPrimary;
    result.buttonText = neutralPrimary;
    result.inputBorderHovered = neutralPrimary;
    result.inputText = neutralPrimary;
    result.listText = neutralPrimary;
    result.menuItemText = neutralPrimary;
  }
  if (neutralLighterAlt) {
    result.bodyStandoutBackground = neutralLighterAlt;
    result.defaultStateBackground = neutralLighterAlt;
  }
  if (neutralDark) {
    result.actionLinkHovered = neutralDark;
    result.buttonTextHovered = neutralDark;
    result.buttonTextChecked = neutralDark;
    result.buttonTextPressed = neutralDark;
    result.inputTextHovered = neutralDark;
    result.menuItemTextHovered = neutralDark;
  }
  if (neutralSecondary) {
    result.bodySubtext = neutralSecondary;
    result.focusBorder = neutralSecondary;
    result.inputBorder = neutralSecondary;
    result.smallInputBorder = neutralSecondary;
    result.inputPlaceholderText = neutralSecondary;
  }
  if (neutralSecondaryAlt) {
    result.buttonBorder = neutralSecondaryAlt;
  }
  if (neutralTertiaryAlt) {
    result.disabledBodySubtext = neutralTertiaryAlt;
    result.disabledBorder = neutralTertiaryAlt;
    result.buttonBackgroundChecked = neutralTertiaryAlt;
    result.menuDivider = neutralTertiaryAlt;
  }
  if (accent) {
    result.accentButtonBackground = accent;
  }
  if (e === null || e === void 0 ? void 0 : e.elevation4) {
    result.cardShadow = e.elevation4;
  }
  if (!isInverted && (e === null || e === void 0 ? void 0 : e.elevation8)) {
    result.cardShadowHovered = e.elevation8;
  } else if (result.variantBorderHovered) {
    result.cardShadowHovered = "0 0 1px " + result.variantBorderHovered;
  }
  result = __assign(__assign({}, result), s);
  return result;
}
function _fixDeprecatedSlots(s, depComments) {
  var dep = "";
  if (depComments === true) {
    dep = " /* @deprecated */";
  }
  s.listTextColor = s.listText + dep;
  s.menuItemBackgroundChecked += dep;
  s.warningHighlight += dep;
  s.warningText = s.messageText + dep;
  s.successText += dep;
  return s;
}

// node_modules/@fluentui/theme/lib/mergeThemes.js
function mergeThemes(theme, partialTheme) {
  var _a5, _b3, _c3;
  if (partialTheme === void 0) {
    partialTheme = {};
  }
  var mergedTheme = merge({}, theme, partialTheme, {
    semanticColors: getSemanticColors(partialTheme.palette, partialTheme.effects, partialTheme.semanticColors, partialTheme.isInverted === void 0 ? theme.isInverted : partialTheme.isInverted)
  });
  if (((_a5 = partialTheme.palette) === null || _a5 === void 0 ? void 0 : _a5.themePrimary) && !((_b3 = partialTheme.palette) === null || _b3 === void 0 ? void 0 : _b3.accent)) {
    mergedTheme.palette.accent = partialTheme.palette.themePrimary;
  }
  if (partialTheme.defaultFontStyle) {
    for (var _i = 0, _d3 = Object.keys(mergedTheme.fonts); _i < _d3.length; _i++) {
      var fontStyle = _d3[_i];
      mergedTheme.fonts[fontStyle] = merge(mergedTheme.fonts[fontStyle], partialTheme.defaultFontStyle, (_c3 = partialTheme === null || partialTheme === void 0 ? void 0 : partialTheme.fonts) === null || _c3 === void 0 ? void 0 : _c3[fontStyle]);
    }
  }
  return mergedTheme;
}

// node_modules/@fluentui/theme/lib/colors/FluentColors.js
var CommunicationColors;
(function(CommunicationColors2) {
  CommunicationColors2.shade30 = "#004578";
  CommunicationColors2.shade20 = "#005a9e";
  CommunicationColors2.shade10 = "#106ebe";
  CommunicationColors2.primary = "#0078d4";
  CommunicationColors2.tint10 = "#2b88d8";
  CommunicationColors2.tint20 = "#c7e0f4";
  CommunicationColors2.tint30 = "#deecf9";
  CommunicationColors2.tint40 = "#eff6fc";
})(CommunicationColors || (CommunicationColors = {}));
var NeutralColors;
(function(NeutralColors2) {
  NeutralColors2.black = "#000000";
  NeutralColors2.gray220 = "#11100f";
  NeutralColors2.gray210 = "#161514";
  NeutralColors2.gray200 = "#1b1a19";
  NeutralColors2.gray190 = "#201f1e";
  NeutralColors2.gray180 = "#252423";
  NeutralColors2.gray170 = "#292827";
  NeutralColors2.gray160 = "#323130";
  NeutralColors2.gray150 = "#3b3a39";
  NeutralColors2.gray140 = "#484644";
  NeutralColors2.gray130 = "#605e5c";
  NeutralColors2.gray120 = "#797775";
  NeutralColors2.gray110 = "#8a8886";
  NeutralColors2.gray100 = "#979593";
  NeutralColors2.gray90 = "#a19f9d";
  NeutralColors2.gray80 = "#b3b0ad";
  NeutralColors2.gray70 = "#bebbb8";
  NeutralColors2.gray60 = "#c8c6c4";
  NeutralColors2.gray50 = "#d2d0ce";
  NeutralColors2.gray40 = "#e1dfdd";
  NeutralColors2.gray30 = "#edebe9";
  NeutralColors2.gray20 = "#f3f2f1";
  NeutralColors2.gray10 = "#faf9f8";
  NeutralColors2.white = "#ffffff";
})(NeutralColors || (NeutralColors = {}));
var SharedColors;
(function(SharedColors2) {
  SharedColors2.pinkRed10 = "#750b1c";
  SharedColors2.red20 = "#a4262c";
  SharedColors2.red10 = "#d13438";
  SharedColors2.redOrange20 = "#603d30";
  SharedColors2.redOrange10 = "#da3b01";
  SharedColors2.orange30 = "#8e562e";
  SharedColors2.orange20 = "#ca5010";
  SharedColors2.orange10 = "#ffaa44";
  SharedColors2.yellow10 = "#fce100";
  SharedColors2.orangeYellow20 = "#986f0b";
  SharedColors2.orangeYellow10 = "#c19c00";
  SharedColors2.yellowGreen10 = "#8cbd18";
  SharedColors2.green20 = "#0b6a0b";
  SharedColors2.green10 = "#498205";
  SharedColors2.greenCyan10 = "#00ad56";
  SharedColors2.cyan40 = "#005e50";
  SharedColors2.cyan30 = "#005b70";
  SharedColors2.cyan20 = "#038387";
  SharedColors2.cyan10 = "#00b7c3";
  SharedColors2.cyanBlue20 = "#004e8c";
  SharedColors2.cyanBlue10 = "#0078d4";
  SharedColors2.blue10 = "#4f6bed";
  SharedColors2.blueMagenta40 = "#373277";
  SharedColors2.blueMagenta30 = "#5c2e91";
  SharedColors2.blueMagenta20 = "#8764b8";
  SharedColors2.blueMagenta10 = "#8378de";
  SharedColors2.magenta20 = "#881798";
  SharedColors2.magenta10 = "#c239b3";
  SharedColors2.magentaPink20 = "#9b0062";
  SharedColors2.magentaPink10 = "#e3008c";
  SharedColors2.gray40 = "#393939";
  SharedColors2.gray30 = "#7a7574";
  SharedColors2.gray20 = "#69797e";
  SharedColors2.gray10 = "#a0aeb2";
})(SharedColors || (SharedColors = {}));

// node_modules/@fluentui/theme/lib/colors/DefaultPalette.js
var DefaultPalette = {
  themeDarker: "#004578",
  themeDark: "#005a9e",
  themeDarkAlt: "#106ebe",
  themePrimary: "#0078d4",
  themeSecondary: "#2b88d8",
  themeTertiary: "#71afe5",
  themeLight: "#c7e0f4",
  themeLighter: "#deecf9",
  themeLighterAlt: "#eff6fc",
  black: "#000000",
  blackTranslucent40: "rgba(0,0,0,.4)",
  neutralDark: "#201f1e",
  neutralPrimary: "#323130",
  neutralPrimaryAlt: "#3b3a39",
  neutralSecondary: "#605e5c",
  neutralSecondaryAlt: "#8a8886",
  neutralTertiary: "#a19f9d",
  neutralTertiaryAlt: "#c8c6c4",
  neutralQuaternary: "#d2d0ce",
  neutralQuaternaryAlt: "#e1dfdd",
  neutralLight: "#edebe9",
  neutralLighter: "#f3f2f1",
  neutralLighterAlt: "#faf9f8",
  accent: "#0078d4",
  white: "#ffffff",
  whiteTranslucent40: "rgba(255,255,255,.4)",
  yellowDark: "#d29200",
  yellow: "#ffb900",
  yellowLight: "#fff100",
  orange: "#d83b01",
  orangeLight: "#ea4300",
  orangeLighter: "#ff8c00",
  redDark: "#a4262c",
  red: "#e81123",
  magentaDark: "#5c005c",
  magenta: "#b4009e",
  magentaLight: "#e3008c",
  purpleDark: "#32145a",
  purple: "#5c2d91",
  purpleLight: "#b4a0ff",
  blueDark: "#002050",
  blueMid: "#00188f",
  blue: "#0078d4",
  blueLight: "#00bcf2",
  tealDark: "#004b50",
  teal: "#008272",
  tealLight: "#00b294",
  greenDark: "#004b1c",
  green: "#107c10",
  greenLight: "#bad80a"
};

// node_modules/@fluentui/theme/lib/effects/FluentDepths.js
var Depths;
(function(Depths2) {
  Depths2.depth0 = "0 0 0 0 transparent";
  Depths2.depth4 = "0 1.6px 3.6px 0 rgba(0, 0, 0, 0.132), 0 0.3px 0.9px 0 rgba(0, 0, 0, 0.108)";
  Depths2.depth8 = "0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132), 0 0.6px 1.8px 0 rgba(0, 0, 0, 0.108)";
  Depths2.depth16 = "0 6.4px 14.4px 0 rgba(0, 0, 0, 0.132), 0 1.2px 3.6px 0 rgba(0, 0, 0, 0.108)";
  Depths2.depth64 = "0 25.6px 57.6px 0 rgba(0, 0, 0, 0.22), 0 4.8px 14.4px 0 rgba(0, 0, 0, 0.18)";
})(Depths || (Depths = {}));

// node_modules/@fluentui/theme/lib/effects/DefaultEffects.js
var DefaultEffects = {
  elevation4: Depths.depth4,
  elevation8: Depths.depth8,
  elevation16: Depths.depth16,
  elevation64: Depths.depth64,
  roundedCorner2: "2px",
  roundedCorner4: "4px",
  roundedCorner6: "6px"
};

// node_modules/@fluentui/theme/lib/spacing/DefaultSpacing.js
var DefaultSpacing = {
  s2: "4px",
  s1: "8px",
  m: "16px",
  l1: "20px",
  l2: "32px"
};

// node_modules/@fluentui/theme/lib/motion/FluentMotion.js
var fadeInAnimationName = keyframes({
  from: { opacity: 0 },
  to: { opacity: 1 }
});
var fadeOutAnimationName = keyframes({
  from: { opacity: 1 },
  to: { opacity: 0 }
});
var scaleDownInAnimationName = keyframes({
  from: { transform: "scale3d(1.15, 1.15, 1)" },
  to: { transform: "scale3d(1, 1, 1)" }
});
var scaleDownOutAnimationName = keyframes({
  from: { transform: "scale3d(1, 1, 1)" },
  to: { transform: "scale3d(0.9, 0.9, 1)" }
});
var slideLeftOutAnimationName = keyframes({
  from: { transform: "translate3d(0, 0, 0)" },
  to: { transform: "translate3d(-48px, 0, 0)" }
});
var slideRightOutAnimationName = keyframes({
  from: { transform: "translate3d(0, 0, 0)" },
  to: { transform: "translate3d(48px, 0, 0)" }
});
var slideLeftInAnimationName = keyframes({
  from: { transform: "translate3d(48px, 0, 0)" },
  to: { transform: "translate3d(0, 0, 0)" }
});
var slideRightInAnimationName = keyframes({
  from: { transform: "translate3d(-48px, 0, 0)" },
  to: { transform: "translate3d(0, 0, 0)" }
});
var slideUpOutAnimationName = keyframes({
  from: { transform: "translate3d(0, 0, 0)" },
  to: { transform: "translate3d(0, -48px, 0)" }
});
var slideDownOutAnimationName = keyframes({
  from: { transform: "translate3d(0, 0, 0)" },
  to: { transform: "translate3d(0, 48px, 0)" }
});
var slideUpInAnimationName = keyframes({
  from: { transform: "translate3d(0, 48px, 0)" },
  to: { transform: "translate3d(0, 0, 0)" }
});
var slideDownInAnimationName = keyframes({
  from: { transform: "translate3d(0, -48px, 0)" },
  to: { transform: "translate3d(0, 0, 0)" }
});
var MotionDurations;
(function(MotionDurations2) {
  MotionDurations2.duration1 = "100ms";
  MotionDurations2.duration2 = "200ms";
  MotionDurations2.duration3 = "300ms";
  MotionDurations2.duration4 = "400ms";
})(MotionDurations || (MotionDurations = {}));
var MotionTimings;
(function(MotionTimings2) {
  MotionTimings2.accelerate = "cubic-bezier(0.9, 0.1, 1, 0.2)";
  MotionTimings2.decelerate = "cubic-bezier(0.1, 0.9, 0.2, 1)";
  MotionTimings2.linear = "cubic-bezier(0, 0, 1, 1)";
  MotionTimings2.standard = "cubic-bezier(0.8, 0, 0.2, 1)";
})(MotionTimings || (MotionTimings = {}));
function _createAnimation(animationName, animationDuration, animationTimingFunction) {
  return "".concat(animationName, " ").concat(animationDuration, " ").concat(animationTimingFunction);
}
var MotionAnimations;
(function(MotionAnimations2) {
  MotionAnimations2.fadeIn = _createAnimation(fadeInAnimationName, MotionDurations.duration1, MotionTimings.linear);
  MotionAnimations2.fadeOut = _createAnimation(fadeOutAnimationName, MotionDurations.duration1, MotionTimings.linear);
  MotionAnimations2.scaleDownIn = _createAnimation(scaleDownInAnimationName, MotionDurations.duration3, MotionTimings.decelerate);
  MotionAnimations2.scaleDownOut = _createAnimation(scaleDownOutAnimationName, MotionDurations.duration3, MotionTimings.decelerate);
  MotionAnimations2.slideLeftOut = _createAnimation(slideLeftOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);
  MotionAnimations2.slideRightOut = _createAnimation(slideRightOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);
  MotionAnimations2.slideLeftIn = _createAnimation(slideLeftInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);
  MotionAnimations2.slideRightIn = _createAnimation(slideRightInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);
  MotionAnimations2.slideUpOut = _createAnimation(slideUpOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);
  MotionAnimations2.slideDownOut = _createAnimation(slideDownOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);
  MotionAnimations2.slideUpIn = _createAnimation(slideUpInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);
  MotionAnimations2.slideDownIn = _createAnimation(slideDownInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);
})(MotionAnimations || (MotionAnimations = {}));

// node_modules/@fluentui/theme/lib/motion/AnimationStyles.js
var EASING_FUNCTION_1 = "cubic-bezier(.1,.9,.2,1)";
var EASING_FUNCTION_2 = "cubic-bezier(.1,.25,.75,.9)";
var DURATION_1 = "0.167s";
var DURATION_2 = "0.267s";
var DURATION_3 = "0.367s";
var DURATION_4 = "0.467s";
var FADE_IN = keyframes({
  from: { opacity: 0 },
  to: { opacity: 1 }
});
var FADE_OUT = keyframes({
  from: { opacity: 1 },
  to: { opacity: 0, visibility: "hidden" }
});
var SLIDE_RIGHT_IN10 = _createSlideInX(-10);
var SLIDE_RIGHT_IN20 = _createSlideInX(-20);
var SLIDE_RIGHT_IN40 = _createSlideInX(-40);
var SLIDE_RIGHT_IN400 = _createSlideInX(-400);
var SLIDE_LEFT_IN10 = _createSlideInX(10);
var SLIDE_LEFT_IN20 = _createSlideInX(20);
var SLIDE_LEFT_IN40 = _createSlideInX(40);
var SLIDE_LEFT_IN400 = _createSlideInX(400);
var SLIDE_UP_IN10 = _createSlideInY(10);
var SLIDE_UP_IN20 = _createSlideInY(20);
var SLIDE_DOWN_IN10 = _createSlideInY(-10);
var SLIDE_DOWN_IN20 = _createSlideInY(-20);
var SLIDE_RIGHT_OUT10 = _createSlideOutX(10);
var SLIDE_RIGHT_OUT20 = _createSlideOutX(20);
var SLIDE_RIGHT_OUT40 = _createSlideOutX(40);
var SLIDE_RIGHT_OUT400 = _createSlideOutX(400);
var SLIDE_LEFT_OUT10 = _createSlideOutX(-10);
var SLIDE_LEFT_OUT20 = _createSlideOutX(-20);
var SLIDE_LEFT_OUT40 = _createSlideOutX(-40);
var SLIDE_LEFT_OUT400 = _createSlideOutX(-400);
var SLIDE_UP_OUT10 = _createSlideOutY(-10);
var SLIDE_UP_OUT20 = _createSlideOutY(-20);
var SLIDE_DOWN_OUT10 = _createSlideOutY(10);
var SLIDE_DOWN_OUT20 = _createSlideOutY(20);
var SCALE_UP100 = keyframes({
  from: { transform: "scale3d(.98,.98,1)" },
  to: { transform: "scale3d(1,1,1)" }
});
var SCALE_DOWN98 = keyframes({
  from: { transform: "scale3d(1,1,1)" },
  to: { transform: "scale3d(.98,.98,1)" }
});
var SCALE_DOWN100 = keyframes({
  from: { transform: "scale3d(1.03,1.03,1)" },
  to: { transform: "scale3d(1,1,1)" }
});
var SCALE_UP103 = keyframes({
  from: { transform: "scale3d(1,1,1)" },
  to: { transform: "scale3d(1.03,1.03,1)" }
});
var ROTATE90 = keyframes({
  from: { transform: "rotateZ(0deg)" },
  to: { transform: "rotateZ(90deg)" }
});
var ROTATE_N90 = keyframes({
  from: { transform: "rotateZ(0deg)" },
  to: { transform: "rotateZ(-90deg)" }
});
var AnimationVariables = {
  easeFunction1: EASING_FUNCTION_1,
  easeFunction2: EASING_FUNCTION_2,
  durationValue1: DURATION_1,
  durationValue2: DURATION_2,
  durationValue3: DURATION_3,
  durationValue4: DURATION_4
};
var AnimationStyles = {
  slideRightIn10: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_RIGHT_IN10), DURATION_3, EASING_FUNCTION_1),
  slideRightIn20: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_RIGHT_IN20), DURATION_3, EASING_FUNCTION_1),
  slideRightIn40: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_RIGHT_IN40), DURATION_3, EASING_FUNCTION_1),
  slideRightIn400: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_RIGHT_IN400), DURATION_3, EASING_FUNCTION_1),
  slideLeftIn10: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_LEFT_IN10), DURATION_3, EASING_FUNCTION_1),
  slideLeftIn20: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_LEFT_IN20), DURATION_3, EASING_FUNCTION_1),
  slideLeftIn40: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_LEFT_IN40), DURATION_3, EASING_FUNCTION_1),
  slideLeftIn400: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_LEFT_IN400), DURATION_3, EASING_FUNCTION_1),
  slideUpIn10: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_UP_IN10), DURATION_3, EASING_FUNCTION_1),
  slideUpIn20: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_UP_IN20), DURATION_3, EASING_FUNCTION_1),
  slideDownIn10: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_DOWN_IN10), DURATION_3, EASING_FUNCTION_1),
  slideDownIn20: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_DOWN_IN20), DURATION_3, EASING_FUNCTION_1),
  slideRightOut10: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_RIGHT_OUT10), DURATION_3, EASING_FUNCTION_1),
  slideRightOut20: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_RIGHT_OUT20), DURATION_3, EASING_FUNCTION_1),
  slideRightOut40: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_RIGHT_OUT40), DURATION_3, EASING_FUNCTION_1),
  slideRightOut400: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_RIGHT_OUT400), DURATION_3, EASING_FUNCTION_1),
  slideLeftOut10: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_LEFT_OUT10), DURATION_3, EASING_FUNCTION_1),
  slideLeftOut20: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_LEFT_OUT20), DURATION_3, EASING_FUNCTION_1),
  slideLeftOut40: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_LEFT_OUT40), DURATION_3, EASING_FUNCTION_1),
  slideLeftOut400: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_LEFT_OUT400), DURATION_3, EASING_FUNCTION_1),
  slideUpOut10: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_UP_OUT10), DURATION_3, EASING_FUNCTION_1),
  slideUpOut20: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_UP_OUT20), DURATION_3, EASING_FUNCTION_1),
  slideDownOut10: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_DOWN_OUT10), DURATION_3, EASING_FUNCTION_1),
  slideDownOut20: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_DOWN_OUT20), DURATION_3, EASING_FUNCTION_1),
  scaleUpIn100: _createAnimation2("".concat(FADE_IN, ",").concat(SCALE_UP100), DURATION_3, EASING_FUNCTION_1),
  scaleDownIn100: _createAnimation2("".concat(FADE_IN, ",").concat(SCALE_DOWN100), DURATION_3, EASING_FUNCTION_1),
  scaleUpOut103: _createAnimation2("".concat(FADE_OUT, ",").concat(SCALE_UP103), DURATION_1, EASING_FUNCTION_2),
  scaleDownOut98: _createAnimation2("".concat(FADE_OUT, ",").concat(SCALE_DOWN98), DURATION_1, EASING_FUNCTION_2),
  fadeIn100: _createAnimation2(FADE_IN, DURATION_1, EASING_FUNCTION_2),
  fadeIn200: _createAnimation2(FADE_IN, DURATION_2, EASING_FUNCTION_2),
  fadeIn400: _createAnimation2(FADE_IN, DURATION_3, EASING_FUNCTION_2),
  fadeIn500: _createAnimation2(FADE_IN, DURATION_4, EASING_FUNCTION_2),
  fadeOut100: _createAnimation2(FADE_OUT, DURATION_1, EASING_FUNCTION_2),
  fadeOut200: _createAnimation2(FADE_OUT, DURATION_2, EASING_FUNCTION_2),
  fadeOut400: _createAnimation2(FADE_OUT, DURATION_3, EASING_FUNCTION_2),
  fadeOut500: _createAnimation2(FADE_OUT, DURATION_4, EASING_FUNCTION_2),
  rotate90deg: _createAnimation2(ROTATE90, "0.1s", EASING_FUNCTION_2),
  rotateN90deg: _createAnimation2(ROTATE_N90, "0.1s", EASING_FUNCTION_2)
  // expandCollapse 100/200/400, delay 100/200
};
function _createAnimation2(animationName, animationDuration, animationTimingFunction) {
  return {
    animationName,
    animationDuration,
    animationTimingFunction,
    animationFillMode: "both"
  };
}
function _createSlideInX(fromX) {
  return keyframes({
    from: { transform: "translate3d(".concat(fromX, "px,0,0)"), pointerEvents: "none" },
    to: { transform: "translate3d(0,0,0)", pointerEvents: "auto" }
  });
}
function _createSlideInY(fromY) {
  return keyframes({
    from: { transform: "translate3d(0,".concat(fromY, "px,0)"), pointerEvents: "none" },
    to: { transform: "translate3d(0,0,0)", pointerEvents: "auto" }
  });
}
function _createSlideOutX(toX) {
  return keyframes({
    from: { transform: "translate3d(0,0,0)" },
    to: { transform: "translate3d(".concat(toX, "px,0,0)") }
  });
}
function _createSlideOutY(toY) {
  return keyframes({
    from: { transform: "translate3d(0,0,0)" },
    to: { transform: "translate3d(0,".concat(toY, "px,0)") }
  });
}

// node_modules/@fluentui/theme/lib/fonts/FluentFonts.js
var LocalizedFontNames;
(function(LocalizedFontNames2) {
  LocalizedFontNames2.Arabic = "Segoe UI Web (Arabic)";
  LocalizedFontNames2.Cyrillic = "Segoe UI Web (Cyrillic)";
  LocalizedFontNames2.EastEuropean = "Segoe UI Web (East European)";
  LocalizedFontNames2.Greek = "Segoe UI Web (Greek)";
  LocalizedFontNames2.Hebrew = "Segoe UI Web (Hebrew)";
  LocalizedFontNames2.Thai = "Leelawadee UI Web";
  LocalizedFontNames2.Vietnamese = "Segoe UI Web (Vietnamese)";
  LocalizedFontNames2.WestEuropean = "Segoe UI Web (West European)";
  LocalizedFontNames2.Selawik = "Selawik Web";
  LocalizedFontNames2.Armenian = "Segoe UI Web (Armenian)";
  LocalizedFontNames2.Georgian = "Segoe UI Web (Georgian)";
})(LocalizedFontNames || (LocalizedFontNames = {}));
var LocalizedFontFamilies;
(function(LocalizedFontFamilies2) {
  LocalizedFontFamilies2.Arabic = "'".concat(LocalizedFontNames.Arabic, "'");
  LocalizedFontFamilies2.ChineseSimplified = "'Microsoft Yahei UI', Verdana, Simsun";
  LocalizedFontFamilies2.ChineseTraditional = "'Microsoft Jhenghei UI', Pmingliu";
  LocalizedFontFamilies2.Cyrillic = "'".concat(LocalizedFontNames.Cyrillic, "'");
  LocalizedFontFamilies2.EastEuropean = "'".concat(LocalizedFontNames.EastEuropean, "'");
  LocalizedFontFamilies2.Greek = "'".concat(LocalizedFontNames.Greek, "'");
  LocalizedFontFamilies2.Hebrew = "'".concat(LocalizedFontNames.Hebrew, "'");
  LocalizedFontFamilies2.Hindi = "'Nirmala UI'";
  LocalizedFontFamilies2.Japanese = "'Yu Gothic UI', 'Meiryo UI', Meiryo, 'MS Pgothic', Osaka";
  LocalizedFontFamilies2.Korean = "'Malgun Gothic', Gulim";
  LocalizedFontFamilies2.Selawik = "'".concat(LocalizedFontNames.Selawik, "'");
  LocalizedFontFamilies2.Thai = "'Leelawadee UI Web', 'Kmer UI'";
  LocalizedFontFamilies2.Vietnamese = "'".concat(LocalizedFontNames.Vietnamese, "'");
  LocalizedFontFamilies2.WestEuropean = "'".concat(LocalizedFontNames.WestEuropean, "'");
  LocalizedFontFamilies2.Armenian = "'".concat(LocalizedFontNames.Armenian, "'");
  LocalizedFontFamilies2.Georgian = "'".concat(LocalizedFontNames.Georgian, "'");
})(LocalizedFontFamilies || (LocalizedFontFamilies = {}));
var FontSizes;
(function(FontSizes2) {
  FontSizes2.size10 = "10px";
  FontSizes2.size12 = "12px";
  FontSizes2.size14 = "14px";
  FontSizes2.size16 = "16px";
  FontSizes2.size18 = "18px";
  FontSizes2.size20 = "20px";
  FontSizes2.size24 = "24px";
  FontSizes2.size28 = "28px";
  FontSizes2.size32 = "32px";
  FontSizes2.size42 = "42px";
  FontSizes2.size68 = "68px";
  FontSizes2.mini = "10px";
  FontSizes2.xSmall = "10px";
  FontSizes2.small = "12px";
  FontSizes2.smallPlus = "12px";
  FontSizes2.medium = "14px";
  FontSizes2.mediumPlus = "16px";
  FontSizes2.icon = "16px";
  FontSizes2.large = "18px";
  FontSizes2.xLarge = "20px";
  FontSizes2.xLargePlus = "24px";
  FontSizes2.xxLarge = "28px";
  FontSizes2.xxLargePlus = "32px";
  FontSizes2.superLarge = "42px";
  FontSizes2.mega = "68px";
})(FontSizes || (FontSizes = {}));
var FontWeights;
(function(FontWeights2) {
  FontWeights2.light = 100;
  FontWeights2.semilight = 300;
  FontWeights2.regular = 400;
  FontWeights2.semibold = 600;
  FontWeights2.bold = 700;
})(FontWeights || (FontWeights = {}));
var IconFontSizes;
(function(IconFontSizes2) {
  IconFontSizes2.xSmall = "10px";
  IconFontSizes2.small = "12px";
  IconFontSizes2.medium = "16px";
  IconFontSizes2.large = "20px";
})(IconFontSizes || (IconFontSizes = {}));

// node_modules/@fluentui/theme/lib/fonts/createFontStyles.js
var FontFamilyFallbacks = "'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', sans-serif";
var defaultFontFamily = "'Segoe UI', '".concat(LocalizedFontNames.WestEuropean, "'");
var LanguageToFontMap = {
  ar: LocalizedFontFamilies.Arabic,
  bg: LocalizedFontFamilies.Cyrillic,
  cs: LocalizedFontFamilies.EastEuropean,
  el: LocalizedFontFamilies.Greek,
  et: LocalizedFontFamilies.EastEuropean,
  he: LocalizedFontFamilies.Hebrew,
  hi: LocalizedFontFamilies.Hindi,
  hr: LocalizedFontFamilies.EastEuropean,
  hu: LocalizedFontFamilies.EastEuropean,
  ja: LocalizedFontFamilies.Japanese,
  kk: LocalizedFontFamilies.EastEuropean,
  ko: LocalizedFontFamilies.Korean,
  lt: LocalizedFontFamilies.EastEuropean,
  lv: LocalizedFontFamilies.EastEuropean,
  pl: LocalizedFontFamilies.EastEuropean,
  ru: LocalizedFontFamilies.Cyrillic,
  sk: LocalizedFontFamilies.EastEuropean,
  "sr-latn": LocalizedFontFamilies.EastEuropean,
  th: LocalizedFontFamilies.Thai,
  tr: LocalizedFontFamilies.EastEuropean,
  uk: LocalizedFontFamilies.Cyrillic,
  vi: LocalizedFontFamilies.Vietnamese,
  "zh-hans": LocalizedFontFamilies.ChineseSimplified,
  "zh-hant": LocalizedFontFamilies.ChineseTraditional,
  hy: LocalizedFontFamilies.Armenian,
  ka: LocalizedFontFamilies.Georgian
};
function _fontFamilyWithFallbacks(fontFamily) {
  return "".concat(fontFamily, ", ").concat(FontFamilyFallbacks);
}
function _getLocalizedFontFamily(language) {
  for (var lang in LanguageToFontMap) {
    if (LanguageToFontMap.hasOwnProperty(lang) && language && lang.indexOf(language) === 0) {
      return LanguageToFontMap[lang];
    }
  }
  return defaultFontFamily;
}
function _createFont(size, weight, fontFamily) {
  return {
    fontFamily,
    MozOsxFontSmoothing: "grayscale",
    WebkitFontSmoothing: "antialiased",
    fontSize: size,
    fontWeight: weight
  };
}
function createFontStyles(localeCode) {
  var localizedFont = _getLocalizedFontFamily(localeCode);
  var fontFamilyWithFallback = _fontFamilyWithFallbacks(localizedFont);
  var fontStyles = {
    tiny: _createFont(FontSizes.mini, FontWeights.regular, fontFamilyWithFallback),
    xSmall: _createFont(FontSizes.xSmall, FontWeights.regular, fontFamilyWithFallback),
    small: _createFont(FontSizes.small, FontWeights.regular, fontFamilyWithFallback),
    smallPlus: _createFont(FontSizes.smallPlus, FontWeights.regular, fontFamilyWithFallback),
    medium: _createFont(FontSizes.medium, FontWeights.regular, fontFamilyWithFallback),
    mediumPlus: _createFont(FontSizes.mediumPlus, FontWeights.regular, fontFamilyWithFallback),
    large: _createFont(FontSizes.large, FontWeights.regular, fontFamilyWithFallback),
    xLarge: _createFont(FontSizes.xLarge, FontWeights.semibold, fontFamilyWithFallback),
    xLargePlus: _createFont(FontSizes.xLargePlus, FontWeights.semibold, fontFamilyWithFallback),
    xxLarge: _createFont(FontSizes.xxLarge, FontWeights.semibold, fontFamilyWithFallback),
    xxLargePlus: _createFont(FontSizes.xxLargePlus, FontWeights.semibold, fontFamilyWithFallback),
    superLarge: _createFont(FontSizes.superLarge, FontWeights.semibold, fontFamilyWithFallback),
    mega: _createFont(FontSizes.mega, FontWeights.semibold, fontFamilyWithFallback)
  };
  return fontStyles;
}

// node_modules/@fluentui/theme/lib/fonts/DefaultFontStyles.js
var DefaultBaseUrl = "https://res-1.cdn.office.net/files/fabric-cdn-prod_20221209.001/assets";
var DefaultFontStyles = createFontStyles(getLanguage());
function _registerFontFace(fontFamily, url, fontWeight, localFontName) {
  fontFamily = "'".concat(fontFamily, "'");
  var localFontSrc = localFontName !== void 0 ? "local('".concat(localFontName, "'),") : "";
  fontFace({
    fontFamily,
    src: localFontSrc + "url('".concat(url, ".woff2') format('woff2'),") + "url('".concat(url, ".woff') format('woff')"),
    fontWeight,
    fontStyle: "normal",
    fontDisplay: "swap"
  });
}
function _registerFontFaceSet(baseUrl, fontFamily, cdnFolder, cdnFontName, localFontName) {
  if (cdnFontName === void 0) {
    cdnFontName = "segoeui";
  }
  var urlBase = "".concat(baseUrl, "/").concat(cdnFolder, "/").concat(cdnFontName);
  _registerFontFace(fontFamily, urlBase + "-light", FontWeights.light, localFontName && localFontName + " Light");
  _registerFontFace(fontFamily, urlBase + "-semilight", FontWeights.semilight, localFontName && localFontName + " SemiLight");
  _registerFontFace(fontFamily, urlBase + "-regular", FontWeights.regular, localFontName);
  _registerFontFace(fontFamily, urlBase + "-semibold", FontWeights.semibold, localFontName && localFontName + " SemiBold");
  _registerFontFace(fontFamily, urlBase + "-bold", FontWeights.bold, localFontName && localFontName + " Bold");
}
function registerDefaultFontFaces(baseUrl) {
  if (baseUrl) {
    var fontUrl = "".concat(baseUrl, "/fonts");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Thai, "leelawadeeui-thai", "leelawadeeui");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Arabic, "segoeui-arabic");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Cyrillic, "segoeui-cyrillic");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.EastEuropean, "segoeui-easteuropean");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Greek, "segoeui-greek");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Hebrew, "segoeui-hebrew");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Vietnamese, "segoeui-vietnamese");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.WestEuropean, "segoeui-westeuropean", "segoeui", "Segoe UI");
    _registerFontFaceSet(fontUrl, LocalizedFontFamilies.Selawik, "selawik", "selawik");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Armenian, "segoeui-armenian");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Georgian, "segoeui-georgian");
    _registerFontFace("Leelawadee UI Web", "".concat(fontUrl, "/leelawadeeui-thai/leelawadeeui-semilight"), FontWeights.light);
    _registerFontFace("Leelawadee UI Web", "".concat(fontUrl, "/leelawadeeui-thai/leelawadeeui-bold"), FontWeights.semibold);
  }
}
function _getFontBaseUrl() {
  var _a5, _b3;
  var fabricConfig = (_a5 = getWindow()) === null || _a5 === void 0 ? void 0 : _a5.FabricConfig;
  return (_b3 = fabricConfig === null || fabricConfig === void 0 ? void 0 : fabricConfig.fontBaseUrl) !== null && _b3 !== void 0 ? _b3 : DefaultBaseUrl;
}
registerDefaultFontFaces(_getFontBaseUrl());

// node_modules/@fluentui/theme/lib/createTheme.js
function createTheme(theme, depComments) {
  if (theme === void 0) {
    theme = {};
  }
  if (depComments === void 0) {
    depComments = false;
  }
  var isInverted = !!theme.isInverted;
  var baseTheme = {
    palette: DefaultPalette,
    effects: DefaultEffects,
    fonts: DefaultFontStyles,
    spacing: DefaultSpacing,
    isInverted,
    disableGlobalClassNames: false,
    semanticColors: makeSemanticColors(DefaultPalette, DefaultEffects, void 0, isInverted, depComments),
    rtl: void 0
  };
  return mergeThemes(baseTheme, theme);
}

// node_modules/@fluentui/theme/lib/FluentTheme.js
var FluentTheme = createTheme({});

// node_modules/@fluentui/theme/lib/version.js
setVersion("@fluentui/theme", "2.6.32");

// node_modules/@fluentui/style-utilities/lib/styles/CommonStyles.js
var HighContrastSelector = "@media screen and (-ms-high-contrast: active), screen and (forced-colors: active)";
var HighContrastSelectorWhite = (
  // eslint-disable-next-line @fluentui/max-len
  "@media screen and (-ms-high-contrast: black-on-white), screen and (forced-colors: active) and (prefers-color-scheme: light)"
);
var HighContrastSelectorBlack = (
  // eslint-disable-next-line @fluentui/max-len
  "@media screen and (-ms-high-contrast: white-on-black), screen and (forced-colors: active) and (prefers-color-scheme: dark)"
);
var EdgeChromiumHighContrastSelector = "@media screen and (-ms-high-contrast: active), screen and (forced-colors: active)";
var ScreenWidthMinSmall = 320;
var ScreenWidthMinMedium = 480;
var ScreenWidthMinLarge = 640;
var ScreenWidthMinXLarge = 1024;
var ScreenWidthMinXXLarge = 1366;
var ScreenWidthMinXXXLarge = 1920;
var ScreenWidthMaxSmall = ScreenWidthMinMedium - 1;
var ScreenWidthMaxMedium = ScreenWidthMinLarge - 1;
var ScreenWidthMaxLarge = ScreenWidthMinXLarge - 1;
var ScreenWidthMaxXLarge = ScreenWidthMinXXLarge - 1;
var ScreenWidthMaxXXLarge = ScreenWidthMinXXXLarge - 1;
var ScreenWidthMinUhfMobile = 768;
function getScreenSelector(min, max) {
  var minSelector = typeof min === "number" ? " and (min-width: ".concat(min, "px)") : "";
  var maxSelector = typeof max === "number" ? " and (max-width: ".concat(max, "px)") : "";
  return "@media only screen".concat(minSelector).concat(maxSelector);
}
function getHighContrastNoAdjustStyle() {
  return {
    forcedColorAdjust: "none",
    MsHighContrastAdjust: "none"
  };
}
function getEdgeChromiumNoHighContrastAdjustSelector() {
  var _a5;
  return _a5 = {}, // eslint-disable-next-line deprecation/deprecation
  _a5[EdgeChromiumHighContrastSelector] = {
    forcedColorAdjust: "none",
    MsHighContrastAdjust: "none"
  }, _a5;
}

// node_modules/@fluentui/style-utilities/lib/styles/zIndexes.js
var ZIndexes;
(function(ZIndexes2) {
  ZIndexes2.Nav = 1;
  ZIndexes2.ScrollablePane = 1;
  ZIndexes2.FocusStyle = 1;
  ZIndexes2.Coachmark = 1e3;
  ZIndexes2.Layer = 1e6;
  ZIndexes2.KeytipLayer = 1000001;
})(ZIndexes || (ZIndexes = {}));

// node_modules/@fluentui/style-utilities/lib/styles/getFocusStyle.js
function getFocusStyle(theme, insetOrOptions, position, highContrastStyle, borderColor, outlineColor, isFocusedOnly, borderRadius) {
  if (typeof insetOrOptions === "number" || !insetOrOptions) {
    return _getFocusStyleInternal(theme, {
      inset: insetOrOptions,
      position,
      highContrastStyle,
      borderColor,
      outlineColor,
      isFocusedOnly,
      borderRadius
    });
  } else {
    return _getFocusStyleInternal(theme, insetOrOptions);
  }
}
function _getFocusStyleInternal(theme, options) {
  var _a5, _b3;
  if (options === void 0) {
    options = {};
  }
  var borderRadius = options.borderRadius, _c3 = options.inset, inset = _c3 === void 0 ? 0 : _c3, _d3 = options.width, width = _d3 === void 0 ? 1 : _d3, _e2 = options.position, position = _e2 === void 0 ? "relative" : _e2, highContrastStyle = options.highContrastStyle, _f = options.borderColor, borderColor = _f === void 0 ? theme.palette.white : _f, _g = options.outlineColor, outlineColor = _g === void 0 ? theme.palette.neutralSecondary : _g, _h = options.isFocusedOnly, isFocusedOnly = _h === void 0 ? true : _h, pointerEvents = options.pointerEvents;
  return {
    // Clear browser-specific focus styles and use 'transparent' as placeholder for focus style.
    outline: "transparent",
    // Requirement because pseudo-element is absolutely positioned.
    position,
    selectors: (_a5 = {
      // Clear the focus border in Firefox.
      // Reference: http://stackoverflow.com/a/199319/1436671
      "::-moz-focus-inner": {
        border: "0"
      }
    }, // When the element that uses this mixin is in a :focus state, add a pseudo-element to
    // create a border.
    _a5[".".concat(IsFocusVisibleClassName, " &").concat(isFocusedOnly ? ":focus" : "", ":after")] = {
      content: '""',
      position: "absolute",
      pointerEvents,
      left: inset + 1,
      top: inset + 1,
      bottom: inset + 1,
      right: inset + 1,
      border: "".concat(width, "px solid ").concat(borderColor),
      outline: "".concat(width, "px solid ").concat(outlineColor),
      zIndex: ZIndexes.FocusStyle,
      borderRadius,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = highContrastStyle, _b3)
    }, _a5)
  };
}
function focusClear() {
  return {
    selectors: {
      "&::-moz-focus-inner": {
        // Clear the focus border in Firefox. Reference: http://stackoverflow.com/a/199319/1436671
        border: 0
      },
      "&": {
        // Clear browser specific focus styles and use transparent as placeholder for focus style
        outline: "transparent"
      }
    }
  };
}
function getFocusOutlineStyle(theme, inset, width, color) {
  var _a5;
  if (inset === void 0) {
    inset = 0;
  }
  if (width === void 0) {
    width = 1;
  }
  return {
    selectors: (_a5 = {}, _a5[":global(".concat(IsFocusVisibleClassName, ") &:focus")] = {
      outline: "".concat(width, " solid ").concat(color || theme.palette.neutralSecondary),
      outlineOffset: "".concat(-inset, "px")
    }, _a5)
  };
}
var getInputFocusStyle = function(borderColor, borderRadius, borderType, borderPosition) {
  var _a5, _b3, _c3;
  if (borderType === void 0) {
    borderType = "border";
  }
  if (borderPosition === void 0) {
    borderPosition = -1;
  }
  var isBorderBottom = borderType === "borderBottom";
  return {
    borderColor,
    selectors: {
      ":after": (_a5 = {
        pointerEvents: "none",
        content: "''",
        position: "absolute",
        left: isBorderBottom ? 0 : borderPosition,
        top: borderPosition,
        bottom: borderPosition,
        right: isBorderBottom ? 0 : borderPosition
      }, _a5[borderType] = "2px solid ".concat(borderColor), _a5.borderRadius = borderRadius, _a5.width = borderType === "borderBottom" ? "100%" : void 0, _a5.selectors = (_b3 = {}, _b3[HighContrastSelector] = (_c3 = {}, _c3[borderType === "border" ? "borderColor" : "borderBottomColor"] = "Highlight", _c3), _b3), _a5)
    }
  };
};

// node_modules/@fluentui/style-utilities/lib/styles/hiddenContentStyle.js
var hiddenContentStyle = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  padding: 0,
  border: 0,
  overflow: "hidden",
  whiteSpace: "nowrap"
};

// node_modules/@fluentui/style-utilities/lib/styles/PulsingBeaconAnimationStyles.js
var DEFAULT_DURATION = "14s";
var DEFAULT_DELAY = "2s";
var DEFAULT_ITERATION_COUNT = "1";
function _continuousPulseStepOne(beaconColorOne, innerDimension) {
  return {
    borderColor: beaconColorOne,
    borderWidth: "0px",
    width: innerDimension,
    height: innerDimension
  };
}
function _continuousPulseStepTwo(borderWidth) {
  return {
    opacity: 1,
    borderWidth
  };
}
function _continuousPulseStepThree() {
  return {
    opacity: 1
  };
}
function _continuousPulseStepFour(beaconColorTwo, outerDimension) {
  return {
    borderWidth: "0",
    width: outerDimension,
    height: outerDimension,
    opacity: 0,
    borderColor: beaconColorTwo
  };
}
function _continuousPulseStepFive(beaconColorOne, innerDimension) {
  return __assign(__assign({}, _continuousPulseStepOne(beaconColorOne, innerDimension)), {
    opacity: 0
  });
}
function _continuousPulseAnimationDouble(beaconColorOne, beaconColorTwo, innerDimension, outerDimension, borderWidth) {
  return keyframes({
    "0%": _continuousPulseStepOne(beaconColorOne, innerDimension),
    "1.42%": _continuousPulseStepTwo(borderWidth),
    "3.57%": _continuousPulseStepThree(),
    "7.14%": _continuousPulseStepFour(beaconColorTwo, outerDimension),
    "8%": _continuousPulseStepFive(beaconColorOne, innerDimension),
    "29.99%": _continuousPulseStepFive(beaconColorOne, innerDimension),
    "30%": _continuousPulseStepOne(beaconColorOne, innerDimension),
    "31.42%": _continuousPulseStepTwo(borderWidth),
    "33.57%": _continuousPulseStepThree(),
    "37.14%": _continuousPulseStepFour(beaconColorTwo, outerDimension),
    "38%": _continuousPulseStepFive(beaconColorOne, innerDimension),
    "79.42%": _continuousPulseStepFive(beaconColorOne, innerDimension),
    "79.43": _continuousPulseStepOne(beaconColorOne, innerDimension),
    "81.85": _continuousPulseStepTwo(borderWidth),
    "83.42": _continuousPulseStepThree(),
    "87%": _continuousPulseStepFour(beaconColorTwo, outerDimension),
    "100%": {}
  });
}
function _continuousPulseAnimationSingle(beaconColorOne, beaconColorTwo, innerDimension, outerDimension, borderWidth) {
  return keyframes({
    "0%": _continuousPulseStepOne(beaconColorOne, innerDimension),
    "14.2%": _continuousPulseStepTwo(borderWidth),
    "35.7%": _continuousPulseStepThree(),
    "71.4%": _continuousPulseStepFour(beaconColorTwo, outerDimension),
    "100%": {}
  });
}
function _createDefaultAnimation(animationName, delayLength) {
  return {
    animationName,
    animationIterationCount: DEFAULT_ITERATION_COUNT,
    animationDuration: DEFAULT_DURATION,
    animationDelay: delayLength || DEFAULT_DELAY
  };
}
var PulsingBeaconAnimationStyles = {
  continuousPulseAnimationDouble: _continuousPulseAnimationDouble,
  continuousPulseAnimationSingle: _continuousPulseAnimationSingle,
  createDefaultAnimation: _createDefaultAnimation
};

// node_modules/@fluentui/style-utilities/lib/styles/getGlobalClassNames.js
var _getGlobalClassNames = memoizeFunction(function(classNames2, disableGlobalClassNames) {
  var styleSheet = Stylesheet.getInstance();
  if (disableGlobalClassNames) {
    return Object.keys(classNames2).reduce(function(acc, className) {
      acc[className] = styleSheet.getClassName(classNames2[className]);
      return acc;
    }, {});
  }
  return classNames2;
});
function getGlobalClassNames(classNames2, theme, disableGlobalClassNames) {
  return _getGlobalClassNames(classNames2, disableGlobalClassNames !== void 0 ? disableGlobalClassNames : theme.disableGlobalClassNames);
}

// node_modules/@fluentui/style-utilities/lib/styles/scheme.js
function getThemedContext(context, scheme, theme) {
  var newContext = context;
  var newSettings;
  var schemeSource = theme || Customizations.getSettings(["theme"], void 0, context.customizations).theme;
  if (theme) {
    newSettings = { theme };
  }
  var schemeTheme = scheme && schemeSource && schemeSource.schemes && schemeSource.schemes[scheme];
  if (schemeSource && schemeTheme && schemeSource !== schemeTheme) {
    newSettings = { theme: schemeTheme };
    newSettings.theme.schemes = schemeSource.schemes;
  }
  if (newSettings) {
    newContext = {
      customizations: {
        settings: mergeSettings(context.customizations.settings, newSettings),
        scopedSettings: context.customizations.scopedSettings
      }
    };
  }
  return newContext;
}

// node_modules/@microsoft/load-themed-styles/lib-es6/index.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var _root = typeof window === "undefined" ? global : window;
var _styleNonce = _root && _root.CSPSettings && _root.CSPSettings.nonce;
var _themeState = initializeThemeState();
function initializeThemeState() {
  var state = _root.__themeState__ || {
    theme: void 0,
    lastStyleElement: void 0,
    registeredStyles: []
  };
  if (!state.runState) {
    state = __assign2(__assign2({}, state), { perf: {
      count: 0,
      duration: 0
    }, runState: {
      flushTimer: 0,
      mode: 0,
      buffer: []
    } });
  }
  if (!state.registeredThemableStyles) {
    state = __assign2(__assign2({}, state), { registeredThemableStyles: [] });
  }
  _root.__themeState__ = state;
  return state;
}
function applyThemableStyles(stylesArray, styleRecord) {
  if (_themeState.loadStyles) {
    _themeState.loadStyles(resolveThemableArray(stylesArray).styleString, stylesArray);
  } else {
    registerStyles(stylesArray);
  }
}
function loadTheme(theme) {
  _themeState.theme = theme;
  reloadStyles();
}
function clearStyles(option) {
  if (option === void 0) {
    option = 3;
  }
  if (option === 3 || option === 2) {
    clearStylesInternal(_themeState.registeredStyles);
    _themeState.registeredStyles = [];
  }
  if (option === 3 || option === 1) {
    clearStylesInternal(_themeState.registeredThemableStyles);
    _themeState.registeredThemableStyles = [];
  }
}
function clearStylesInternal(records) {
  records.forEach(function(styleRecord) {
    var styleElement = styleRecord && styleRecord.styleElement;
    if (styleElement && styleElement.parentElement) {
      styleElement.parentElement.removeChild(styleElement);
    }
  });
}
function reloadStyles() {
  if (_themeState.theme) {
    var themableStyles = [];
    for (var _i = 0, _a5 = _themeState.registeredThemableStyles; _i < _a5.length; _i++) {
      var styleRecord = _a5[_i];
      themableStyles.push(styleRecord.themableStyle);
    }
    if (themableStyles.length > 0) {
      clearStyles(
        1
        /* ClearStyleOptions.onlyThemable */
      );
      applyThemableStyles([].concat.apply([], themableStyles));
    }
  }
}
function resolveThemableArray(splitStyleArray) {
  var theme = _themeState.theme;
  var themable = false;
  var resolvedArray = (splitStyleArray || []).map(function(currentValue) {
    var themeSlot = currentValue.theme;
    if (themeSlot) {
      themable = true;
      var themedValue = theme ? theme[themeSlot] : void 0;
      var defaultValue = currentValue.defaultValue || "inherit";
      if (theme && !themedValue && console && !(themeSlot in theme) && typeof DEBUG !== "undefined" && DEBUG) {
        console.warn('Theming value not provided for "'.concat(themeSlot, '". Falling back to "').concat(defaultValue, '".'));
      }
      return themedValue || defaultValue;
    } else {
      return currentValue.rawString;
    }
  });
  return {
    styleString: resolvedArray.join(""),
    themable
  };
}
function registerStyles(styleArray) {
  if (typeof document === "undefined") {
    return;
  }
  var head = document.getElementsByTagName("head")[0];
  var styleElement = document.createElement("style");
  var _a5 = resolveThemableArray(styleArray), styleString = _a5.styleString, themable = _a5.themable;
  styleElement.setAttribute("data-load-themed-styles", "true");
  if (_styleNonce) {
    styleElement.setAttribute("nonce", _styleNonce);
  }
  styleElement.appendChild(document.createTextNode(styleString));
  _themeState.perf.count++;
  head.appendChild(styleElement);
  var ev = document.createEvent("HTMLEvents");
  ev.initEvent(
    "styleinsert",
    true,
    false
    /* cancelable */
  );
  ev.args = {
    newStyle: styleElement
  };
  document.dispatchEvent(ev);
  var record = {
    styleElement,
    themableStyle: styleArray
  };
  if (themable) {
    _themeState.registeredThemableStyles.push(record);
  } else {
    _themeState.registeredStyles.push(record);
  }
}

// node_modules/@fluentui/style-utilities/lib/styles/theme.js
var _theme = createTheme({});
var _onThemeChangeCallbacks = [];
var ThemeSettingName = "theme";
function initializeThemeInCustomizations() {
  var _a5;
  var _b3, _c3;
  var win = getWindow();
  if ((_b3 = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _b3 === void 0 ? void 0 : _b3.legacyTheme) {
    loadTheme2(win.FabricConfig.legacyTheme);
  } else if (!Customizations.getSettings([ThemeSettingName]).theme) {
    if ((_c3 = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _c3 === void 0 ? void 0 : _c3.theme) {
      _theme = createTheme(win.FabricConfig.theme);
    }
    Customizations.applySettings((_a5 = {}, _a5[ThemeSettingName] = _theme, _a5));
  }
}
initializeThemeInCustomizations();
function getTheme(depComments) {
  if (depComments === void 0) {
    depComments = false;
  }
  if (depComments === true) {
    _theme = createTheme({}, depComments);
  }
  return _theme;
}
function registerOnThemeChangeCallback(callback) {
  if (_onThemeChangeCallbacks.indexOf(callback) === -1) {
    _onThemeChangeCallbacks.push(callback);
  }
}
function removeOnThemeChangeCallback(callback) {
  var i = _onThemeChangeCallbacks.indexOf(callback);
  if (i === -1) {
    return;
  }
  _onThemeChangeCallbacks.splice(i, 1);
}
function loadTheme2(theme, depComments) {
  var _a5;
  if (depComments === void 0) {
    depComments = false;
  }
  _theme = createTheme(theme, depComments);
  loadTheme(__assign(__assign(__assign(__assign({}, _theme.palette), _theme.semanticColors), _theme.effects), _loadFonts(_theme)));
  Customizations.applySettings((_a5 = {}, _a5[ThemeSettingName] = _theme, _a5));
  _onThemeChangeCallbacks.forEach(function(callback) {
    try {
      callback(_theme);
    } catch (e) {
    }
  });
  return _theme;
}
function _loadFonts(theme) {
  var lines = {};
  for (var _i = 0, _a5 = Object.keys(theme.fonts); _i < _a5.length; _i++) {
    var fontName = _a5[_i];
    var font = theme.fonts[fontName];
    for (var _b3 = 0, _c3 = Object.keys(font); _b3 < _c3.length; _b3++) {
      var propName = _c3[_b3];
      var name_1 = fontName + propName.charAt(0).toUpperCase() + propName.slice(1);
      var value = font[propName];
      if (propName === "fontSize" && typeof value === "number") {
        value = value + "px";
      }
      lines[name_1] = value;
    }
  }
  return lines;
}

// node_modules/@fluentui/style-utilities/lib/styles/GeneralStyles.js
var normalize = {
  boxShadow: "none",
  margin: 0,
  padding: 0,
  boxSizing: "border-box"
};
var noWrap = {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
};

// node_modules/@fluentui/style-utilities/lib/styles/getFadedOverflowStyle.js
var DEFAULT_HEIGHT = "50%";
var DEFAULT_WIDTH = 20;
function getFadedOverflowStyle(theme, color, direction, width, height) {
  if (color === void 0) {
    color = "bodyBackground";
  }
  if (direction === void 0) {
    direction = "horizontal";
  }
  if (width === void 0) {
    width = getDefaultValue("width", direction);
  }
  if (height === void 0) {
    height = getDefaultValue("height", direction);
  }
  var colorValue = theme.semanticColors[color] || theme.palette[color];
  var rgbColor = color2rgb(colorValue);
  var rgba = "rgba(".concat(rgbColor.r, ", ").concat(rgbColor.g, ", ").concat(rgbColor.b, ", 0)");
  var gradientDirection = direction === "vertical" ? "to bottom" : "to right";
  return {
    content: '""',
    position: "absolute",
    right: 0,
    bottom: 0,
    width,
    height,
    pointerEvents: "none",
    backgroundImage: "linear-gradient(".concat(gradientDirection, ", ").concat(rgba, " 0%, ").concat(colorValue, " 100%)")
  };
}
function color2rgb(colorValue) {
  if (colorValue[0] === "#") {
    return {
      r: parseInt(colorValue.slice(1, 3), 16),
      g: parseInt(colorValue.slice(3, 5), 16),
      b: parseInt(colorValue.slice(5, 7), 16)
    };
  } else if (colorValue.indexOf("rgba(") === 0) {
    colorValue = colorValue.match(/rgba\(([^)]+)\)/)[1];
    var parts = colorValue.split(/ *, */).map(Number);
    return {
      r: parts[0],
      g: parts[1],
      b: parts[2]
    };
  }
  return {
    r: 255,
    g: 255,
    b: 255
  };
}
function getDefaultValue(style, direction) {
  if (style === "width") {
    return direction === "horizontal" ? DEFAULT_WIDTH : "100%";
  } else {
    return direction === "vertical" ? DEFAULT_HEIGHT : "100%";
  }
}

// node_modules/@fluentui/style-utilities/lib/styles/getPlaceholderStyles.js
function getPlaceholderStyles(styles) {
  return {
    selectors: {
      "::placeholder": styles,
      ":-ms-input-placeholder": styles,
      "::-ms-input-placeholder": styles
      // Edge
    }
  };
}

// node_modules/@fluentui/style-utilities/lib/classNames/AnimationClassNames.js
var AnimationClassNames = buildClassMap(AnimationStyles);

// node_modules/@fluentui/style-utilities/lib/classNames/FontClassNames.js
var FontClassNames = buildClassMap(DefaultFontStyles);

// node_modules/@fluentui/style-utilities/lib/classNames/ColorClassNames.js
var ColorClassNames = {};
for (colorName in DefaultPalette) {
  if (DefaultPalette.hasOwnProperty(colorName)) {
    _defineGetter(ColorClassNames, colorName, "", false, "color");
    _defineGetter(ColorClassNames, colorName, "Hover", true, "color");
    _defineGetter(ColorClassNames, colorName, "Background", false, "background");
    _defineGetter(ColorClassNames, colorName, "BackgroundHover", true, "background");
    _defineGetter(ColorClassNames, colorName, "Border", false, "borderColor");
    _defineGetter(ColorClassNames, colorName, "BorderHover", true, "borderColor");
  }
}
var colorName;
function _defineGetter(obj, colorName, suffix, isHover, cssProperty) {
  Object.defineProperty(obj, colorName + suffix, {
    get: function() {
      var _a5;
      var style = (_a5 = {}, _a5[cssProperty] = getTheme().palette[colorName], _a5);
      return mergeStyles(isHover ? { selectors: { ":hover": style } } : style).toString();
    },
    enumerable: true,
    configurable: true
  });
}

// node_modules/@fluentui/style-utilities/lib/cdn.js
var FLUENT_CDN_BASE_URL = "https://res.cdn.office.net/files/fabric-cdn-prod_20230524.001";

// node_modules/@fluentui/style-utilities/lib/version.js
setVersion("@fluentui/style-utilities", "8.9.14");

// node_modules/@fluentui/style-utilities/lib/index.js
initializeThemeInCustomizations();

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.base.js
var _a2;
var COMPONENT_NAME = "CalloutContentBase";
var ANIMATIONS = (_a2 = {}, _a2[RectangleEdge.top] = AnimationClassNames.slideUpIn10, _a2[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10, _a2[RectangleEdge.left] = AnimationClassNames.slideLeftIn10, _a2[RectangleEdge.right] = AnimationClassNames.slideRightIn10, _a2);
var BEAK_ORIGIN_POSITION = { top: 0, left: 0 };
var OFF_SCREEN_STYLE = {
  opacity: 0,
  filter: "opacity(0)",
  pointerEvents: "none"
};
var ARIA_ROLE_ATTRIBUTES = ["role", "aria-roledescription"];
var DEFAULT_PROPS = {
  preventDismissOnLostFocus: false,
  preventDismissOnScroll: false,
  preventDismissOnResize: false,
  isBeakVisible: true,
  beakWidth: 16,
  gapSpace: 0,
  minPagePadding: 8,
  directionalHint: DirectionalHint.bottomAutoEdge
};
var getClassNames = classNamesFunction({
  disableCaching: true
  // disabling caching because stylesProp.position mutates often
});
function useBounds(_a5, targetRef, targetWindow) {
  var bounds = _a5.bounds, _b3 = _a5.minPagePadding, minPagePadding = _b3 === void 0 ? DEFAULT_PROPS.minPagePadding : _b3, target = _a5.target;
  var _c3 = React2.useState(false), targetWindowResized = _c3[0], setTargetWindowResized = _c3[1];
  var cachedBounds = React2.useRef();
  var getBounds = React2.useCallback(function() {
    if (!cachedBounds.current || targetWindowResized) {
      var currentBounds = typeof bounds === "function" ? targetWindow ? bounds(target, targetWindow) : void 0 : bounds;
      if (!currentBounds && targetWindow) {
        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);
        currentBounds = {
          top: currentBounds.top + minPagePadding,
          left: currentBounds.left + minPagePadding,
          right: currentBounds.right - minPagePadding,
          bottom: currentBounds.bottom - minPagePadding,
          width: currentBounds.width - minPagePadding * 2,
          height: currentBounds.height - minPagePadding * 2
        };
      }
      cachedBounds.current = currentBounds;
      targetWindowResized && setTargetWindowResized(false);
    }
    return cachedBounds.current;
  }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);
  var async = useAsync();
  useOnEvent(targetWindow, "resize", async.debounce(function() {
    setTargetWindowResized(true);
  }, 500, { leading: true }));
  return getBounds;
}
function useMaxHeight(_a5, getBounds, positions) {
  var _b3;
  var calloutMaxHeight = _a5.calloutMaxHeight, finalHeight = _a5.finalHeight, directionalHint = _a5.directionalHint, directionalHintFixed = _a5.directionalHintFixed, hidden = _a5.hidden;
  var _c3 = React2.useState(), maxHeight = _c3[0], setMaxHeight = _c3[1];
  var _d3 = (_b3 = positions === null || positions === void 0 ? void 0 : positions.elementPosition) !== null && _b3 !== void 0 ? _b3 : {}, top = _d3.top, bottom = _d3.bottom;
  React2.useEffect(function() {
    var _a6;
    var _b4 = (_a6 = getBounds()) !== null && _a6 !== void 0 ? _a6 : {}, topBounds = _b4.top, bottomBounds = _b4.bottom;
    var calculatedHeight;
    if (typeof top === "number" && bottomBounds) {
      calculatedHeight = bottomBounds - top;
    } else if (typeof bottom === "number" && typeof topBounds === "number" && bottomBounds) {
      calculatedHeight = bottomBounds - topBounds - bottom;
    }
    if (!calloutMaxHeight && !hidden || calloutMaxHeight && calculatedHeight && calloutMaxHeight > calculatedHeight) {
      setMaxHeight(calculatedHeight);
    } else if (calloutMaxHeight) {
      setMaxHeight(calloutMaxHeight);
    } else {
      setMaxHeight(void 0);
    }
  }, [bottom, calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, getBounds, hidden, positions, top]);
  return maxHeight;
}
function usePositions(props, hostElement, calloutElement, targetRef, getBounds) {
  var _a5 = React2.useState(), positions = _a5[0], setPositions = _a5[1];
  var positionAttempts = React2.useRef(0);
  var previousTarget = React2.useRef();
  var async = useAsync();
  var hidden = props.hidden, target = props.target, finalHeight = props.finalHeight, calloutMaxHeight = props.calloutMaxHeight, onPositioned = props.onPositioned, directionalHint = props.directionalHint;
  React2.useEffect(function() {
    if (!hidden) {
      var timerId_1 = async.requestAnimationFrame(function() {
        var _a6, _b3;
        if (hostElement.current && calloutElement) {
          var currentProps = __assign(__assign({}, props), { target: targetRef.current, bounds: getBounds() });
          var dupeCalloutElement = calloutElement.cloneNode(true);
          dupeCalloutElement.style.maxHeight = calloutMaxHeight ? "".concat(calloutMaxHeight) : "";
          dupeCalloutElement.style.visibility = "hidden";
          (_a6 = calloutElement.parentElement) === null || _a6 === void 0 ? void 0 : _a6.appendChild(dupeCalloutElement);
          var previousPositions = previousTarget.current === target ? positions : void 0;
          var newPositions = finalHeight ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions) : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions);
          (_b3 = calloutElement.parentElement) === null || _b3 === void 0 ? void 0 : _b3.removeChild(dupeCalloutElement);
          if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {
            positionAttempts.current++;
            setPositions(newPositions);
          } else if (positionAttempts.current > 0) {
            positionAttempts.current = 0;
            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(positions);
          }
        }
      }, calloutElement);
      previousTarget.current = target;
      return function() {
        async.cancelAnimationFrame(timerId_1);
        previousTarget.current = void 0;
      };
    } else {
      setPositions(void 0);
      positionAttempts.current = 0;
    }
  }, [
    hidden,
    directionalHint,
    async,
    calloutElement,
    calloutMaxHeight,
    hostElement,
    targetRef,
    finalHeight,
    getBounds,
    onPositioned,
    positions,
    props,
    target
  ]);
  return positions;
}
function useAutoFocus(_a5, positions, calloutElement) {
  var hidden = _a5.hidden, setInitialFocus = _a5.setInitialFocus;
  var async = useAsync();
  var hasPositions = !!positions;
  React2.useEffect(function() {
    if (!hidden && setInitialFocus && hasPositions && calloutElement) {
      var timerId_2 = async.requestAnimationFrame(function() {
        return focusFirstChild(calloutElement);
      }, calloutElement);
      return function() {
        return async.cancelAnimationFrame(timerId_2);
      };
    }
  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);
}
function useDismissHandlers(_a5, positions, hostElement, targetRef, targetWindow) {
  var hidden = _a5.hidden, onDismiss = _a5.onDismiss, preventDismissOnScroll = _a5.preventDismissOnScroll, preventDismissOnResize = _a5.preventDismissOnResize, preventDismissOnLostFocus = _a5.preventDismissOnLostFocus, dismissOnTargetClick = _a5.dismissOnTargetClick, shouldDismissOnWindowFocus = _a5.shouldDismissOnWindowFocus, preventDismissOnEvent = _a5.preventDismissOnEvent;
  var isMouseDownOnPopup = React2.useRef(false);
  var async = useAsync();
  var mouseDownHandlers = useConst([
    function() {
      isMouseDownOnPopup.current = true;
    },
    function() {
      isMouseDownOnPopup.current = false;
    }
  ]);
  var positionsExists = !!positions;
  React2.useEffect(function() {
    var dismissOnScroll = function(ev) {
      if (positionsExists && !preventDismissOnScroll) {
        dismissOnClickOrScroll(ev);
      }
    };
    var dismissOnResize = function(ev) {
      if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var dismissOnLostFocus = function(ev) {
      if (!preventDismissOnLostFocus) {
        dismissOnClickOrScroll(ev);
      }
    };
    var dismissOnClickOrScroll = function(ev) {
      var eventPaths = ev.composedPath ? ev.composedPath() : [];
      var target = eventPaths.length > 0 ? eventPaths[0] : ev.target;
      var isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target);
      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {
        isMouseDownOnPopup.current = false;
        return;
      }
      if (!targetRef.current && isEventTargetOutsideCallout || ev.target !== targetWindow && isEventTargetOutsideCallout && (!targetRef.current || "stopPropagation" in targetRef.current || dismissOnTargetClick || target !== targetRef.current && !elementContains(targetRef.current, target))) {
        if (preventDismissOnEvent && preventDismissOnEvent(ev)) {
          return;
        }
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var dismissOnTargetWindowBlur = function(ev) {
      if (!shouldDismissOnWindowFocus) {
        return;
      }
      if ((preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) && !(targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.hasFocus()) && ev.relatedTarget === null) {
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var disposablesPromise = new Promise(function(resolve) {
      async.setTimeout(function() {
        if (!hidden && targetWindow) {
          var disposables_1 = [
            on(targetWindow, "scroll", dismissOnScroll, true),
            on(targetWindow, "resize", dismissOnResize, true),
            on(targetWindow.document.documentElement, "focus", dismissOnLostFocus, true),
            on(targetWindow.document.documentElement, "click", dismissOnLostFocus, true),
            on(targetWindow, "blur", dismissOnTargetWindowBlur, true)
          ];
          resolve(function() {
            disposables_1.forEach(function(dispose) {
              return dispose();
            });
          });
        }
      }, 0);
    });
    return function() {
      disposablesPromise.then(function(dispose) {
        return dispose();
      });
    };
  }, [
    hidden,
    async,
    hostElement,
    targetRef,
    targetWindow,
    onDismiss,
    shouldDismissOnWindowFocus,
    dismissOnTargetClick,
    preventDismissOnLostFocus,
    preventDismissOnResize,
    preventDismissOnScroll,
    positionsExists,
    preventDismissOnEvent
  ]);
  return mouseDownHandlers;
}
var CalloutContentBase = React2.memo(React2.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);
  var styles = props.styles, style = props.style, ariaLabel = props.ariaLabel, ariaDescribedBy = props.ariaDescribedBy, ariaLabelledBy = props.ariaLabelledBy, className = props.className, isBeakVisible = props.isBeakVisible, children = props.children, beakWidth = props.beakWidth, calloutWidth = props.calloutWidth, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer, finalHeight = props.finalHeight, _a5 = props.hideOverflow, hideOverflow = _a5 === void 0 ? !!finalHeight : _a5, backgroundColor = props.backgroundColor, calloutMaxHeight = props.calloutMaxHeight, onScroll = props.onScroll, _b3 = props.shouldRestoreFocus, shouldRestoreFocus = _b3 === void 0 ? true : _b3, target = props.target, hidden = props.hidden, onLayerMounted = props.onLayerMounted, popupProps = props.popupProps;
  var hostElement = React2.useRef(null);
  var _c3 = React2.useState(null), calloutElement = _c3[0], setCalloutElement = _c3[1];
  var calloutCallback = React2.useCallback(function(calloutEl) {
    setCalloutElement(calloutEl);
  }, []);
  var rootRef = useMergedRefs(hostElement, forwardedRef);
  var _d3 = useTarget(props.target, {
    current: calloutElement
  }), targetRef = _d3[0], targetWindow = _d3[1];
  var getBounds = useBounds(props, targetRef, targetWindow);
  var positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds);
  var maxHeight = useMaxHeight(props, getBounds, positions);
  var _e2 = useDismissHandlers(props, positions, hostElement, targetRef, targetWindow), mouseDownOnPopup = _e2[0], mouseUpOnPopup = _e2[1];
  var isForcedInBounds = (positions === null || positions === void 0 ? void 0 : positions.elementPosition.top) && (positions === null || positions === void 0 ? void 0 : positions.elementPosition.bottom);
  var cssPositions = __assign(__assign({}, positions === null || positions === void 0 ? void 0 : positions.elementPosition), { maxHeight });
  if (isForcedInBounds) {
    cssPositions.bottom = void 0;
  }
  useAutoFocus(props, positions, calloutElement);
  React2.useEffect(function() {
    if (!hidden) {
      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
    }
  }, [hidden]);
  if (!targetWindow) {
    return null;
  }
  var overflowYHidden = hideOverflow;
  var beakVisible = isBeakVisible && !!target;
  var classNames2 = getClassNames(styles, {
    theme: props.theme,
    className,
    overflowYHidden,
    calloutWidth,
    positions,
    beakWidth,
    backgroundColor,
    calloutMaxWidth,
    calloutMinWidth,
    doNotLayer
  });
  var overflowStyle = __assign(__assign({ maxHeight: calloutMaxHeight ? calloutMaxHeight : "100%" }, style), overflowYHidden && { overflowY: "hidden" });
  var visibilityStyle = props.hidden ? { visibility: "hidden" } : void 0;
  return React2.createElement(
    "div",
    { ref: rootRef, className: classNames2.container, style: visibilityStyle },
    React2.createElement(
      "div",
      __assign({}, getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES), {
        className: css(classNames2.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]),
        style: positions ? __assign({}, cssPositions) : OFF_SCREEN_STYLE,
        // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.
        // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
        tabIndex: -1,
        ref: calloutCallback
      }),
      beakVisible && React2.createElement("div", { className: classNames2.beak, style: getBeakPosition(positions) }),
      beakVisible && React2.createElement("div", { className: classNames2.beakCurtain }),
      React2.createElement(
        Popup,
        __assign({
          // don't use getNativeElementProps for role and roledescription because it will also
          // pass through data-* props (resulting in them being used in two places)
          role: props.role,
          "aria-roledescription": props["aria-roledescription"],
          ariaDescribedBy,
          ariaLabel,
          ariaLabelledBy,
          className: classNames2.calloutMain,
          onDismiss: props.onDismiss,
          onMouseDown: mouseDownOnPopup,
          onMouseUp: mouseUpOnPopup,
          onRestoreFocus: props.onRestoreFocus,
          onScroll,
          shouldRestoreFocus,
          style: overflowStyle
        }, popupProps),
        children
      )
    )
  );
}), function(previousProps, nextProps) {
  if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {
    return true;
  }
  return shallowCompare(previousProps, nextProps);
});
function getBeakPosition(positions) {
  var _a5, _b3;
  var beakPositionStyle = __assign(__assign({}, (_a5 = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _a5 === void 0 ? void 0 : _a5.elementPosition), { display: ((_b3 = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _b3 === void 0 ? void 0 : _b3.hideBeak) ? "none" : void 0 });
  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {
    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;
    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;
  }
  return beakPositionStyle;
}
function arePositionsEqual(prevElementPositions, newElementPosition) {
  return comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) && comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition);
}
function comparePositions(prevElementPositions, newElementPositions) {
  for (var key in newElementPositions) {
    if (newElementPositions.hasOwnProperty(key)) {
      var oldPositionEdge = prevElementPositions[key];
      var newPositionEdge = newElementPositions[key];
      if (oldPositionEdge !== void 0 && newPositionEdge !== void 0) {
        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  return true;
}
CalloutContentBase.displayName = COMPONENT_NAME;

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.styles.js
function getBeakStyle(beakWidth) {
  return {
    height: beakWidth,
    width: beakWidth
  };
}
var GlobalClassNames = {
  container: "ms-Callout-container",
  root: "ms-Callout",
  beak: "ms-Callout-beak",
  beakCurtain: "ms-Callout-beakCurtain",
  calloutMain: "ms-Callout-main"
};
var getStyles = function(props) {
  var _a5;
  var theme = props.theme, className = props.className, overflowYHidden = props.overflowYHidden, calloutWidth = props.calloutWidth, beakWidth = props.beakWidth, backgroundColor = props.backgroundColor, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer;
  var classNames2 = getGlobalClassNames(GlobalClassNames, theme);
  var semanticColors = theme.semanticColors, effects = theme.effects;
  return {
    container: [
      classNames2.container,
      {
        position: "relative"
      }
    ],
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        position: "absolute",
        display: "flex",
        zIndex: doNotLayer ? ZIndexes.Layer : void 0,
        boxSizing: "border-box",
        borderRadius: effects.roundedCorner2,
        boxShadow: effects.elevation16,
        selectors: (_a5 = {}, _a5[HighContrastSelector] = {
          borderWidth: 1,
          borderStyle: "solid",
          borderColor: "WindowText"
        }, _a5)
      },
      focusClear(),
      className,
      !!calloutWidth && { width: calloutWidth },
      !!calloutMaxWidth && { maxWidth: calloutMaxWidth },
      !!calloutMinWidth && { minWidth: calloutMinWidth }
    ],
    beak: [
      classNames2.beak,
      {
        position: "absolute",
        backgroundColor: semanticColors.menuBackground,
        boxShadow: "inherit",
        border: "inherit",
        boxSizing: "border-box",
        transform: "rotate(45deg)"
      },
      getBeakStyle(beakWidth),
      backgroundColor && {
        backgroundColor
      }
    ],
    beakCurtain: [
      classNames2.beakCurtain,
      {
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        backgroundColor: semanticColors.menuBackground,
        borderRadius: effects.roundedCorner2
      }
    ],
    calloutMain: [
      classNames2.calloutMain,
      {
        backgroundColor: semanticColors.menuBackground,
        overflowX: "hidden",
        overflowY: "auto",
        position: "relative",
        width: "100%",
        borderRadius: effects.roundedCorner2
      },
      overflowYHidden && {
        overflowY: "hidden"
      },
      backgroundColor && {
        backgroundColor
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.js
var CalloutContent = styled(CalloutContentBase, getStyles, void 0, {
  scope: "CalloutContent"
});

// node_modules/@fluentui/react-portal-compat-context/lib/PortalCompatContext.js
var React3 = __toESM(require_react());
var PortalCompatContext = React3.createContext(void 0);
var portalCompatContextDefaultValue = () => () => void 0;
var PortalCompatContextProvider = PortalCompatContext.Provider;
function usePortalCompat() {
  var _React_useContext;
  return (_React_useContext = React3.useContext(PortalCompatContext)) !== null && _React_useContext !== void 0 ? _React_useContext : portalCompatContextDefaultValue;
}

// node_modules/@fluentui/react/lib/components/Layer/Layer.base.js
var React5 = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());

// node_modules/@fluentui/react/lib/components/Fabric/Fabric.base.js
var React4 = __toESM(require_react());
var getClassNames2 = classNamesFunction();
var getFabricTheme = memoizeFunction(function(theme, isRTL) {
  return createTheme(__assign(__assign({}, theme), { rtl: isRTL }));
});
var getDir = function(_a5) {
  var theme = _a5.theme, dir = _a5.dir;
  var contextDir = getRTL(theme) ? "rtl" : "ltr";
  var pageDir = getRTL() ? "rtl" : "ltr";
  var componentDir = dir ? dir : contextDir;
  return {
    // If Fabric dir !== contextDir
    // Or If contextDir !== pageDir
    // Then we need to set dir of the Fabric root
    rootDir: componentDir !== contextDir || componentDir !== pageDir ? componentDir : dir,
    // If dir !== contextDir || pageDir
    // then set contextual theme around content
    needsTheme: componentDir !== contextDir
  };
};
var FabricBase = React4.forwardRef(function(props, ref) {
  var className = props.className, theme = props.theme, applyTheme = props.applyTheme, applyThemeToBody = props.applyThemeToBody, styles = props.styles;
  var classNames2 = getClassNames2(styles, {
    theme,
    applyTheme,
    className
  });
  var rootElement = React4.useRef(null);
  useApplyThemeToBody(applyThemeToBody, classNames2, rootElement);
  return React4.createElement(React4.Fragment, null, useRenderedContent(props, classNames2, rootElement, ref));
});
FabricBase.displayName = "FabricBase";
function useRenderedContent(props, _a5, rootElement, ref) {
  var root = _a5.root;
  var _b3 = props.as, Root = _b3 === void 0 ? "div" : _b3, dir = props.dir, theme = props.theme;
  var divProps = getNativeProps(props, divProperties, ["dir"]);
  var _c3 = getDir(props), rootDir = _c3.rootDir, needsTheme = _c3.needsTheme;
  var renderedContent = React4.createElement(
    FocusRectsProvider,
    { providerRef: rootElement },
    React4.createElement(Root, __assign({ dir: rootDir }, divProps, { className: root, ref: useMergedRefs(rootElement, ref) }))
  );
  if (needsTheme) {
    renderedContent = // eslint-disable-next-line deprecation/deprecation
    React4.createElement(Customizer, { settings: { theme: getFabricTheme(theme, dir === "rtl") } }, renderedContent);
  }
  return renderedContent;
}
function useApplyThemeToBody(applyThemeToBody, _a5, rootElement) {
  var bodyThemed = _a5.bodyThemed;
  React4.useEffect(function() {
    if (applyThemeToBody) {
      var currentDoc_1 = getDocument(rootElement.current);
      if (currentDoc_1) {
        currentDoc_1.body.classList.add(bodyThemed);
        return function() {
          currentDoc_1.body.classList.remove(bodyThemed);
        };
      }
    }
  }, [bodyThemed, applyThemeToBody, rootElement]);
  return rootElement;
}

// node_modules/@fluentui/react/lib/components/Fabric/Fabric.styles.js
var inheritFont = { fontFamily: "inherit" };
var GlobalClassNames2 = {
  root: "ms-Fabric",
  bodyThemed: "ms-Fabric-bodyThemed"
};
var getStyles2 = function(props) {
  var applyTheme = props.applyTheme, className = props.className, preventBlanketFontInheritance = props.preventBlanketFontInheritance, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames2, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        color: theme.palette.neutralPrimary
      },
      !preventBlanketFontInheritance && {
        "& button": inheritFont,
        "& input": inheritFont,
        "& textarea": inheritFont
      },
      // apply theme to only if applyTheme is true
      applyTheme && {
        color: theme.semanticColors.bodyText,
        backgroundColor: theme.semanticColors.bodyBackground
      },
      className
    ],
    bodyThemed: [
      {
        backgroundColor: theme.semanticColors.bodyBackground
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Fabric/Fabric.js
var Fabric = styled(FabricBase, getStyles2, void 0, {
  scope: "Fabric"
});

// node_modules/@fluentui/react/lib/components/Layer/Layer.notification.js
var _layersByHostId = {};
var _layerHostsById = {};
var defaultHostId = "fluent-default-layer-host";
var _defaultHostSelector = "#".concat(defaultHostId);
function registerLayer(hostId, callback) {
  if (!_layersByHostId[hostId]) {
    _layersByHostId[hostId] = [];
  }
  _layersByHostId[hostId].push(callback);
  var layerHosts = _layerHostsById[hostId];
  if (layerHosts) {
    for (var _i = 0, layerHosts_1 = layerHosts; _i < layerHosts_1.length; _i++) {
      var layerHost = layerHosts_1[_i];
      layerHost.notifyLayersChanged();
    }
  }
}
function unregisterLayer(hostId, callback) {
  var layers = _layersByHostId[hostId];
  if (layers) {
    var idx = layers.indexOf(callback);
    if (idx >= 0) {
      layers.splice(idx, 1);
      if (layers.length === 0) {
        delete _layersByHostId[hostId];
      }
    }
  }
  var layerHosts = _layerHostsById[hostId];
  if (layerHosts) {
    for (var _i = 0, layerHosts_2 = layerHosts; _i < layerHosts_2.length; _i++) {
      var layerHost = layerHosts_2[_i];
      layerHost.notifyLayersChanged();
    }
  }
}
function getLayerCount(hostId) {
  var layers = _layerHostsById[hostId];
  return layers ? layers.length : 0;
}
function getLayerHost(hostId) {
  var layerHosts = _layerHostsById[hostId];
  return layerHosts && layerHosts[0] || void 0;
}
function registerLayerHost(hostId, layerHost) {
  var layerHosts = _layerHostsById[hostId] || (_layerHostsById[hostId] = []);
  layerHosts.unshift(layerHost);
}
function unregisterLayerHost(hostId, layerHost) {
  var layerHosts = _layerHostsById[hostId];
  if (layerHosts) {
    var idx = layerHosts.indexOf(layerHost);
    if (idx >= 0) {
      layerHosts.splice(idx, 1);
    }
    if (layerHosts.length === 0) {
      delete _layerHostsById[hostId];
    }
  }
}
function createDefaultLayerHost(doc) {
  var host = doc.createElement("div");
  host.setAttribute("id", defaultHostId);
  host.style.cssText = "position:fixed;z-index:1000000";
  doc === null || doc === void 0 ? void 0 : doc.body.appendChild(host);
  return host;
}
function cleanupDefaultLayerHost(doc) {
  var host = doc.querySelector("#".concat(defaultHostId));
  if (host) {
    doc.removeChild(host);
  }
}
function notifyHostChanged(id) {
  if (_layersByHostId[id]) {
    _layersByHostId[id].forEach(function(callback) {
      return callback();
    });
  }
}
function setDefaultTarget(selector) {
  _defaultHostSelector = selector;
}
function getDefaultTarget() {
  return _defaultHostSelector;
}

// node_modules/@fluentui/react/lib/components/Layer/Layer.base.js
var getClassNames3 = classNamesFunction();
var getFocusVisibility = function(providerRef) {
  if (providerRef === null || providerRef === void 0 ? void 0 : providerRef.current) {
    return providerRef.current.classList.contains(IsFocusVisibleClassName);
  }
  return false;
};
var LayerBase = React5.forwardRef(function(props, ref) {
  var registerPortalEl = usePortalCompat();
  var rootRef = React5.useRef(null);
  var mergedRef = useMergedRefs(rootRef, ref);
  var layerRef = React5.useRef();
  var fabricElementRef = React5.useRef(null);
  var focusContext = React5.useContext(FocusRectsContext);
  var _a5 = React5.useState(false), needRaiseLayerMount = _a5[0], setNeedRaiseLayerMount = _a5[1];
  var focusRectsRef = React5.useCallback(function(el) {
    var isFocusVisible = getFocusVisibility(focusContext === null || focusContext === void 0 ? void 0 : focusContext.providerRef);
    if (el && isFocusVisible) {
      el.classList.add(IsFocusVisibleClassName);
    }
  }, [focusContext]);
  var children = props.children, className = props.className, eventBubblingEnabled = props.eventBubblingEnabled, fabricProps = props.fabricProps, hostId = props.hostId, insertFirst = props.insertFirst, _b3 = props.onLayerDidMount, onLayerDidMount = _b3 === void 0 ? function() {
    return void 0;
  } : _b3, _c3 = props.onLayerMounted, onLayerMounted = _c3 === void 0 ? function() {
    return void 0;
  } : _c3, onLayerWillUnmount = props.onLayerWillUnmount, styles = props.styles, theme = props.theme;
  var fabricRef = useMergedRefs(fabricElementRef, fabricProps === null || fabricProps === void 0 ? void 0 : fabricProps.ref, focusRectsRef);
  var classNames2 = getClassNames3(styles, {
    theme,
    className,
    isNotHost: !hostId
  });
  var getHost = function(doc) {
    var _a6, _b4;
    if (hostId) {
      var layerHost = getLayerHost(hostId);
      if (layerHost) {
        return (_a6 = layerHost.rootRef.current) !== null && _a6 !== void 0 ? _a6 : null;
      }
      return (_b4 = doc.getElementById(hostId)) !== null && _b4 !== void 0 ? _b4 : null;
    } else {
      var defaultHostSelector = getDefaultTarget();
      var host = defaultHostSelector ? doc.querySelector(defaultHostSelector) : null;
      if (!host) {
        host = createDefaultLayerHost(doc);
      }
      return host;
    }
  };
  var removeLayerElement = function() {
    onLayerWillUnmount === null || onLayerWillUnmount === void 0 ? void 0 : onLayerWillUnmount();
    var elem = layerRef.current;
    layerRef.current = void 0;
    if (elem && elem.parentNode) {
      elem.parentNode.removeChild(elem);
    }
  };
  var createLayerElement = function() {
    var _a6;
    var doc = getDocument(rootRef.current);
    if (!doc) {
      return;
    }
    var host = getHost(doc);
    if (!host) {
      return;
    }
    removeLayerElement();
    var el = ((_a6 = host.ownerDocument) !== null && _a6 !== void 0 ? _a6 : doc).createElement("div");
    el.className = classNames2.root;
    setPortalAttribute(el);
    setVirtualParent(el, rootRef.current);
    insertFirst ? host.insertBefore(el, host.firstChild) : host.appendChild(el);
    layerRef.current = el;
    setNeedRaiseLayerMount(true);
  };
  useIsomorphicLayoutEffect(function() {
    createLayerElement();
    if (hostId) {
      registerLayer(hostId, createLayerElement);
    }
    var unregisterPortalEl = layerRef.current ? registerPortalEl(layerRef.current) : void 0;
    return function() {
      if (unregisterPortalEl) {
        unregisterPortalEl();
      }
      removeLayerElement();
      if (hostId) {
        unregisterLayer(hostId, createLayerElement);
      }
    };
  }, [hostId]);
  React5.useEffect(function() {
    if (layerRef.current && needRaiseLayerMount) {
      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
      onLayerDidMount === null || onLayerDidMount === void 0 ? void 0 : onLayerDidMount();
      setNeedRaiseLayerMount(false);
    }
  }, [needRaiseLayerMount, onLayerMounted, onLayerDidMount]);
  useDebugWarnings(props);
  return React5.createElement("span", { className: "ms-layer", ref: mergedRef }, layerRef.current && ReactDOM.createPortal(React5.createElement(
    FocusRectsProvider,
    { layerRoot: true, providerRef: fabricRef },
    React5.createElement(Fabric, __assign({}, !eventBubblingEnabled && getFilteredEvents(), fabricProps, { className: css(classNames2.content, fabricProps === null || fabricProps === void 0 ? void 0 : fabricProps.className), ref: fabricRef }), children)
  ), layerRef.current));
});
LayerBase.displayName = "LayerBase";
var filteredEventProps;
var onFilterEvent = function(ev) {
  if (ev.eventPhase === Event.BUBBLING_PHASE && ev.type !== "mouseenter" && ev.type !== "mouseleave" && ev.type !== "touchstart" && ev.type !== "touchend") {
    ev.stopPropagation();
  }
};
function getFilteredEvents() {
  if (!filteredEventProps) {
    filteredEventProps = {};
    [
      "onClick",
      "onContextMenu",
      "onDoubleClick",
      "onDrag",
      "onDragEnd",
      "onDragEnter",
      "onDragExit",
      "onDragLeave",
      "onDragOver",
      "onDragStart",
      "onDrop",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onMouseMove",
      "onMouseOver",
      "onMouseOut",
      "onMouseUp",
      "onTouchMove",
      "onTouchStart",
      "onTouchCancel",
      "onTouchEnd",
      "onKeyDown",
      "onKeyPress",
      "onKeyUp",
      "onFocus",
      "onBlur",
      "onChange",
      "onInput",
      "onInvalid",
      "onSubmit"
    ].forEach(function(name) {
      return filteredEventProps[name] = onFilterEvent;
    });
  }
  return filteredEventProps;
}
function useDebugWarnings(props) {
  if (true) {
    useWarnings({
      name: "Layer",
      props,
      deprecations: { onLayerMounted: "onLayerDidMount" }
    });
  }
}

// node_modules/@fluentui/react/lib/components/Layer/Layer.styles.js
var GlobalClassNames3 = {
  root: "ms-Layer",
  rootNoHost: "ms-Layer--fixed",
  content: "ms-Layer-content"
};
var getStyles3 = function(props) {
  var className = props.className, isNotHost = props.isNotHost, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames3, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      isNotHost && [
        classNames2.rootNoHost,
        {
          position: "fixed",
          zIndex: ZIndexes.Layer,
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          visibility: "hidden"
        }
      ],
      className
    ],
    content: [
      classNames2.content,
      {
        visibility: "visible"
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Layer/Layer.js
var Layer = styled(LayerBase, getStyles3, void 0, {
  scope: "Layer",
  fields: ["hostId", "theme", "styles"]
});

// node_modules/@fluentui/react/lib/components/Layer/LayerHost.js
var React6 = __toESM(require_react());
var LayerHost = function(props) {
  var className = props.className;
  var layerHostId = React6.useState(function() {
    return getId();
  })[0];
  var _a5 = props.id, hostId = _a5 === void 0 ? layerHostId : _a5;
  var layerHostRef = React6.useRef({
    hostId,
    rootRef: React6.useRef(null),
    notifyLayersChanged: function() {
    }
  });
  React6.useImperativeHandle(props.componentRef, function() {
    return layerHostRef.current;
  });
  React6.useEffect(function() {
    registerLayerHost(hostId, layerHostRef.current);
    notifyHostChanged(hostId);
  }, []);
  useUnmount(function() {
    unregisterLayerHost(hostId, layerHostRef.current);
    notifyHostChanged(hostId);
  });
  return React6.createElement("div", __assign({}, props, { className: css("ms-LayerHost", className), ref: layerHostRef.current.rootRef }));
};

// node_modules/@fluentui/react/lib/components/Callout/Callout.js
var Callout = React7.forwardRef(function(_a5, forwardedRef) {
  var layerProps = _a5.layerProps, doNotLayer = _a5.doNotLayer, rest = __rest(_a5, ["layerProps", "doNotLayer"]);
  var content = React7.createElement(CalloutContent, __assign({}, rest, { doNotLayer, ref: forwardedRef }));
  return doNotLayer ? content : React7.createElement(Layer, __assign({}, layerProps), content);
});
Callout.displayName = "Callout";

// node_modules/@fluentui/react/lib/components/Callout/FocusTrapCallout.js
var React9 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/FocusTrapZone/FocusTrapZone.js
var React8 = __toESM(require_react());
var COMPONENT_NAME2 = "FocusTrapZone";
var DEFAULT_PROPS2 = {
  disabled: false,
  disableFirstFocus: false,
  forceFocusInsideTrap: true,
  isClickableOutsideFocusTrap: false
};
var useComponentRef = function(componentRef, previouslyFocusedElement, focusFTZ) {
  React8.useImperativeHandle(componentRef, function() {
    return {
      get previouslyFocusedElement() {
        return previouslyFocusedElement;
      },
      focus: focusFTZ
    };
  }, [focusFTZ, previouslyFocusedElement]);
};
var FocusTrapZone = React8.forwardRef(function(propsWithoutDefaults, ref) {
  var _a5;
  var root = React8.useRef(null);
  var firstBumper = React8.useRef(null);
  var lastBumper = React8.useRef(null);
  var mergedRootRef = useMergedRefs(root, ref);
  var doc = useDocument();
  var isFirstRender = (_a5 = usePrevious(false)) !== null && _a5 !== void 0 ? _a5 : true;
  var props = getPropsWithDefaults(DEFAULT_PROPS2, propsWithoutDefaults);
  var internalState = useConst({
    hasFocus: false,
    focusStackId: useId("ftz-", props.id)
  });
  var children = props.children, componentRef = props.componentRef, disabled = props.disabled, disableFirstFocus = props.disableFirstFocus, forceFocusInsideTrap = props.forceFocusInsideTrap, focusPreviouslyFocusedInnerElement = props.focusPreviouslyFocusedInnerElement, firstFocusableSelector = props.firstFocusableSelector, firstFocusableTarget = props.firstFocusableTarget, _b3 = props.disableRestoreFocus, disableRestoreFocus = _b3 === void 0 ? props.ignoreExternalFocusing : _b3, isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap, enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;
  var bumperProps = {
    "aria-hidden": true,
    style: {
      pointerEvents: "none",
      position: "fixed"
      // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them
    },
    tabIndex: disabled ? -1 : 0,
    "data-is-visible": true,
    "data-is-focus-trap-zone-bumper": true
  };
  var focusElementAsync = React8.useCallback(function(element) {
    if (element !== firstBumper.current && element !== lastBumper.current) {
      focusAsync(element);
    }
  }, []);
  var focusFTZ = useEventCallback(function() {
    if (!root.current) {
      return;
    }
    var previouslyFocusedElementInTrapZone = internalState.previouslyFocusedElementInTrapZone;
    if (focusPreviouslyFocusedInnerElement && previouslyFocusedElementInTrapZone && elementContains(root.current, previouslyFocusedElementInTrapZone)) {
      focusElementAsync(previouslyFocusedElementInTrapZone);
      return;
    }
    var firstFocusableChild = null;
    if (typeof firstFocusableTarget === "string") {
      firstFocusableChild = root.current.querySelector(firstFocusableTarget);
    } else if (firstFocusableTarget) {
      firstFocusableChild = firstFocusableTarget(root.current);
    } else if (firstFocusableSelector) {
      var focusSelector = typeof firstFocusableSelector === "string" ? firstFocusableSelector : firstFocusableSelector();
      firstFocusableChild = root.current.querySelector("." + focusSelector);
    }
    if (!firstFocusableChild) {
      firstFocusableChild = getNextElement(root.current, root.current.firstChild, false, false, false, true);
    }
    if (firstFocusableChild) {
      focusElementAsync(firstFocusableChild);
    }
  });
  var focusBumper = function(isFirstBumper) {
    if (disabled || !root.current) {
      return;
    }
    var nextFocusable = isFirstBumper === internalState.hasFocus ? getLastTabbable(root.current, lastBumper.current, true, false) : getFirstTabbable(root.current, firstBumper.current, true, false);
    if (nextFocusable) {
      if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {
        focusFTZ();
      } else {
        nextFocusable.focus();
      }
    }
  };
  var onRootBlurCapture = function(ev) {
    var _a6;
    (_a6 = props.onBlurCapture) === null || _a6 === void 0 ? void 0 : _a6.call(props, ev);
    var relatedTarget = ev.relatedTarget;
    if (ev.relatedTarget === null) {
      relatedTarget = doc.activeElement;
    }
    if (!elementContains(root.current, relatedTarget)) {
      internalState.hasFocus = false;
    }
  };
  var onRootFocusCapture = function(ev) {
    var _a6;
    (_a6 = props.onFocusCapture) === null || _a6 === void 0 ? void 0 : _a6.call(props, ev);
    if (ev.target === firstBumper.current) {
      focusBumper(true);
    } else if (ev.target === lastBumper.current) {
      focusBumper(false);
    }
    internalState.hasFocus = true;
    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {
      internalState.previouslyFocusedElementInTrapZone = ev.target;
    }
  };
  var returnFocusToInitiator = useEventCallback(function(elementToFocusOnDismiss) {
    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter(function(value) {
      return internalState.focusStackId !== value;
    });
    if (!doc) {
      return;
    }
    var activeElement = doc.activeElement;
    if (!disableRestoreFocus && typeof (elementToFocusOnDismiss === null || elementToFocusOnDismiss === void 0 ? void 0 : elementToFocusOnDismiss.focus) === "function" && // only restore focus if the current focused element is within the FTZ, or if nothing is focused
    (elementContains(root.current, activeElement) || activeElement === doc.body)) {
      focusElementAsync(elementToFocusOnDismiss);
    }
  });
  var forceFocusOrClickInTrap = useEventCallback(function(ev) {
    if (disabled) {
      return;
    }
    if (internalState.focusStackId === FocusTrapZone.focusStack.slice(-1)[0]) {
      var targetElement = ev.target;
      if (targetElement && !elementContains(root.current, targetElement)) {
        if (doc && doc.activeElement === doc.body) {
          setTimeout(function() {
            if (doc && doc.activeElement === doc.body) {
              focusFTZ();
              internalState.hasFocus = true;
            }
          }, 0);
        } else {
          focusFTZ();
          internalState.hasFocus = true;
        }
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  });
  React8.useEffect(function() {
    var disposables = [];
    if (forceFocusInsideTrap) {
      disposables.push(on(window, "focus", forceFocusOrClickInTrap, true));
    }
    if (!isClickableOutsideFocusTrap) {
      disposables.push(on(window, "click", forceFocusOrClickInTrap, true));
    }
    return function() {
      disposables.forEach(function(dispose) {
        return dispose();
      });
    };
  }, [forceFocusInsideTrap, isClickableOutsideFocusTrap]);
  React8.useEffect(function() {
    if (disabled || !isFirstRender && !forceFocusInsideTrap || !root.current) {
      return;
    }
    FocusTrapZone.focusStack.push(internalState.focusStackId);
    var elementToFocusOnDismiss = props.elementToFocusOnDismiss || doc.activeElement;
    if (!disableFirstFocus && !elementContains(root.current, elementToFocusOnDismiss)) {
      focusFTZ();
    }
    return function() {
      return returnFocusToInitiator(elementToFocusOnDismiss);
    };
  }, [forceFocusInsideTrap, disabled]);
  React8.useEffect(function() {
    if (!disabled && enableAriaHiddenSiblings) {
      var unmodalize = modalize(root.current);
      return unmodalize;
    }
  }, [disabled, enableAriaHiddenSiblings, root]);
  useUnmount(function() {
    delete internalState.previouslyFocusedElementInTrapZone;
  });
  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focusFTZ);
  return React8.createElement(
    "div",
    __assign({ "aria-labelledby": props.ariaLabelledBy }, getNativeProps(props, divProperties), { ref: mergedRootRef, onFocusCapture: onRootFocusCapture, onBlurCapture: onRootBlurCapture }),
    React8.createElement("div", __assign({}, bumperProps, { ref: firstBumper })),
    children,
    React8.createElement("div", __assign({}, bumperProps, { ref: lastBumper }))
  );
});
FocusTrapZone.displayName = COMPONENT_NAME2;
FocusTrapZone.focusStack = [];

// node_modules/@fluentui/react/lib/components/Callout/FocusTrapCallout.js
var FocusTrapCallout = function(props) {
  return React9.createElement(
    Callout,
    __assign({}, props),
    React9.createElement(FocusTrapZone, __assign({ disabled: props.hidden }, props.focusTrapProps), props.children)
  );
};

// node_modules/@fluentui/react/lib/components/Button/BaseButton.js
var React29 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Icon/Icon.base.js
var React12 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Icon/Icon.types.js
var IconType;
(function(IconType2) {
  IconType2[IconType2["default"] = 0] = "default";
  IconType2[IconType2["image"] = 1] = "image";
  IconType2[IconType2["Default"] = 1e5] = "Default";
  IconType2[IconType2["Image"] = 100001] = "Image";
})(IconType || (IconType = {}));

// node_modules/@fluentui/react/lib/components/Image/Image.base.js
var React10 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Image/Image.types.js
var ImageFit;
(function(ImageFit2) {
  ImageFit2[ImageFit2["center"] = 0] = "center";
  ImageFit2[ImageFit2["contain"] = 1] = "contain";
  ImageFit2[ImageFit2["cover"] = 2] = "cover";
  ImageFit2[ImageFit2["none"] = 3] = "none";
  ImageFit2[ImageFit2["centerCover"] = 4] = "centerCover";
  ImageFit2[ImageFit2["centerContain"] = 5] = "centerContain";
})(ImageFit || (ImageFit = {}));
var ImageCoverStyle;
(function(ImageCoverStyle2) {
  ImageCoverStyle2[ImageCoverStyle2["landscape"] = 0] = "landscape";
  ImageCoverStyle2[ImageCoverStyle2["portrait"] = 1] = "portrait";
})(ImageCoverStyle || (ImageCoverStyle = {}));
var ImageLoadState;
(function(ImageLoadState2) {
  ImageLoadState2[ImageLoadState2["notLoaded"] = 0] = "notLoaded";
  ImageLoadState2[ImageLoadState2["loaded"] = 1] = "loaded";
  ImageLoadState2[ImageLoadState2["error"] = 2] = "error";
  ImageLoadState2[ImageLoadState2["errorLoaded"] = 3] = "errorLoaded";
})(ImageLoadState || (ImageLoadState = {}));

// node_modules/@fluentui/react/lib/components/Image/Image.base.js
var getClassNames4 = classNamesFunction();
var SVG_REGEX = /\.svg$/i;
var KEY_PREFIX = "fabricImage";
function useLoadState(props, imageElement) {
  var onLoadingStateChange = props.onLoadingStateChange, onLoad = props.onLoad, onError = props.onError, src = props.src;
  var _a5 = React10.useState(ImageLoadState.notLoaded), loadState = _a5[0], setLoadState = _a5[1];
  useIsomorphicLayoutEffect(function() {
    setLoadState(ImageLoadState.notLoaded);
  }, [src]);
  React10.useEffect(function() {
    if (loadState === ImageLoadState.notLoaded) {
      var isLoaded = imageElement.current ? src && imageElement.current.naturalWidth > 0 && imageElement.current.naturalHeight > 0 || imageElement.current.complete && SVG_REGEX.test(src) : false;
      if (isLoaded) {
        setLoadState(ImageLoadState.loaded);
      }
    }
  });
  React10.useEffect(function() {
    onLoadingStateChange === null || onLoadingStateChange === void 0 ? void 0 : onLoadingStateChange(loadState);
  }, [loadState]);
  var onImageLoaded = React10.useCallback(function(ev) {
    onLoad === null || onLoad === void 0 ? void 0 : onLoad(ev);
    if (src) {
      setLoadState(ImageLoadState.loaded);
    }
  }, [src, onLoad]);
  var onImageError = React10.useCallback(function(ev) {
    onError === null || onError === void 0 ? void 0 : onError(ev);
    setLoadState(ImageLoadState.error);
  }, [onError]);
  return [loadState, onImageLoaded, onImageError];
}
var ImageBase = React10.forwardRef(function(props, forwardedRef) {
  var frameElement = React10.useRef();
  var imageElement = React10.useRef();
  var _a5 = useLoadState(props, imageElement), loadState = _a5[0], onImageLoaded = _a5[1], onImageError = _a5[2];
  var imageProps = getNativeProps(props, imgProperties, [
    "width",
    "height"
  ]);
  var src = props.src, alt = props.alt, width = props.width, height = props.height, _b3 = props.shouldFadeIn, shouldFadeIn = _b3 === void 0 ? true : _b3, shouldStartVisible = props.shouldStartVisible, className = props.className, imageFit = props.imageFit, role = props.role, maximizeFrame = props.maximizeFrame, styles = props.styles, theme = props.theme, loading = props.loading;
  var coverStyle = useCoverStyle(props, loadState, imageElement, frameElement);
  var classNames2 = getClassNames4(styles, {
    theme,
    className,
    width,
    height,
    maximizeFrame,
    shouldFadeIn,
    shouldStartVisible,
    isLoaded: loadState === ImageLoadState.loaded || loadState === ImageLoadState.notLoaded && props.shouldStartVisible,
    isLandscape: coverStyle === ImageCoverStyle.landscape,
    isCenter: imageFit === ImageFit.center,
    isCenterContain: imageFit === ImageFit.centerContain,
    isCenterCover: imageFit === ImageFit.centerCover,
    isContain: imageFit === ImageFit.contain,
    isCover: imageFit === ImageFit.cover,
    isNone: imageFit === ImageFit.none,
    isError: loadState === ImageLoadState.error,
    isNotImageFit: imageFit === void 0
  });
  return React10.createElement(
    "div",
    { className: classNames2.root, style: { width, height }, ref: frameElement },
    React10.createElement("img", __assign({}, imageProps, { onLoad: onImageLoaded, onError: onImageError, key: KEY_PREFIX + props.src || "", className: classNames2.image, ref: useMergedRefs(imageElement, forwardedRef), src, alt, role, loading }))
  );
});
ImageBase.displayName = "ImageBase";
function useCoverStyle(props, loadState, imageElement, frameElement) {
  var previousLoadState = React10.useRef(loadState);
  var coverStyle = React10.useRef();
  if (coverStyle === void 0 || previousLoadState.current === ImageLoadState.notLoaded && loadState === ImageLoadState.loaded) {
    coverStyle.current = computeCoverStyle(props, loadState, imageElement, frameElement);
  }
  previousLoadState.current = loadState;
  return coverStyle.current;
}
function computeCoverStyle(props, loadState, imageElement, frameElement) {
  var imageFit = props.imageFit, width = props.width, height = props.height;
  if (props.coverStyle !== void 0) {
    return props.coverStyle;
  } else if (loadState === ImageLoadState.loaded && (imageFit === ImageFit.cover || imageFit === ImageFit.contain || imageFit === ImageFit.centerContain || imageFit === ImageFit.centerCover) && imageElement.current && frameElement.current) {
    var desiredRatio = void 0;
    if (typeof width === "number" && typeof height === "number" && imageFit !== ImageFit.centerContain && imageFit !== ImageFit.centerCover) {
      desiredRatio = width / height;
    } else {
      desiredRatio = frameElement.current.clientWidth / frameElement.current.clientHeight;
    }
    var naturalRatio = imageElement.current.naturalWidth / imageElement.current.naturalHeight;
    if (naturalRatio > desiredRatio) {
      return ImageCoverStyle.landscape;
    }
  }
  return ImageCoverStyle.portrait;
}

// node_modules/@fluentui/react/lib/components/Image/Image.styles.js
var GlobalClassNames4 = {
  root: "ms-Image",
  rootMaximizeFrame: "ms-Image--maximizeFrame",
  image: "ms-Image-image",
  imageCenter: "ms-Image-image--center",
  imageContain: "ms-Image-image--contain",
  imageCover: "ms-Image-image--cover",
  imageCenterContain: "ms-Image-image--centerContain",
  imageCenterCover: "ms-Image-image--centerCover",
  imageNone: "ms-Image-image--none",
  imageLandscape: "ms-Image-image--landscape",
  imagePortrait: "ms-Image-image--portrait"
};
var getStyles4 = function(props) {
  var className = props.className, width = props.width, height = props.height, maximizeFrame = props.maximizeFrame, isLoaded = props.isLoaded, shouldFadeIn = props.shouldFadeIn, shouldStartVisible = props.shouldStartVisible, isLandscape = props.isLandscape, isCenter = props.isCenter, isContain = props.isContain, isCover = props.isCover, isCenterContain = props.isCenterContain, isCenterCover = props.isCenterCover, isNone = props.isNone, isError = props.isError, isNotImageFit = props.isNotImageFit, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames4, theme);
  var ImageFitStyles = {
    position: "absolute",
    left: "50% /* @noflip */",
    top: "50%",
    transform: "translate(-50%,-50%)"
    // @todo test RTL renders transform: translate(50%,-50%);
  };
  var window2 = getWindow();
  var supportsObjectFit = window2 !== void 0 && // eslint-disable-next-line @fluentui/max-len
  // cast needed as vendor prefixed `msMaxTouchPoints` api is no longer part of TS lib declaration - introduced with TS 4.4
  window2.navigator.msMaxTouchPoints === void 0;
  var fallbackObjectFitStyles = isContain && isLandscape || isCover && !isLandscape ? { width: "100%", height: "auto" } : { width: "auto", height: "100%" };
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        overflow: "hidden"
      },
      maximizeFrame && [
        classNames2.rootMaximizeFrame,
        {
          height: "100%",
          width: "100%"
        }
      ],
      isLoaded && shouldFadeIn && !shouldStartVisible && AnimationClassNames.fadeIn400,
      (isCenter || isContain || isCover || isCenterContain || isCenterCover) && {
        position: "relative"
      },
      className
    ],
    image: [
      classNames2.image,
      {
        display: "block",
        opacity: 0
      },
      isLoaded && [
        "is-loaded",
        {
          opacity: 1
        }
      ],
      isCenter && [classNames2.imageCenter, ImageFitStyles],
      isContain && [
        classNames2.imageContain,
        supportsObjectFit && {
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        !supportsObjectFit && fallbackObjectFitStyles,
        !supportsObjectFit && ImageFitStyles
      ],
      isCover && [
        classNames2.imageCover,
        supportsObjectFit && {
          width: "100%",
          height: "100%",
          objectFit: "cover"
        },
        !supportsObjectFit && fallbackObjectFitStyles,
        !supportsObjectFit && ImageFitStyles
      ],
      isCenterContain && [
        classNames2.imageCenterContain,
        isLandscape && {
          maxWidth: "100%"
        },
        !isLandscape && {
          maxHeight: "100%"
        },
        ImageFitStyles
      ],
      isCenterCover && [
        classNames2.imageCenterCover,
        isLandscape && {
          maxHeight: "100%"
        },
        !isLandscape && {
          maxWidth: "100%"
        },
        ImageFitStyles
      ],
      isNone && [
        classNames2.imageNone,
        {
          width: "auto",
          height: "auto"
        }
      ],
      isNotImageFit && [
        !!width && !height && {
          height: "auto",
          width: "100%"
        },
        !width && !!height && {
          height: "100%",
          width: "auto"
        },
        !!width && !!height && {
          height: "100%",
          width: "100%"
        }
      ],
      isLandscape && classNames2.imageLandscape,
      !isLandscape && classNames2.imagePortrait,
      !isLoaded && "is-notLoaded",
      shouldFadeIn && "is-fadeIn",
      isError && "is-error"
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Image/Image.js
var Image = styled(ImageBase, getStyles4, void 0, {
  scope: "Image"
}, true);
Image.displayName = "Image";

// node_modules/@fluentui/react/lib/components/Icon/FontIcon.js
var React11 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Icon/Icon.styles.js
var classNames = mergeStyleSets({
  root: {
    display: "inline-block"
  },
  placeholder: [
    "ms-Icon-placeHolder",
    {
      width: "1em"
    }
  ],
  image: [
    "ms-Icon-imageContainer",
    {
      overflow: "hidden"
    }
  ]
});
var MS_ICON = "ms-Icon";
var getStyles5 = function(props) {
  var className = props.className, iconClassName = props.iconClassName, isPlaceholder = props.isPlaceholder, isImage = props.isImage, styles = props.styles;
  return {
    root: [
      isPlaceholder && classNames.placeholder,
      classNames.root,
      isImage && classNames.image,
      iconClassName,
      className,
      styles && styles.root,
      // eslint-disable-next-line deprecation/deprecation
      styles && styles.imageContainer
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Icon/FontIcon.js
var getIconContent = memoizeFunction(
  function(iconName) {
    var _a5 = getIcon(iconName) || {
      subset: {},
      code: void 0
    }, code = _a5.code, subset = _a5.subset;
    if (!code) {
      return null;
    }
    return {
      children: code,
      iconClassName: subset.className,
      fontFamily: subset.fontFace && subset.fontFace.fontFamily,
      mergeImageProps: subset.mergeImageProps
    };
  },
  void 0,
  true
  /*ignoreNullOrUndefinedResult */
);
var FontIcon = function(props) {
  var iconName = props.iconName, className = props.className, _a5 = props.style, style = _a5 === void 0 ? {} : _a5;
  var iconContent = getIconContent(iconName) || {};
  var iconClassName = iconContent.iconClassName, children = iconContent.children, fontFamily = iconContent.fontFamily, mergeImageProps = iconContent.mergeImageProps;
  var nativeProps = getNativeProps(props, htmlElementProperties);
  var accessibleName = props["aria-label"] || props.title;
  var containerProps = props["aria-label"] || props["aria-labelledby"] || props.title ? {
    role: mergeImageProps ? void 0 : "img"
  } : {
    "aria-hidden": true
  };
  var finalChildren = children;
  if (mergeImageProps) {
    if (typeof children === "object" && typeof children.props === "object" && accessibleName) {
      finalChildren = React11.cloneElement(children, { alt: accessibleName });
    }
  }
  return React11.createElement("i", __assign({ "data-icon-name": iconName }, containerProps, nativeProps, mergeImageProps ? {
    title: void 0,
    "aria-label": void 0
  } : {}, {
    className: css(MS_ICON, classNames.root, iconClassName, !iconName && classNames.placeholder, className),
    // Apply the font family this way to ensure it doesn't get overridden by Fabric Core ms-Icon styles
    // https://github.com/microsoft/fluentui/issues/10449
    style: __assign({ fontFamily }, style)
  }), finalChildren);
};
var getFontIcon = memoizeFunction(function(iconName, className, ariaLabel) {
  return FontIcon({ iconName, className, "aria-label": ariaLabel });
});

// node_modules/@fluentui/react/lib/components/Icon/Icon.base.js
var getClassNames5 = classNamesFunction({
  // Icon is used a lot by other components.
  // It's likely to see expected cases which pass different className to the Icon.
  // Therefore setting a larger cache size.
  cacheSize: 100
});
var IconBase = (
  /** @class */
  function(_super) {
    __extends(IconBase2, _super);
    function IconBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._onImageLoadingStateChange = function(state) {
        if (_this.props.imageProps && _this.props.imageProps.onLoadingStateChange) {
          _this.props.imageProps.onLoadingStateChange(state);
        }
        if (state === ImageLoadState.error) {
          _this.setState({ imageLoadError: true });
        }
      };
      _this.state = {
        imageLoadError: false
      };
      return _this;
    }
    IconBase2.prototype.render = function() {
      var _a5 = this.props, children = _a5.children, className = _a5.className, styles = _a5.styles, iconName = _a5.iconName, imageErrorAs = _a5.imageErrorAs, theme = _a5.theme;
      var isPlaceholder = typeof iconName === "string" && iconName.length === 0;
      var isImage = (
        // eslint-disable-next-line deprecation/deprecation
        !!this.props.imageProps || this.props.iconType === IconType.image || this.props.iconType === IconType.Image
      );
      var iconContent = getIconContent(iconName) || {};
      var iconClassName = iconContent.iconClassName, iconContentChildren = iconContent.children, mergeImageProps = iconContent.mergeImageProps;
      var classNames2 = getClassNames5(styles, {
        theme,
        className,
        iconClassName,
        isImage,
        isPlaceholder
      });
      var RootType = isImage ? "span" : "i";
      var nativeProps = getNativeProps(this.props, htmlElementProperties, [
        "aria-label"
      ]);
      var imageLoadError = this.state.imageLoadError;
      var imageProps = __assign(__assign({}, this.props.imageProps), { onLoadingStateChange: this._onImageLoadingStateChange });
      var ImageType = imageLoadError && imageErrorAs || Image;
      var ariaLabel = this.props["aria-label"] || this.props.ariaLabel;
      var accessibleName = imageProps.alt || ariaLabel || this.props.title;
      var hasName = !!(accessibleName || this.props["aria-labelledby"] || imageProps["aria-label"] || imageProps["aria-labelledby"]);
      var containerProps = hasName ? {
        role: isImage || mergeImageProps ? void 0 : "img",
        "aria-label": isImage || mergeImageProps ? void 0 : accessibleName
      } : {
        "aria-hidden": true
      };
      var finalIconContentChildren = iconContentChildren;
      if (mergeImageProps && iconContentChildren && typeof iconContentChildren === "object" && accessibleName) {
        finalIconContentChildren = React12.cloneElement(iconContentChildren, {
          alt: accessibleName
        });
      }
      return React12.createElement(RootType, __assign({ "data-icon-name": iconName }, containerProps, nativeProps, mergeImageProps ? {
        title: void 0,
        "aria-label": void 0
      } : {}, { className: classNames2.root }), isImage ? React12.createElement(ImageType, __assign({}, imageProps)) : children || finalIconContentChildren);
    };
    return IconBase2;
  }(React12.Component)
);

// node_modules/@fluentui/react/lib/components/Icon/Icon.js
var Icon = styled(IconBase, getStyles5, void 0, {
  scope: "Icon"
}, true);
Icon.displayName = "Icon";

// node_modules/@fluentui/react/lib/components/Icon/ImageIcon.js
var React13 = __toESM(require_react());
var ImageIcon = function(props) {
  var className = props.className, imageProps = props.imageProps;
  var nativeProps = getNativeProps(props, htmlElementProperties, [
    "aria-label",
    "aria-labelledby",
    "title",
    "aria-describedby"
  ]);
  var altText = imageProps.alt || props["aria-label"];
  var hasName = altText || props["aria-labelledby"] || props.title || imageProps["aria-label"] || imageProps["aria-labelledby"] || imageProps.title;
  var imageNameProps = {
    "aria-labelledby": props["aria-labelledby"],
    "aria-describedby": props["aria-describedby"],
    title: props.title
  };
  var containerProps = hasName ? {} : {
    "aria-hidden": true
  };
  return React13.createElement(
    "div",
    __assign({}, containerProps, nativeProps, { className: css(MS_ICON, classNames.root, classNames.image, className) }),
    React13.createElement(Image, __assign({}, imageNameProps, imageProps, { alt: hasName ? altText : "" }))
  );
};

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.js
var React28 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.base.js
var React27 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.types.js
var ContextualMenuItemType;
(function(ContextualMenuItemType2) {
  ContextualMenuItemType2[ContextualMenuItemType2["Normal"] = 0] = "Normal";
  ContextualMenuItemType2[ContextualMenuItemType2["Divider"] = 1] = "Divider";
  ContextualMenuItemType2[ContextualMenuItemType2["Header"] = 2] = "Header";
  ContextualMenuItemType2[ContextualMenuItemType2["Section"] = 3] = "Section";
})(ContextualMenuItemType || (ContextualMenuItemType = {}));

// node_modules/@fluentui/react-focus/lib/version.js
setVersion("@fluentui/react-focus", "8.8.28");

// node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.js
var React14 = __toESM(require_react());

// node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.types.js
var FocusZoneTabbableElements = {
  /** Tabbing is not allowed */
  none: 0,
  /** All tabbing action is allowed */
  all: 1,
  /** Tabbing is allowed only on input elements */
  inputOnly: 2
};
var FocusZoneDirection;
(function(FocusZoneDirection2) {
  FocusZoneDirection2[FocusZoneDirection2["vertical"] = 0] = "vertical";
  FocusZoneDirection2[FocusZoneDirection2["horizontal"] = 1] = "horizontal";
  FocusZoneDirection2[FocusZoneDirection2["bidirectional"] = 2] = "bidirectional";
  FocusZoneDirection2[FocusZoneDirection2["domOrder"] = 3] = "domOrder";
})(FocusZoneDirection || (FocusZoneDirection = {}));

// node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.js
var IS_FOCUSABLE_ATTRIBUTE = "data-is-focusable";
var IS_ENTER_DISABLED_ATTRIBUTE = "data-disable-click-on-enter";
var FOCUSZONE_ID_ATTRIBUTE = "data-focuszone-id";
var TABINDEX = "tabindex";
var NO_VERTICAL_WRAP = "data-no-vertical-wrap";
var NO_HORIZONTAL_WRAP = "data-no-horizontal-wrap";
var LARGE_DISTANCE_FROM_CENTER = 999999999;
var LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;
var focusZoneStyles;
var focusZoneClass = "ms-FocusZone";
function raiseClickFromKeyboardEvent(target, ev) {
  var event;
  if (typeof MouseEvent === "function") {
    event = new MouseEvent("click", {
      ctrlKey: ev === null || ev === void 0 ? void 0 : ev.ctrlKey,
      metaKey: ev === null || ev === void 0 ? void 0 : ev.metaKey,
      shiftKey: ev === null || ev === void 0 ? void 0 : ev.shiftKey,
      altKey: ev === null || ev === void 0 ? void 0 : ev.altKey,
      bubbles: ev === null || ev === void 0 ? void 0 : ev.bubbles,
      cancelable: ev === null || ev === void 0 ? void 0 : ev.cancelable
    });
  } else {
    event = document.createEvent("MouseEvents");
    event.initMouseEvent(
      "click",
      ev ? ev.bubbles : false,
      ev ? ev.cancelable : false,
      window,
      // not using getWindow() since this can only be run client side
      0,
      // detail
      0,
      // screen x
      0,
      // screen y
      0,
      // client x
      0,
      // client y
      ev ? ev.ctrlKey : false,
      ev ? ev.altKey : false,
      ev ? ev.shiftKey : false,
      ev ? ev.metaKey : false,
      0,
      // button
      null
    );
  }
  target.dispatchEvent(event);
}
function getRootClass() {
  if (!focusZoneStyles) {
    focusZoneStyles = mergeStyles({
      selectors: {
        ":focus": {
          outline: "none"
        }
      }
    }, focusZoneClass);
  }
  return focusZoneStyles;
}
var _allInstances = {};
var _outerZones = /* @__PURE__ */ new Set();
var ALLOWED_INPUT_TYPES = ["text", "number", "password", "email", "tel", "url", "search", "textarea"];
var ALLOW_VIRTUAL_ELEMENTS = false;
var FocusZone = (
  /** @class */
  function(_super) {
    __extends(FocusZone2, _super);
    function FocusZone2(props) {
      var _this = this;
      var _a5, _b3, _c3, _d3;
      _this = _super.call(this, props) || this;
      _this._root = React14.createRef();
      _this._mergedRef = createMergedRef();
      _this._onFocus = function(ev) {
        if (_this._portalContainsElement(ev.target)) {
          return;
        }
        var _a6 = _this.props, onActiveElementChanged = _a6.onActiveElementChanged, doNotAllowFocusEventToPropagate = _a6.doNotAllowFocusEventToPropagate, stopFocusPropagation = _a6.stopFocusPropagation, onFocusNotification = _a6.onFocusNotification, onFocus = _a6.onFocus, shouldFocusInnerElementWhenReceivedFocus = _a6.shouldFocusInnerElementWhenReceivedFocus, defaultTabbableElement = _a6.defaultTabbableElement;
        var isImmediateDescendant = _this._isImmediateDescendantOfZone(ev.target);
        var newActiveElement;
        if (isImmediateDescendant) {
          newActiveElement = ev.target;
        } else {
          var parentElement = ev.target;
          while (parentElement && parentElement !== _this._root.current) {
            if (isElementTabbable(parentElement) && _this._isImmediateDescendantOfZone(parentElement)) {
              newActiveElement = parentElement;
              break;
            }
            parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
          }
        }
        if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {
          var maybeElementToFocus = defaultTabbableElement && typeof defaultTabbableElement === "function" && _this._root.current && defaultTabbableElement(_this._root.current);
          if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {
            newActiveElement = maybeElementToFocus;
            maybeElementToFocus.focus();
          } else {
            _this.focus(true);
            if (_this._activeElement) {
              newActiveElement = null;
            }
          }
        }
        var initialElementFocused = !_this._activeElement;
        if (newActiveElement && newActiveElement !== _this._activeElement) {
          if (isImmediateDescendant || initialElementFocused) {
            _this._setFocusAlignment(newActiveElement, true, true);
          }
          _this._activeElement = newActiveElement;
          if (initialElementFocused) {
            _this._updateTabIndexes();
          }
        }
        if (onActiveElementChanged) {
          onActiveElementChanged(_this._activeElement, ev);
        }
        if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {
          ev.stopPropagation();
        }
        if (onFocus) {
          onFocus(ev);
        } else if (onFocusNotification) {
          onFocusNotification();
        }
      };
      _this._onBlur = function() {
        _this._setParkedFocus(false);
      };
      _this._onMouseDown = function(ev) {
        if (_this._portalContainsElement(ev.target)) {
          return;
        }
        var disabled = _this.props.disabled;
        if (disabled) {
          return;
        }
        var target = ev.target;
        var path = [];
        while (target && target !== _this._root.current) {
          path.push(target);
          target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
        }
        while (path.length) {
          target = path.pop();
          if (target && isElementTabbable(target)) {
            _this._setActiveElement(target, true);
          }
          if (isElementFocusZone(target)) {
            break;
          }
        }
      };
      _this._onKeyDown = function(ev, theme) {
        if (_this._portalContainsElement(ev.target)) {
          return;
        }
        var _a6 = _this.props, direction = _a6.direction, disabled = _a6.disabled, isInnerZoneKeystroke = _a6.isInnerZoneKeystroke, pagingSupportDisabled = _a6.pagingSupportDisabled, shouldEnterInnerZone = _a6.shouldEnterInnerZone;
        if (disabled) {
          return;
        }
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(ev);
        }
        if (ev.isDefaultPrevented()) {
          return;
        }
        if (_this._getDocument().activeElement === _this._root.current && _this._isInnerZone) {
          return;
        }
        if ((shouldEnterInnerZone && shouldEnterInnerZone(ev) || isInnerZoneKeystroke && isInnerZoneKeystroke(ev)) && _this._isImmediateDescendantOfZone(ev.target)) {
          var innerZone = _this._getFirstInnerZone();
          if (innerZone) {
            if (!innerZone.focus(true)) {
              return;
            }
          } else if (isElementFocusSubZone(ev.target)) {
            if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {
              return;
            }
          } else {
            return;
          }
        } else if (ev.altKey) {
          return;
        } else {
          switch (ev.which) {
            case KeyCodes.space:
              if (_this._shouldRaiseClicksOnSpace && _this._tryInvokeClickForFocusable(ev.target, ev)) {
                break;
              }
              return;
            case KeyCodes.left:
              if (direction !== FocusZoneDirection.vertical) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusLeft(theme)) {
                  break;
                }
              }
              return;
            case KeyCodes.right:
              if (direction !== FocusZoneDirection.vertical) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusRight(theme)) {
                  break;
                }
              }
              return;
            case KeyCodes.up:
              if (direction !== FocusZoneDirection.horizontal) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusUp()) {
                  break;
                }
              }
              return;
            case KeyCodes.down:
              if (direction !== FocusZoneDirection.horizontal) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusDown()) {
                  break;
                }
              }
              return;
            case KeyCodes.pageDown:
              if (!pagingSupportDisabled && _this._moveFocusPaging(true)) {
                break;
              }
              return;
            case KeyCodes.pageUp:
              if (!pagingSupportDisabled && _this._moveFocusPaging(false)) {
                break;
              }
              return;
            case KeyCodes.tab:
              if (
                // eslint-disable-next-line deprecation/deprecation
                _this.props.allowTabKey || _this.props.handleTabKey === FocusZoneTabbableElements.all || _this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && _this._isElementInput(ev.target)
              ) {
                var focusChanged = false;
                _this._processingTabKey = true;
                if (direction === FocusZoneDirection.vertical || !_this._shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {
                  focusChanged = ev.shiftKey ? _this._moveFocusUp() : _this._moveFocusDown();
                } else {
                  var tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;
                  focusChanged = tabWithDirection ? _this._moveFocusLeft(theme) : _this._moveFocusRight(theme);
                }
                _this._processingTabKey = false;
                if (focusChanged) {
                  break;
                } else if (_this.props.shouldResetActiveElementWhenTabFromZone) {
                  _this._activeElement = null;
                }
              }
              return;
            case KeyCodes.home:
              if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, false)) {
                return false;
              }
              var firstChild = _this._root.current && _this._root.current.firstChild;
              if (_this._root.current && firstChild && _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {
                break;
              }
              return;
            case KeyCodes.end:
              if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, true)) {
                return false;
              }
              var lastChild = _this._root.current && _this._root.current.lastChild;
              if (_this._root.current && _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {
                break;
              }
              return;
            case KeyCodes.enter:
              if (_this._shouldRaiseClicksOnEnter && _this._tryInvokeClickForFocusable(ev.target, ev)) {
                break;
              }
              return;
            default:
              return;
          }
        }
        ev.preventDefault();
        ev.stopPropagation();
      };
      _this._getHorizontalDistanceFromCenter = function(isForward, activeRect, targetRect) {
        var leftAlignment = _this._focusAlignment.left || _this._focusAlignment.x || 0;
        var targetRectTop = Math.floor(targetRect.top);
        var activeRectBottom = Math.floor(activeRect.bottom);
        var targetRectBottom = Math.floor(targetRect.bottom);
        var activeRectTop = Math.floor(activeRect.top);
        var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;
        var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;
        if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {
          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
            return 0;
          }
          return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
        }
        if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
        }
        return LARGE_DISTANCE_FROM_CENTER;
      };
      initializeComponentRef(_this);
      if (true) {
        warnDeprecations("FocusZone", props, {
          rootProps: void 0,
          allowTabKey: "handleTabKey",
          elementType: "as",
          ariaDescribedBy: "aria-describedby",
          ariaLabelledBy: "aria-labelledby"
        });
      }
      _this._id = getId("FocusZone");
      _this._focusAlignment = {
        left: 0,
        top: 0
      };
      _this._processingTabKey = false;
      var shouldRaiseClicksFallback = (_b3 = (_a5 = props.shouldRaiseClicks) !== null && _a5 !== void 0 ? _a5 : FocusZone2.defaultProps.shouldRaiseClicks) !== null && _b3 !== void 0 ? _b3 : true;
      _this._shouldRaiseClicksOnEnter = (_c3 = props.shouldRaiseClicksOnEnter) !== null && _c3 !== void 0 ? _c3 : shouldRaiseClicksFallback;
      _this._shouldRaiseClicksOnSpace = (_d3 = props.shouldRaiseClicksOnSpace) !== null && _d3 !== void 0 ? _d3 : shouldRaiseClicksFallback;
      return _this;
    }
    FocusZone2.getOuterZones = function() {
      return _outerZones.size;
    };
    FocusZone2._onKeyDownCapture = function(ev) {
      if (ev.which === KeyCodes.tab) {
        _outerZones.forEach(function(zone) {
          return zone._updateTabIndexes();
        });
      }
    };
    FocusZone2.prototype.componentDidMount = function() {
      var root = this._root.current;
      _allInstances[this._id] = this;
      if (root) {
        var parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);
        while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {
          if (isElementFocusZone(parentElement)) {
            this._isInnerZone = true;
            break;
          }
          parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
        }
        if (!this._isInnerZone) {
          _outerZones.add(this);
          this._root.current && this._root.current.addEventListener("keydown", FocusZone2._onKeyDownCapture, true);
        }
        this._root.current && this._root.current.addEventListener("blur", this._onBlur, true);
        this._updateTabIndexes();
        if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === "string") {
          this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement);
        } else if (this.props.defaultActiveElement) {
          this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement);
        }
        if (this.props.shouldFocusOnMount) {
          this.focus();
        }
      }
    };
    FocusZone2.prototype.componentDidUpdate = function() {
      var root = this._root.current;
      var doc = this._getDocument();
      if (this._activeElement && !elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) || this._defaultFocusElement && !elementContains(this._root.current, this._defaultFocusElement, ALLOW_VIRTUAL_ELEMENTS)) {
        this._activeElement = null;
        this._defaultFocusElement = null;
        this._updateTabIndexes();
      }
      if (!this.props.preventFocusRestoration && doc && this._lastIndexPath && (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)) {
        var elementToFocus = getFocusableByIndexPath(root, this._lastIndexPath);
        if (elementToFocus) {
          this._setActiveElement(elementToFocus, true);
          elementToFocus.focus();
          this._setParkedFocus(false);
        } else {
          this._setParkedFocus(true);
        }
      }
    };
    FocusZone2.prototype.componentWillUnmount = function() {
      delete _allInstances[this._id];
      if (!this._isInnerZone) {
        _outerZones.delete(this);
        this._root.current && this._root.current.removeEventListener("keydown", FocusZone2._onKeyDownCapture, true);
      }
      if (this._root.current) {
        this._root.current.removeEventListener("blur", this._onBlur, true);
      }
      this._activeElement = null;
      this._defaultFocusElement = null;
    };
    FocusZone2.prototype.render = function() {
      var _this = this;
      var _a5 = this.props, tag = _a5.as, elementType = _a5.elementType, rootProps = _a5.rootProps, ariaDescribedBy = _a5.ariaDescribedBy, ariaLabelledBy = _a5.ariaLabelledBy, className = _a5.className;
      var divProps = getNativeProps(this.props, htmlElementProperties);
      var Tag = tag || elementType || "div";
      this._evaluateFocusBeforeRender();
      var theme = getTheme();
      return React14.createElement(Tag, __assign({ "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy }, divProps, rootProps, {
        // Once the getClassName correctly memoizes inputs this should
        // be replaced so that className is passed to getRootClass and is included there so
        // the class names will always be in the same order.
        className: css(getRootClass(), className),
        // eslint-disable-next-line deprecation/deprecation
        ref: this._mergedRef(this.props.elementRef, this._root),
        "data-focuszone-id": this._id,
        // eslint-disable-next-line react/jsx-no-bind
        onKeyDown: function(ev) {
          return _this._onKeyDown(ev, theme);
        },
        onFocus: this._onFocus,
        onMouseDownCapture: this._onMouseDown
      }), this.props.children);
    };
    FocusZone2.prototype.focus = function(forceIntoFirstElement, bypassHiddenElements) {
      if (forceIntoFirstElement === void 0) {
        forceIntoFirstElement = false;
      }
      if (bypassHiddenElements === void 0) {
        bypassHiddenElements = false;
      }
      if (this._root.current) {
        if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true" && this._isInnerZone) {
          var ownerZoneElement = this._getOwnerZone(this._root.current);
          if (ownerZoneElement !== this._root.current) {
            var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
            return !!ownerZone && ownerZone.focusElement(this._root.current);
          }
          return false;
        } else if (!forceIntoFirstElement && this._activeElement && elementContains(this._root.current, this._activeElement) && isElementTabbable(this._activeElement) && (!bypassHiddenElements || isElementVisibleAndNotHidden(this._activeElement))) {
          this._activeElement.focus();
          return true;
        } else {
          var firstChild = this._root.current.firstChild;
          return this.focusElement(getNextElement(this._root.current, firstChild, true, void 0, void 0, void 0, void 0, void 0, bypassHiddenElements));
        }
      }
      return false;
    };
    FocusZone2.prototype.focusLast = function() {
      if (this._root.current) {
        var lastChild = this._root.current && this._root.current.lastChild;
        return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));
      }
      return false;
    };
    FocusZone2.prototype.focusElement = function(element, forceAlignment) {
      var _a5 = this.props, onBeforeFocus = _a5.onBeforeFocus, shouldReceiveFocus = _a5.shouldReceiveFocus;
      if (shouldReceiveFocus && !shouldReceiveFocus(element) || onBeforeFocus && !onBeforeFocus(element)) {
        return false;
      }
      if (element) {
        this._setActiveElement(element, forceAlignment);
        if (this._activeElement) {
          this._activeElement.focus();
        }
        return true;
      }
      return false;
    };
    FocusZone2.prototype.setFocusAlignment = function(point) {
      this._focusAlignment = point;
    };
    Object.defineProperty(FocusZone2.prototype, "defaultFocusElement", {
      get: function() {
        return this._defaultFocusElement;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FocusZone2.prototype, "activeElement", {
      get: function() {
        return this._activeElement;
      },
      enumerable: false,
      configurable: true
    });
    FocusZone2.prototype._evaluateFocusBeforeRender = function() {
      var root = this._root.current;
      var doc = this._getDocument();
      if (doc) {
        var focusedElement = doc.activeElement;
        if (focusedElement !== root) {
          var shouldRestoreFocus = elementContains(root, focusedElement, false);
          this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root, focusedElement) : void 0;
        }
      }
    };
    FocusZone2.prototype._setParkedFocus = function(isParked) {
      var root = this._root.current;
      if (root && this._isParked !== isParked) {
        this._isParked = isParked;
        if (isParked) {
          if (!this.props.allowFocusRoot) {
            this._parkedTabIndex = root.getAttribute("tabindex");
            root.setAttribute("tabindex", "-1");
          }
          root.focus();
        } else if (!this.props.allowFocusRoot) {
          if (this._parkedTabIndex) {
            root.setAttribute("tabindex", this._parkedTabIndex);
            this._parkedTabIndex = void 0;
          } else {
            root.removeAttribute("tabindex");
          }
        }
      }
    };
    FocusZone2.prototype._setActiveElement = function(element, forceAlignment) {
      var previousActiveElement = this._activeElement;
      this._activeElement = element;
      if (previousActiveElement) {
        if (isElementFocusZone(previousActiveElement)) {
          this._updateTabIndexes(previousActiveElement);
        }
        previousActiveElement.tabIndex = -1;
      }
      if (this._activeElement) {
        if (!this._focusAlignment || forceAlignment) {
          this._setFocusAlignment(element, true, true);
        }
        this._activeElement.tabIndex = 0;
      }
    };
    FocusZone2.prototype._preventDefaultWhenHandled = function(ev) {
      this.props.preventDefaultWhenHandled && ev.preventDefault();
    };
    FocusZone2.prototype._tryInvokeClickForFocusable = function(targetElement, ev) {
      var target = targetElement;
      if (target === this._root.current) {
        return false;
      }
      do {
        if (target.tagName === "BUTTON" || target.tagName === "A" || target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "SUMMARY") {
          return false;
        }
        if (this._isImmediateDescendantOfZone(target) && target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true" && target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== "true") {
          raiseClickFromKeyboardEvent(target, ev);
          return true;
        }
        target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
      } while (target !== this._root.current);
      return false;
    };
    FocusZone2.prototype._getFirstInnerZone = function(rootElement) {
      rootElement = rootElement || this._activeElement || this._root.current;
      if (!rootElement) {
        return null;
      }
      if (isElementFocusZone(rootElement)) {
        return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
      }
      var child = rootElement.firstElementChild;
      while (child) {
        if (isElementFocusZone(child)) {
          return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
        }
        var match = this._getFirstInnerZone(child);
        if (match) {
          return match;
        }
        child = child.nextElementSibling;
      }
      return null;
    };
    FocusZone2.prototype._moveFocus = function(isForward, getDistanceFromCenter, ev, useDefaultWrap) {
      if (useDefaultWrap === void 0) {
        useDefaultWrap = true;
      }
      var element = this._activeElement;
      var candidateDistance = -1;
      var candidateElement = void 0;
      var changedFocus = false;
      var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;
      if (!element || !this._root.current) {
        return false;
      }
      if (this._isElementInput(element)) {
        if (!this._shouldInputLoseFocus(element, isForward)) {
          return false;
        }
      }
      var activeRect = isBidirectional ? element.getBoundingClientRect() : null;
      do {
        element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);
        if (isBidirectional) {
          if (element) {
            var targetRect = element.getBoundingClientRect();
            var elementDistance = getDistanceFromCenter(activeRect, targetRect);
            if (elementDistance === -1 && candidateDistance === -1) {
              candidateElement = element;
              break;
            }
            if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
              candidateDistance = elementDistance;
              candidateElement = element;
            }
            if (candidateDistance >= 0 && elementDistance < 0) {
              break;
            }
          }
        } else {
          candidateElement = element;
          break;
        }
      } while (element);
      if (candidateElement && candidateElement !== this._activeElement) {
        changedFocus = true;
        this.focusElement(candidateElement);
      } else if (this.props.isCircularNavigation && useDefaultWrap) {
        if (isForward) {
          return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
        } else {
          return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
        }
      }
      return changedFocus;
    };
    FocusZone2.prototype._moveFocusDown = function() {
      var _this = this;
      var targetTop = -1;
      var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
      if (
        // eslint-disable-next-line deprecation/deprecation
        this._moveFocus(true, function(activeRect, targetRect) {
          var distance = -1;
          var targetRectTop = Math.floor(targetRect.top);
          var activeRectBottom = Math.floor(activeRect.bottom);
          if (targetRectTop < activeRectBottom) {
            if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
              return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return LARGE_DISTANCE_FROM_CENTER;
          }
          if (targetTop === -1 && targetRectTop >= activeRectBottom || targetRectTop === targetTop) {
            targetTop = targetRectTop;
            if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
              distance = 0;
            } else {
              distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
            }
          }
          return distance;
        })
      ) {
        this._setFocusAlignment(this._activeElement, false, true);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusUp = function() {
      var _this = this;
      var targetTop = -1;
      var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
      if (
        // eslint-disable-next-line deprecation/deprecation
        this._moveFocus(false, function(activeRect, targetRect) {
          var distance = -1;
          var targetRectBottom = Math.floor(targetRect.bottom);
          var targetRectTop = Math.floor(targetRect.top);
          var activeRectTop = Math.floor(activeRect.top);
          if (targetRectBottom > activeRectTop) {
            if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
              return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return LARGE_DISTANCE_FROM_CENTER;
          }
          if (targetTop === -1 && targetRectBottom <= activeRectTop || targetRectTop === targetTop) {
            targetTop = targetRectTop;
            if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
              distance = 0;
            } else {
              distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
            }
          }
          return distance;
        })
      ) {
        this._setFocusAlignment(this._activeElement, false, true);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusLeft = function(theme) {
      var _this = this;
      var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
      if (this._moveFocus(
        getRTL(theme),
        // eslint-disable-next-line deprecation/deprecation
        function(activeRect, targetRect) {
          var distance = -1;
          var topBottomComparison;
          if (getRTL(theme)) {
            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
          } else {
            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
          }
          if (topBottomComparison && targetRect.right <= activeRect.right && _this.props.direction !== FocusZoneDirection.vertical) {
            distance = activeRect.right - targetRect.right;
          } else if (!shouldWrap) {
            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
          }
          return distance;
        },
        void 0,
        shouldWrap
      )) {
        this._setFocusAlignment(this._activeElement, true, false);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusRight = function(theme) {
      var _this = this;
      var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
      if (this._moveFocus(
        !getRTL(theme),
        // eslint-disable-next-line deprecation/deprecation
        function(activeRect, targetRect) {
          var distance = -1;
          var topBottomComparison;
          if (getRTL(theme)) {
            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
          } else {
            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
          }
          if (topBottomComparison && targetRect.left >= activeRect.left && _this.props.direction !== FocusZoneDirection.vertical) {
            distance = targetRect.left - activeRect.left;
          } else if (!shouldWrap) {
            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
          }
          return distance;
        },
        void 0,
        shouldWrap
      )) {
        this._setFocusAlignment(this._activeElement, true, false);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusPaging = function(isForward, useDefaultWrap) {
      if (useDefaultWrap === void 0) {
        useDefaultWrap = true;
      }
      var element = this._activeElement;
      if (!element || !this._root.current) {
        return false;
      }
      if (this._isElementInput(element)) {
        if (!this._shouldInputLoseFocus(element, isForward)) {
          return false;
        }
      }
      var scrollableParent = findScrollableParent(element);
      if (!scrollableParent) {
        return false;
      }
      var candidateDistance = -1;
      var candidateElement = void 0;
      var targetTop = -1;
      var targetBottom = -1;
      var pagesize = scrollableParent.clientHeight;
      var activeRect = element.getBoundingClientRect();
      do {
        element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);
        if (element) {
          var targetRect = element.getBoundingClientRect();
          var targetRectTop = Math.floor(targetRect.top);
          var activeRectBottom = Math.floor(activeRect.bottom);
          var targetRectBottom = Math.floor(targetRect.bottom);
          var activeRectTop = Math.floor(activeRect.top);
          var elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);
          var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;
          var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;
          if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {
            break;
          }
          if (elementDistance > -1) {
            if (isForward && targetRectTop > targetTop) {
              targetTop = targetRectTop;
              candidateDistance = elementDistance;
              candidateElement = element;
            } else if (!isForward && targetRectBottom < targetBottom) {
              targetBottom = targetRectBottom;
              candidateDistance = elementDistance;
              candidateElement = element;
            } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {
              candidateDistance = elementDistance;
              candidateElement = element;
            }
          }
        }
      } while (element);
      var changedFocus = false;
      if (candidateElement && candidateElement !== this._activeElement) {
        changedFocus = true;
        this.focusElement(candidateElement);
        this._setFocusAlignment(candidateElement, false, true);
      } else if (this.props.isCircularNavigation && useDefaultWrap) {
        if (isForward) {
          return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
        }
        return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
      }
      return changedFocus;
    };
    FocusZone2.prototype._setFocusAlignment = function(element, isHorizontal, isVertical) {
      if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {
        var rect = element.getBoundingClientRect();
        var left = rect.left + rect.width / 2;
        var top_1 = rect.top + rect.height / 2;
        if (!this._focusAlignment) {
          this._focusAlignment = { left, top: top_1 };
        }
        if (isHorizontal) {
          this._focusAlignment.left = left;
        }
        if (isVertical) {
          this._focusAlignment.top = top_1;
        }
      }
    };
    FocusZone2.prototype._isImmediateDescendantOfZone = function(element) {
      return this._getOwnerZone(element) === this._root.current;
    };
    FocusZone2.prototype._getOwnerZone = function(element) {
      var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS);
      while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {
        if (isElementFocusZone(parentElement)) {
          return parentElement;
        }
        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
      }
      return parentElement;
    };
    FocusZone2.prototype._updateTabIndexes = function(element) {
      if (!this._activeElement && this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === "function") {
        this._activeElement = this.props.defaultTabbableElement(this._root.current);
      }
      if (!element && this._root.current) {
        this._defaultFocusElement = null;
        element = this._root.current;
        if (this._activeElement && !elementContains(element, this._activeElement)) {
          this._activeElement = null;
        }
      }
      if (this._activeElement && !isElementTabbable(this._activeElement)) {
        this._activeElement = null;
      }
      var childNodes = element && element.children;
      for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
        var child = childNodes[childIndex];
        if (!isElementFocusZone(child)) {
          if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "false") {
            child.setAttribute(TABINDEX, "-1");
          }
          if (isElementTabbable(child)) {
            if (this.props.disabled) {
              child.setAttribute(TABINDEX, "-1");
            } else if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
              this._defaultFocusElement = child;
              if (child.getAttribute(TABINDEX) !== "0") {
                child.setAttribute(TABINDEX, "0");
              }
            } else if (child.getAttribute(TABINDEX) !== "-1") {
              child.setAttribute(TABINDEX, "-1");
            }
          } else if (child.tagName === "svg" && child.getAttribute("focusable") !== "false") {
            child.setAttribute("focusable", "false");
          }
        } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true") {
          if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
            this._defaultFocusElement = child;
            if (child.getAttribute(TABINDEX) !== "0") {
              child.setAttribute(TABINDEX, "0");
            }
          } else if (child.getAttribute(TABINDEX) !== "-1") {
            child.setAttribute(TABINDEX, "-1");
          }
        }
        this._updateTabIndexes(child);
      }
    };
    FocusZone2.prototype._isContentEditableElement = function(element) {
      return element && element.getAttribute("contenteditable") === "true";
    };
    FocusZone2.prototype._isElementInput = function(element) {
      if (element && element.tagName && (element.tagName.toLowerCase() === "input" || element.tagName.toLowerCase() === "textarea")) {
        return true;
      }
      return false;
    };
    FocusZone2.prototype._shouldInputLoseFocus = function(element, isForward) {
      if (!this._processingTabKey && element && element.type && ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {
        var selectionStart = element.selectionStart;
        var selectionEnd = element.selectionEnd;
        var isRangeSelected = selectionStart !== selectionEnd;
        var inputValue = element.value;
        var isReadonly = element.readOnly;
        if (isRangeSelected || selectionStart > 0 && !isForward && !isReadonly || selectionStart !== inputValue.length && isForward && !isReadonly || !!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element))) {
          return false;
        }
      }
      return true;
    };
    FocusZone2.prototype._shouldWrapFocus = function(element, noWrapDataAttribute) {
      return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;
    };
    FocusZone2.prototype._portalContainsElement = function(element) {
      return element && !!this._root.current && portalContainsElement(element, this._root.current);
    };
    FocusZone2.prototype._getDocument = function() {
      return getDocument(this._root.current);
    };
    FocusZone2.defaultProps = {
      isCircularNavigation: false,
      direction: FocusZoneDirection.bidirectional,
      shouldRaiseClicks: true
    };
    return FocusZone2;
  }(React14.Component)
);

// node_modules/@fluentui/react/lib/utilities/contextualMenu/contextualMenuUtility.js
function getIsChecked(item) {
  if (item.canCheck) {
    return !!(item.isChecked || item.checked);
  }
  if (typeof item.isChecked === "boolean") {
    return item.isChecked;
  }
  if (typeof item.checked === "boolean") {
    return item.checked;
  }
  return null;
}
function hasSubmenu(item) {
  return !!(item.subMenuProps || item.items);
}
function isItemDisabled(item) {
  return !!(item.isDisabled || item.disabled);
}
function getMenuItemAriaRole(item) {
  var isChecked = getIsChecked(item);
  var canCheck = isChecked !== null;
  return canCheck ? "menuitemcheckbox" : "menuitem";
}

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItem.base.js
var React15 = __toESM(require_react());
var defaultIconRenderer = function(props) {
  var item = props.item, classNames2 = props.classNames;
  var iconProps = item.iconProps;
  return React15.createElement(Icon, __assign({}, iconProps, { className: classNames2.icon }));
};
var renderItemIcon = function(props) {
  var item = props.item, hasIcons = props.hasIcons;
  if (!hasIcons) {
    return null;
  }
  if (item.onRenderIcon) {
    return item.onRenderIcon(props, defaultIconRenderer);
  }
  return defaultIconRenderer(props);
};
var renderCheckMarkIcon = function(_a5) {
  var onCheckmarkClick = _a5.onCheckmarkClick, item = _a5.item, classNames2 = _a5.classNames;
  var isItemChecked = getIsChecked(item);
  if (onCheckmarkClick) {
    var onClick = function(e) {
      return onCheckmarkClick(item, e);
    };
    return React15.createElement(Icon, {
      iconName: item.canCheck !== false && isItemChecked ? "CheckMark" : "",
      className: classNames2.checkmarkIcon,
      // eslint-disable-next-line react/jsx-no-bind
      onClick
    });
  }
  return null;
};
var renderItemName = function(_a5) {
  var item = _a5.item, classNames2 = _a5.classNames;
  if (item.text || item.name) {
    return React15.createElement("span", { className: classNames2.label }, item.text || item.name);
  }
  return null;
};
var renderSecondaryText = function(_a5) {
  var item = _a5.item, classNames2 = _a5.classNames;
  if (item.secondaryText) {
    return React15.createElement("span", { className: classNames2.secondaryText }, item.secondaryText);
  }
  return null;
};
var renderSubMenuIcon = function(_a5) {
  var item = _a5.item, classNames2 = _a5.classNames, theme = _a5.theme;
  if (hasSubmenu(item)) {
    return React15.createElement(Icon, __assign({ iconName: getRTL(theme) ? "ChevronLeft" : "ChevronRight" }, item.submenuIconProps, { className: classNames2.subMenuIcon }));
  }
  return null;
};
var ContextualMenuItemBase = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuItemBase2, _super);
    function ContextualMenuItemBase2(props) {
      var _this = _super.call(this, props) || this;
      _this.openSubMenu = function() {
        var _a5 = _this.props, item = _a5.item, openSubMenu = _a5.openSubMenu, getSubmenuTarget = _a5.getSubmenuTarget;
        if (getSubmenuTarget) {
          var submenuTarget = getSubmenuTarget();
          if (hasSubmenu(item) && openSubMenu && submenuTarget) {
            openSubMenu(item, submenuTarget);
          }
        }
      };
      _this.dismissSubMenu = function() {
        var _a5 = _this.props, item = _a5.item, dismissSubMenu = _a5.dismissSubMenu;
        if (hasSubmenu(item) && dismissSubMenu) {
          dismissSubMenu();
        }
      };
      _this.dismissMenu = function(dismissAll) {
        var dismissMenu = _this.props.dismissMenu;
        if (dismissMenu) {
          dismissMenu(void 0, dismissAll);
        }
      };
      initializeComponentRef(_this);
      return _this;
    }
    ContextualMenuItemBase2.prototype.render = function() {
      var _a5 = this.props, item = _a5.item, classNames2 = _a5.classNames;
      var renderContent = item.onRenderContent || this._renderLayout;
      return React15.createElement("div", { className: item.split ? classNames2.linkContentMenu : classNames2.linkContent }, renderContent(this.props, {
        renderCheckMarkIcon,
        renderItemIcon,
        renderItemName,
        renderSecondaryText,
        renderSubMenuIcon
      }));
    };
    ContextualMenuItemBase2.prototype._renderLayout = function(props, defaultRenders) {
      return React15.createElement(
        React15.Fragment,
        null,
        defaultRenders.renderCheckMarkIcon(props),
        defaultRenders.renderItemIcon(props),
        defaultRenders.renderItemName(props),
        defaultRenders.renderSecondaryText(props),
        defaultRenders.renderSubMenuIcon(props)
      );
    };
    return ContextualMenuItemBase2;
  }(React15.Component)
);

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.classNames.js
var getDividerClassNames = memoizeFunction(
  // eslint-disable-next-line deprecation/deprecation
  function(theme) {
    return mergeStyleSets({
      wrapper: {
        display: "inline-flex",
        height: "100%",
        alignItems: "center"
      },
      divider: {
        width: 1,
        height: "100%",
        backgroundColor: theme.palette.neutralTertiaryAlt
      }
    });
  }
);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.cnstyles.js
var CONTEXTUAL_MENU_ITEM_HEIGHT = 36;
var MediumScreenSelector = getScreenSelector(0, ScreenWidthMaxMedium);
var getMenuItemStyles = memoizeFunction(function(theme) {
  var _a5, _b3, _c3, _d3, _e2;
  var semanticColors = theme.semanticColors, fonts = theme.fonts, palette = theme.palette;
  var ContextualMenuItemBackgroundHoverColor = semanticColors.menuItemBackgroundHovered;
  var ContextualMenuItemTextHoverColor = semanticColors.menuItemTextHovered;
  var ContextualMenuItemBackgroundSelectedColor = semanticColors.menuItemBackgroundPressed;
  var ContextualMenuItemDividerColor = semanticColors.bodyDivider;
  var menuItemStyles = {
    item: [
      fonts.medium,
      {
        color: semanticColors.bodyText,
        position: "relative",
        boxSizing: "border-box"
      }
    ],
    divider: {
      display: "block",
      height: "1px",
      backgroundColor: ContextualMenuItemDividerColor,
      position: "relative"
    },
    root: [
      getFocusStyle(theme),
      fonts.medium,
      {
        color: semanticColors.bodyText,
        backgroundColor: "transparent",
        border: "none",
        width: "100%",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
        display: "block",
        cursor: "pointer",
        padding: "0px 8px 0 4px",
        textAlign: "left"
      }
    ],
    rootDisabled: {
      color: semanticColors.disabledBodyText,
      cursor: "default",
      pointerEvents: "none",
      selectors: (_a5 = {}, _a5[HighContrastSelector] = {
        // ensure disabled text looks different than enabled
        color: "GrayText",
        opacity: 1
      }, _a5)
    },
    rootHovered: {
      backgroundColor: ContextualMenuItemBackgroundHoverColor,
      color: ContextualMenuItemTextHoverColor,
      selectors: {
        ".ms-ContextualMenu-icon": {
          color: palette.themeDarkAlt
        },
        ".ms-ContextualMenu-submenuIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootFocused: {
      backgroundColor: palette.white
    },
    rootChecked: {
      selectors: {
        ".ms-ContextualMenu-checkmarkIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootPressed: {
      backgroundColor: ContextualMenuItemBackgroundSelectedColor,
      selectors: {
        ".ms-ContextualMenu-icon": {
          color: palette.themeDark
        },
        ".ms-ContextualMenu-submenuIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootExpanded: {
      backgroundColor: ContextualMenuItemBackgroundSelectedColor,
      color: semanticColors.bodyTextChecked,
      selectors: (_b3 = {
        ".ms-ContextualMenu-submenuIcon": (_c3 = {}, _c3[HighContrastSelector] = {
          // icons inside of anchor tags are not properly inheriting color in high contrast
          color: "inherit"
        }, _c3)
      }, _b3[HighContrastSelector] = __assign({}, getHighContrastNoAdjustStyle()), _b3)
    },
    linkContent: {
      whiteSpace: "nowrap",
      height: "inherit",
      display: "flex",
      alignItems: "center",
      maxWidth: "100%"
    },
    anchorLink: {
      padding: "0px 8px 0 4px",
      textRendering: "auto",
      color: "inherit",
      letterSpacing: "normal",
      wordSpacing: "normal",
      textTransform: "none",
      textIndent: "0px",
      textShadow: "none",
      textDecoration: "none",
      boxSizing: "border-box"
    },
    label: {
      margin: "0 4px",
      verticalAlign: "middle",
      display: "inline-block",
      flexGrow: "1",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden"
    },
    secondaryText: {
      color: theme.palette.neutralSecondary,
      paddingLeft: "20px",
      textAlign: "right"
    },
    icon: {
      display: "inline-block",
      minHeight: "1px",
      maxHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
      fontSize: IconFontSizes.medium,
      width: IconFontSizes.medium,
      margin: "0 4px",
      verticalAlign: "middle",
      flexShrink: "0",
      selectors: (_d3 = {}, _d3[MediumScreenSelector] = {
        fontSize: IconFontSizes.large,
        width: IconFontSizes.large
      }, _d3)
    },
    iconColor: {
      color: semanticColors.menuIcon
    },
    iconDisabled: {
      color: semanticColors.disabledBodyText
    },
    checkmarkIcon: {
      color: semanticColors.bodySubtext
    },
    subMenuIcon: {
      height: CONTEXTUAL_MENU_ITEM_HEIGHT,
      lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
      color: palette.neutralSecondary,
      textAlign: "center",
      display: "inline-block",
      verticalAlign: "middle",
      flexShrink: "0",
      fontSize: IconFontSizes.small,
      selectors: (_e2 = {
        ":hover": {
          color: palette.neutralPrimary
        },
        ":active": {
          color: palette.neutralPrimary
        }
      }, _e2[MediumScreenSelector] = {
        fontSize: IconFontSizes.medium
        // 16px
      }, _e2)
    },
    splitButtonFlexContainer: [
      getFocusStyle(theme),
      {
        display: "flex",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        flexWrap: "nowrap",
        justifyContent: "center",
        alignItems: "flex-start"
      }
    ]
  };
  return concatStyleSets(menuItemStyles);
});

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.classNames.js
var CONTEXTUAL_SPLIT_MENU_MINWIDTH = "28px";
var MediumScreenSelector2 = getScreenSelector(0, ScreenWidthMaxMedium);
var getSplitButtonVerticalDividerClassNames = memoizeFunction(
  /* eslint-disable deprecation/deprecation */
  function(theme) {
    var _a5;
    return mergeStyleSets(getDividerClassNames(theme), {
      /* eslint-enable deprecation/deprecation */
      wrapper: {
        position: "absolute",
        right: 28,
        selectors: (_a5 = {}, _a5[MediumScreenSelector2] = {
          right: 32
          // fontSize of the icon increased from 12px to 16px
        }, _a5)
      },
      divider: {
        height: 16,
        width: 1
      }
    });
  }
);
var GlobalClassNames5 = {
  item: "ms-ContextualMenu-item",
  divider: "ms-ContextualMenu-divider",
  root: "ms-ContextualMenu-link",
  isChecked: "is-checked",
  isExpanded: "is-expanded",
  isDisabled: "is-disabled",
  linkContent: "ms-ContextualMenu-linkContent",
  linkContentMenu: "ms-ContextualMenu-linkContent",
  icon: "ms-ContextualMenu-icon",
  iconColor: "ms-ContextualMenu-iconColor",
  checkmarkIcon: "ms-ContextualMenu-checkmarkIcon",
  subMenuIcon: "ms-ContextualMenu-submenuIcon",
  label: "ms-ContextualMenu-itemText",
  secondaryText: "ms-ContextualMenu-secondaryText",
  splitMenu: "ms-ContextualMenu-splitMenu",
  screenReaderText: "ms-ContextualMenu-screenReaderText"
};
var getItemClassNames = memoizeFunction(function(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className) {
  var _a5, _b3, _c3, _d3;
  var styles = getMenuItemStyles(theme);
  var classNames2 = getGlobalClassNames(GlobalClassNames5, theme);
  return mergeStyleSets({
    item: [classNames2.item, styles.item, itemClassName],
    divider: [classNames2.divider, styles.divider, dividerClassName],
    root: [
      classNames2.root,
      styles.root,
      checked && [classNames2.isChecked, styles.rootChecked],
      isAnchorLink && styles.anchorLink,
      expanded && [classNames2.isExpanded, styles.rootExpanded],
      disabled && [classNames2.isDisabled, styles.rootDisabled],
      !disabled && !expanded && [
        {
          selectors: (_a5 = {
            ":hover": styles.rootHovered,
            ":active": styles.rootPressed
          }, _a5[".".concat(IsFocusVisibleClassName, " &:focus, .").concat(IsFocusVisibleClassName, " &:focus:hover")] = styles.rootFocused, _a5[".".concat(IsFocusVisibleClassName, " &:hover")] = { background: "inherit;" }, _a5)
        }
      ],
      className
    ],
    splitPrimary: [
      styles.root,
      {
        width: "calc(100% - ".concat(CONTEXTUAL_SPLIT_MENU_MINWIDTH, ")")
      },
      checked && ["is-checked", styles.rootChecked],
      (disabled || primaryDisabled) && ["is-disabled", styles.rootDisabled],
      !(disabled || primaryDisabled) && !checked && [
        {
          selectors: (_b3 = {
            ":hover": styles.rootHovered
          }, // when hovering over the splitPrimary also affect the splitMenu
          _b3[":hover ~ .".concat(classNames2.splitMenu)] = styles.rootHovered, _b3[":active"] = styles.rootPressed, _b3[".".concat(IsFocusVisibleClassName, " &:focus, .").concat(IsFocusVisibleClassName, " &:focus:hover")] = styles.rootFocused, _b3[".".concat(IsFocusVisibleClassName, " &:hover")] = { background: "inherit;" }, _b3)
        }
      ]
    ],
    splitMenu: [
      classNames2.splitMenu,
      styles.root,
      {
        flexBasis: "0",
        padding: "0 8px",
        minWidth: CONTEXTUAL_SPLIT_MENU_MINWIDTH
      },
      expanded && ["is-expanded", styles.rootExpanded],
      disabled && ["is-disabled", styles.rootDisabled],
      !disabled && !expanded && [
        {
          selectors: (_c3 = {
            ":hover": styles.rootHovered,
            ":active": styles.rootPressed
          }, _c3[".".concat(IsFocusVisibleClassName, " &:focus, .").concat(IsFocusVisibleClassName, " &:focus:hover")] = styles.rootFocused, _c3[".".concat(IsFocusVisibleClassName, " &:hover")] = { background: "inherit;" }, _c3)
        }
      ]
    ],
    anchorLink: styles.anchorLink,
    linkContent: [classNames2.linkContent, styles.linkContent],
    linkContentMenu: [
      classNames2.linkContentMenu,
      styles.linkContent,
      {
        justifyContent: "center"
      }
    ],
    icon: [
      classNames2.icon,
      knownIcon && styles.iconColor,
      styles.icon,
      iconClassName,
      disabled && [classNames2.isDisabled, styles.iconDisabled]
    ],
    iconColor: styles.iconColor,
    checkmarkIcon: [classNames2.checkmarkIcon, knownIcon && styles.checkmarkIcon, styles.icon, iconClassName],
    subMenuIcon: [
      classNames2.subMenuIcon,
      styles.subMenuIcon,
      subMenuClassName,
      expanded && { color: theme.palette.neutralPrimary },
      disabled && [styles.iconDisabled]
    ],
    label: [classNames2.label, styles.label],
    secondaryText: [classNames2.secondaryText, styles.secondaryText],
    splitContainer: [
      styles.splitButtonFlexContainer,
      !disabled && !checked && [
        {
          selectors: (_d3 = {}, _d3[".".concat(IsFocusVisibleClassName, " &:focus, .").concat(IsFocusVisibleClassName, " &:focus:hover")] = styles.rootFocused, _d3)
        }
      ]
    ],
    screenReaderText: [
      classNames2.screenReaderText,
      styles.screenReaderText,
      hiddenContentStyle,
      { visibility: "hidden" }
    ]
  });
});
var getItemStyles = function(props) {
  var theme = props.theme, disabled = props.disabled, expanded = props.expanded, checked = props.checked, isAnchorLink = props.isAnchorLink, knownIcon = props.knownIcon, itemClassName = props.itemClassName, dividerClassName = props.dividerClassName, iconClassName = props.iconClassName, subMenuClassName = props.subMenuClassName, primaryDisabled = props.primaryDisabled, className = props.className;
  return getItemClassNames(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className);
};

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItem.js
var ContextualMenuItem = styled(ContextualMenuItemBase, getItemStyles, void 0, { scope: "ContextualMenuItem" });

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuAnchor.js
var React19 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuItemWrapper.js
var React16 = __toESM(require_react());
var ContextualMenuItemWrapper = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuItemWrapper2, _super);
    function ContextualMenuItemWrapper2(props) {
      var _this = _super.call(this, props) || this;
      _this._onItemMouseEnter = function(ev) {
        var _a5 = _this.props, item = _a5.item, onItemMouseEnter = _a5.onItemMouseEnter;
        if (onItemMouseEnter) {
          onItemMouseEnter(item, ev, ev.currentTarget);
        }
      };
      _this._onItemClick = function(ev) {
        var _a5 = _this.props, item = _a5.item, onItemClickBase = _a5.onItemClickBase;
        if (onItemClickBase) {
          onItemClickBase(item, ev, ev.currentTarget);
        }
      };
      _this._onItemMouseLeave = function(ev) {
        var _a5 = _this.props, item = _a5.item, onItemMouseLeave = _a5.onItemMouseLeave;
        if (onItemMouseLeave) {
          onItemMouseLeave(item, ev);
        }
      };
      _this._onItemKeyDown = function(ev) {
        var _a5 = _this.props, item = _a5.item, onItemKeyDown = _a5.onItemKeyDown;
        if (onItemKeyDown) {
          onItemKeyDown(item, ev);
        }
      };
      _this._onItemMouseMove = function(ev) {
        var _a5 = _this.props, item = _a5.item, onItemMouseMove = _a5.onItemMouseMove;
        if (onItemMouseMove) {
          onItemMouseMove(item, ev, ev.currentTarget);
        }
      };
      _this._getSubmenuTarget = function() {
        return void 0;
      };
      initializeComponentRef(_this);
      return _this;
    }
    ContextualMenuItemWrapper2.prototype.shouldComponentUpdate = function(newProps) {
      return !shallowCompare(newProps, this.props);
    };
    return ContextualMenuItemWrapper2;
  }(React16.Component)
);

// node_modules/@fluentui/react/lib/utilities/keytips/IKeytipTransitionKey.js
function transitionKeysAreEqual(key1, key2) {
  if (key1.key !== key2.key) {
    return false;
  }
  var mod1 = key1.modifierKeys;
  var mod2 = key2.modifierKeys;
  if (!mod1 && mod2 || mod1 && !mod2) {
    return false;
  }
  if (mod1 && mod2) {
    if (mod1.length !== mod2.length) {
      return false;
    }
    mod1 = mod1.sort();
    mod2 = mod2.sort();
    for (var i = 0; i < mod1.length; i++) {
      if (mod1[i] !== mod2[i]) {
        return false;
      }
    }
  }
  return true;
}
function transitionKeysContain(keys, key) {
  return !!find(keys, function(transitionKey) {
    return transitionKeysAreEqual(transitionKey, key);
  });
}

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipConfig.js
function buildKeytipConfigMap(config) {
  var configMap = {};
  for (var _i = 0, _a5 = config.keytips; _i < _a5.length; _i++) {
    var keytip = _a5[_i];
    constructKeytip(configMap, [], keytip);
  }
  return configMap;
}
function constructKeytip(configMap, parentSequence, keytip) {
  var sequence = keytip.sequence ? keytip.sequence : keytip.content.toLocaleLowerCase();
  var keytipSequence = parentSequence.concat(sequence);
  var keytipProps = __assign(__assign({}, keytip.optionalProps), { keySequences: keytipSequence, content: keytip.content });
  configMap[keytip.id] = keytipProps;
  if (keytip.children) {
    for (var _i = 0, _a5 = keytip.children; _i < _a5.length; _i++) {
      var child = _a5[_i];
      constructKeytip(configMap, keytipSequence, child);
    }
  }
}

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipConstants.js
var KTP_PREFIX = "ktp";
var KTP_SEPARATOR = "-";
var KTP_FULL_PREFIX = KTP_PREFIX + KTP_SEPARATOR;
var DATAKTP_TARGET = "data-ktp-target";
var DATAKTP_EXECUTE_TARGET = "data-ktp-execute-target";
var DATAKTP_ARIA_TARGET = "data-ktp-aria-target";
var KTP_LAYER_ID = "ktp-layer-id";
var KTP_ARIA_SEPARATOR = ", ";
var KeytipEvents;
(function(KeytipEvents2) {
  KeytipEvents2.KEYTIP_ADDED = "keytipAdded";
  KeytipEvents2.KEYTIP_REMOVED = "keytipRemoved";
  KeytipEvents2.KEYTIP_UPDATED = "keytipUpdated";
  KeytipEvents2.PERSISTED_KEYTIP_ADDED = "persistedKeytipAdded";
  KeytipEvents2.PERSISTED_KEYTIP_REMOVED = "persistedKeytipRemoved";
  KeytipEvents2.PERSISTED_KEYTIP_EXECUTE = "persistedKeytipExecute";
  KeytipEvents2.ENTER_KEYTIP_MODE = "enterKeytipMode";
  KeytipEvents2.EXIT_KEYTIP_MODE = "exitKeytipMode";
})(KeytipEvents || (KeytipEvents = {}));

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipManager.js
var KeytipManager = (
  /** @class */
  function() {
    function KeytipManager2() {
      this.keytips = {};
      this.persistedKeytips = {};
      this.sequenceMapping = {};
      this.inKeytipMode = false;
      this.shouldEnterKeytipMode = true;
      this.delayUpdatingKeytipChange = false;
    }
    KeytipManager2.getInstance = function() {
      return this._instance;
    };
    KeytipManager2.prototype.init = function(delayUpdatingKeytipChange) {
      this.delayUpdatingKeytipChange = delayUpdatingKeytipChange;
    };
    KeytipManager2.prototype.register = function(keytipProps, persisted) {
      if (persisted === void 0) {
        persisted = false;
      }
      var props = keytipProps;
      if (!persisted) {
        props = this.addParentOverflow(keytipProps);
        this.sequenceMapping[props.keySequences.toString()] = props;
      }
      var uniqueKeytip = this._getUniqueKtp(props);
      persisted ? this.persistedKeytips[uniqueKeytip.uniqueID] = uniqueKeytip : this.keytips[uniqueKeytip.uniqueID] = uniqueKeytip;
      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
        var event_1 = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;
        EventGroup.raise(this, event_1, {
          keytip: props,
          uniqueID: uniqueKeytip.uniqueID
        });
      }
      return uniqueKeytip.uniqueID;
    };
    KeytipManager2.prototype.update = function(keytipProps, uniqueID) {
      var newKeytipProps = this.addParentOverflow(keytipProps);
      var uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);
      var oldKeyTip = this.keytips[uniqueID];
      if (oldKeyTip) {
        uniqueKeytip.keytip.visible = oldKeyTip.keytip.visible;
        this.keytips[uniqueID] = uniqueKeytip;
        delete this.sequenceMapping[oldKeyTip.keytip.keySequences.toString()];
        this.sequenceMapping[uniqueKeytip.keytip.keySequences.toString()] = uniqueKeytip.keytip;
        if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
          EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {
            keytip: uniqueKeytip.keytip,
            uniqueID: uniqueKeytip.uniqueID
          });
        }
      }
    };
    KeytipManager2.prototype.unregister = function(keytipToRemove, uniqueID, persisted) {
      if (persisted === void 0) {
        persisted = false;
      }
      persisted ? delete this.persistedKeytips[uniqueID] : delete this.keytips[uniqueID];
      !persisted && delete this.sequenceMapping[keytipToRemove.keySequences.toString()];
      var event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;
      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
        EventGroup.raise(this, event, {
          keytip: keytipToRemove,
          uniqueID
        });
      }
    };
    KeytipManager2.prototype.enterKeytipMode = function() {
      EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);
    };
    KeytipManager2.prototype.exitKeytipMode = function() {
      EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);
    };
    KeytipManager2.prototype.getKeytips = function() {
      var _this = this;
      return Object.keys(this.keytips).map(function(key) {
        return _this.keytips[key].keytip;
      });
    };
    KeytipManager2.prototype.addParentOverflow = function(keytipProps) {
      var fullSequence = __spreadArray([], keytipProps.keySequences, true);
      fullSequence.pop();
      if (fullSequence.length !== 0) {
        var parentKeytip = this.sequenceMapping[fullSequence.toString()];
        if (parentKeytip && parentKeytip.overflowSetSequence) {
          return __assign(__assign({}, keytipProps), { overflowSetSequence: parentKeytip.overflowSetSequence });
        }
      }
      return keytipProps;
    };
    KeytipManager2.prototype.menuExecute = function(overflowButtonSequences, keytipSequences) {
      EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {
        overflowButtonSequences,
        keytipSequences
      });
    };
    KeytipManager2.prototype._getUniqueKtp = function(keytipProps, uniqueID) {
      if (uniqueID === void 0) {
        uniqueID = getId();
      }
      return { keytip: __assign({}, keytipProps), uniqueID };
    };
    KeytipManager2._instance = new KeytipManager2();
    return KeytipManager2;
  }()
);

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipUtils.js
function sequencesToID(keySequences) {
  return keySequences.reduce(function(prevValue, keySequence) {
    return prevValue + KTP_SEPARATOR + keySequence.split("").join(KTP_SEPARATOR);
  }, KTP_PREFIX);
}
function mergeOverflows(keySequences, overflowKeySequences) {
  var overflowSequenceLen = overflowKeySequences.length;
  var overflowSequence = __spreadArray([], overflowKeySequences, true).pop();
  var newKeySequences = __spreadArray([], keySequences, true);
  return addElementAtIndex(newKeySequences, overflowSequenceLen - 1, overflowSequence);
}
function ktpTargetFromSequences(keySequences) {
  return "[" + DATAKTP_TARGET + '="' + sequencesToID(keySequences) + '"]';
}
function ktpTargetFromId(keytipId) {
  return "[" + DATAKTP_EXECUTE_TARGET + '="' + keytipId + '"]';
}
function getAriaDescribedBy(keySequences) {
  var describedby = " " + KTP_LAYER_ID;
  if (!keySequences.length) {
    return describedby;
  }
  return describedby + " " + sequencesToID(keySequences);
}

// node_modules/@fluentui/react/lib/components/KeytipData/useKeytipData.js
var React17 = __toESM(require_react());
function useKeytipData(options) {
  var uniqueId = React17.useRef();
  var keytipProps = options.keytipProps ? __assign({ disabled: options.disabled }, options.keytipProps) : void 0;
  var keytipManager = useConst(KeytipManager.getInstance());
  var prevOptions = usePrevious(options);
  useIsomorphicLayoutEffect(function() {
    if (uniqueId.current && keytipProps && ((prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.keytipProps) !== options.keytipProps || (prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.disabled) !== options.disabled)) {
      keytipManager.update(keytipProps, uniqueId.current);
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (keytipProps) {
      uniqueId.current = keytipManager.register(keytipProps);
    }
    return function() {
      keytipProps && keytipManager.unregister(keytipProps, uniqueId.current);
    };
  }, []);
  var nativeKeytipProps = {
    ariaDescribedBy: void 0,
    keytipId: void 0
  };
  if (keytipProps) {
    nativeKeytipProps = getKeytipData(keytipManager, keytipProps, options.ariaDescribedBy);
  }
  return nativeKeytipProps;
}
function getKeytipData(keytipManager, keytipProps, describedByPrepend) {
  var newKeytipProps = keytipManager.addParentOverflow(keytipProps);
  var ariaDescribedBy = mergeAriaAttributeValues(describedByPrepend, getAriaDescribedBy(newKeytipProps.keySequences));
  var keySequences = __spreadArray([], newKeytipProps.keySequences, true);
  if (newKeytipProps.overflowSetSequence) {
    keySequences = mergeOverflows(keySequences, newKeytipProps.overflowSetSequence);
  }
  var keytipId = sequencesToID(keySequences);
  return {
    ariaDescribedBy,
    keytipId
  };
}

// node_modules/@fluentui/react/lib/components/KeytipData/KeytipData.js
var KeytipData = function(props) {
  var _a5;
  var children = props.children, keytipDataProps = __rest(props, ["children"]);
  var _b3 = useKeytipData(keytipDataProps), keytipId = _b3.keytipId, ariaDescribedBy = _b3.ariaDescribedBy;
  return children((_a5 = {}, _a5[DATAKTP_TARGET] = keytipId, _a5[DATAKTP_EXECUTE_TARGET] = keytipId, _a5["aria-describedby"] = ariaDescribedBy, _a5));
};

// node_modules/@fluentui/react/lib/components/KeytipData/useKeytipRef.js
var React18 = __toESM(require_react());
function useKeytipRef(options) {
  var _a5 = useKeytipData(options), keytipId = _a5.keytipId, ariaDescribedBy = _a5.ariaDescribedBy;
  var contentRef = React18.useCallback(function(contentElement) {
    if (!contentElement) {
      return;
    }
    var targetElement = findFirstElement(contentElement, DATAKTP_TARGET) || contentElement;
    var executeElement = findFirstElement(contentElement, DATAKTP_EXECUTE_TARGET) || targetElement;
    var ariaElement = findFirstElement(contentElement, DATAKTP_ARIA_TARGET) || executeElement;
    setAttribute(targetElement, DATAKTP_TARGET, keytipId);
    setAttribute(executeElement, DATAKTP_EXECUTE_TARGET, keytipId);
    setAttribute(ariaElement, "aria-describedby", ariaDescribedBy, true);
  }, [keytipId, ariaDescribedBy]);
  return contentRef;
}
function setAttribute(element, attributeName, attributeValue, append) {
  if (append === void 0) {
    append = false;
  }
  if (element && attributeValue) {
    var value = attributeValue;
    if (append) {
      var currentValue = element.getAttribute(attributeName);
      if (currentValue && currentValue.indexOf(attributeValue) === -1) {
        value = "".concat(currentValue, " ").concat(attributeValue);
      }
    }
    element.setAttribute(attributeName, value);
  }
}
function findFirstElement(rootElement, dataAttribute) {
  return rootElement.querySelector("[".concat(dataAttribute, "]"));
}

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuAnchor.js
var ContextualMenuAnchor = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuAnchor2, _super);
    function ContextualMenuAnchor2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._anchor = React19.createRef();
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign(__assign({}, keytipProps), { hasMenu: true });
      });
      _this._getSubmenuTarget = function() {
        return _this._anchor.current ? _this._anchor.current : void 0;
      };
      _this._onItemClick = function(ev) {
        var _a5 = _this.props, item = _a5.item, onItemClick = _a5.onItemClick;
        if (onItemClick) {
          onItemClick(item, ev);
        }
      };
      _this._renderAriaDescription = function(ariaDescription, className) {
        return ariaDescription ? React19.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
      };
      return _this;
    }
    ContextualMenuAnchor2.prototype.render = function() {
      var _this = this;
      var _a5 = this.props, item = _a5.item, classNames2 = _a5.classNames, index = _a5.index, focusableElementIndex = _a5.focusableElementIndex, totalItemCount = _a5.totalItemCount, hasCheckmarks = _a5.hasCheckmarks, hasIcons = _a5.hasIcons, _b3 = _a5.contextualMenuItemAs, ChildrenRenderer = _b3 === void 0 ? ContextualMenuItem : _b3, expandedMenuItemKey = _a5.expandedMenuItemKey, onItemClick = _a5.onItemClick, openSubMenu = _a5.openSubMenu, dismissSubMenu = _a5.dismissSubMenu, dismissMenu = _a5.dismissMenu;
      var anchorRel = item.rel;
      if (item.target && item.target.toLowerCase() === "_blank") {
        anchorRel = anchorRel ? anchorRel : "nofollow noopener noreferrer";
      }
      var itemHasSubmenu = hasSubmenu(item);
      var nativeProps = getNativeProps(item, anchorProperties);
      var disabled = isItemDisabled(item);
      var itemProps = item.itemProps, ariaDescription = item.ariaDescription;
      var keytipProps = item.keytipProps;
      if (keytipProps && itemHasSubmenu) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      if (ariaDescription) {
        this._ariaDescriptionId = getId();
      }
      var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : void 0, nativeProps["aria-describedby"]);
      var additionalItemProperties = {
        "aria-describedby": ariaDescribedByIds
      };
      return React19.createElement(
        "div",
        null,
        React19.createElement(KeytipData, { keytipProps: item.keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled }, function(keytipAttributes) {
          return React19.createElement(
            "a",
            __assign({}, additionalItemProperties, nativeProps, keytipAttributes, {
              ref: _this._anchor,
              href: item.href,
              target: item.target,
              rel: anchorRel,
              className: classNames2.root,
              role: "menuitem",
              "aria-haspopup": itemHasSubmenu || void 0,
              "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0,
              "aria-posinset": focusableElementIndex + 1,
              "aria-setsize": totalItemCount,
              "aria-disabled": isItemDisabled(item),
              // eslint-disable-next-line deprecation/deprecation
              style: item.style,
              onClick: _this._onItemClick,
              onMouseEnter: _this._onItemMouseEnter,
              onMouseLeave: _this._onItemMouseLeave,
              onMouseMove: _this._onItemMouseMove,
              onKeyDown: itemHasSubmenu ? _this._onItemKeyDown : void 0
            }),
            React19.createElement(ChildrenRenderer, __assign({ componentRef: item.componentRef, item, classNames: classNames2, index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
            _this._renderAriaDescription(ariaDescription, classNames2.screenReaderText)
          );
        })
      );
    };
    return ContextualMenuAnchor2;
  }(ContextualMenuItemWrapper)
);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuButton.js
var React20 = __toESM(require_react());
var ContextualMenuButton = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuButton2, _super);
    function ContextualMenuButton2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._btn = React20.createRef();
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign(__assign({}, keytipProps), { hasMenu: true });
      });
      _this._renderAriaDescription = function(ariaDescription, className) {
        return ariaDescription ? React20.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
      };
      _this._getSubmenuTarget = function() {
        return _this._btn.current ? _this._btn.current : void 0;
      };
      return _this;
    }
    ContextualMenuButton2.prototype.render = function() {
      var _this = this;
      var _a5 = this.props, item = _a5.item, classNames2 = _a5.classNames, index = _a5.index, focusableElementIndex = _a5.focusableElementIndex, totalItemCount = _a5.totalItemCount, hasCheckmarks = _a5.hasCheckmarks, hasIcons = _a5.hasIcons, _b3 = _a5.contextualMenuItemAs, ChildrenRenderer = _b3 === void 0 ? ContextualMenuItem : _b3, expandedMenuItemKey = _a5.expandedMenuItemKey, onItemMouseDown2 = _a5.onItemMouseDown, onItemClick = _a5.onItemClick, openSubMenu = _a5.openSubMenu, dismissSubMenu = _a5.dismissSubMenu, dismissMenu = _a5.dismissMenu;
      var isChecked = getIsChecked(item);
      var canCheck = isChecked !== null;
      var defaultRole = getMenuItemAriaRole(item);
      var itemHasSubmenu = hasSubmenu(item);
      var itemProps = item.itemProps, ariaLabel = item.ariaLabel, ariaDescription = item.ariaDescription;
      var buttonNativeProperties = getNativeProps(item, buttonProperties);
      delete buttonNativeProperties.disabled;
      var itemRole = item.role || defaultRole;
      if (ariaDescription) {
        this._ariaDescriptionId = getId();
      }
      var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : void 0, buttonNativeProperties["aria-describedby"]);
      var itemButtonProperties = {
        className: classNames2.root,
        onClick: this._onItemClick,
        onKeyDown: itemHasSubmenu ? this._onItemKeyDown : void 0,
        onMouseEnter: this._onItemMouseEnter,
        onMouseLeave: this._onItemMouseLeave,
        onMouseDown: function(ev) {
          return onItemMouseDown2 ? onItemMouseDown2(item, ev) : void 0;
        },
        onMouseMove: this._onItemMouseMove,
        href: item.href,
        title: item.title,
        "aria-label": ariaLabel,
        "aria-describedby": ariaDescribedByIds,
        "aria-haspopup": itemHasSubmenu || void 0,
        "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0,
        "aria-posinset": focusableElementIndex + 1,
        "aria-setsize": totalItemCount,
        "aria-disabled": isItemDisabled(item),
        "aria-checked": (itemRole === "menuitemcheckbox" || itemRole === "menuitemradio") && canCheck ? !!isChecked : void 0,
        "aria-selected": itemRole === "menuitem" && canCheck ? !!isChecked : void 0,
        role: itemRole,
        // eslint-disable-next-line deprecation/deprecation
        style: item.style
      };
      var keytipProps = item.keytipProps;
      if (keytipProps && itemHasSubmenu) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      return React20.createElement(KeytipData, { keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled: isItemDisabled(item) }, function(keytipAttributes) {
        return React20.createElement(
          "button",
          __assign({ ref: _this._btn }, buttonNativeProperties, itemButtonProperties, keytipAttributes),
          React20.createElement(ChildrenRenderer, __assign({ componentRef: item.componentRef, item, classNames: classNames2, index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
          _this._renderAriaDescription(ariaDescription, classNames2.screenReaderText)
        );
      });
    };
    return ContextualMenuButton2;
  }(ContextualMenuItemWrapper)
);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuSplitButton.js
var React22 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.styles.js
var getStyles6 = function(props) {
  var theme = props.theme, getClassNames13 = props.getClassNames, className = props.className;
  if (!theme) {
    throw new Error("Theme is undefined or null.");
  }
  if (getClassNames13) {
    var names = getClassNames13(theme);
    return {
      wrapper: [names.wrapper],
      divider: [names.divider]
    };
  }
  return {
    wrapper: [
      {
        display: "inline-flex",
        height: "100%",
        alignItems: "center"
      },
      className
    ],
    divider: [
      {
        width: 1,
        height: "100%",
        backgroundColor: theme.palette.neutralTertiaryAlt
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.base.js
var React21 = __toESM(require_react());
var getClassNames6 = classNamesFunction();
var VerticalDividerBase = React21.forwardRef(function(props, ref) {
  var styles = props.styles, theme = props.theme, deprecatedGetClassNames = props.getClassNames, className = props.className;
  var classNames2 = getClassNames6(styles, { theme, getClassNames: deprecatedGetClassNames, className });
  return React21.createElement(
    "span",
    { className: classNames2.wrapper, ref },
    React21.createElement("span", { className: classNames2.divider })
  );
});
VerticalDividerBase.displayName = "VerticalDividerBase";

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.js
var VerticalDivider = styled(VerticalDividerBase, getStyles6, void 0, {
  scope: "VerticalDivider"
});

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuSplitButton.js
var TouchIdleDelay = 500;
var ContextualMenuSplitButton = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuSplitButton2, _super);
    function ContextualMenuSplitButton2(props) {
      var _this = _super.call(this, props) || this;
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign(__assign({}, keytipProps), { hasMenu: true });
      });
      _this._onItemKeyDown = function(ev) {
        var _a5 = _this.props, item = _a5.item, onItemKeyDown = _a5.onItemKeyDown;
        if (ev.which === KeyCodes.enter) {
          _this._executeItemClick(ev);
          ev.preventDefault();
          ev.stopPropagation();
        } else if (onItemKeyDown) {
          onItemKeyDown(item, ev);
        }
      };
      _this._getSubmenuTarget = function() {
        return _this._splitButton;
      };
      _this._renderAriaDescription = function(ariaDescription, className) {
        return ariaDescription ? React22.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
      };
      _this._onItemMouseEnterPrimary = function(ev) {
        var _a5 = _this.props, item = _a5.item, onItemMouseEnter = _a5.onItemMouseEnter;
        if (onItemMouseEnter) {
          onItemMouseEnter(__assign(__assign({}, item), { subMenuProps: void 0, items: void 0 }), ev, _this._splitButton);
        }
      };
      _this._onItemMouseEnterIcon = function(ev) {
        var _a5 = _this.props, item = _a5.item, onItemMouseEnter = _a5.onItemMouseEnter;
        if (onItemMouseEnter) {
          onItemMouseEnter(item, ev, _this._splitButton);
        }
      };
      _this._onItemMouseMovePrimary = function(ev) {
        var _a5 = _this.props, item = _a5.item, onItemMouseMove = _a5.onItemMouseMove;
        if (onItemMouseMove) {
          onItemMouseMove(__assign(__assign({}, item), { subMenuProps: void 0, items: void 0 }), ev, _this._splitButton);
        }
      };
      _this._onItemMouseMoveIcon = function(ev) {
        var _a5 = _this.props, item = _a5.item, onItemMouseMove = _a5.onItemMouseMove;
        if (onItemMouseMove) {
          onItemMouseMove(item, ev, _this._splitButton);
        }
      };
      _this._onIconItemClick = function(ev) {
        var _a5 = _this.props, item = _a5.item, onItemClickBase = _a5.onItemClickBase;
        if (onItemClickBase) {
          onItemClickBase(item, ev, _this._splitButton ? _this._splitButton : ev.currentTarget);
        }
      };
      _this._executeItemClick = function(ev) {
        var _a5 = _this.props, item = _a5.item, executeItemClick = _a5.executeItemClick, onItemClick = _a5.onItemClick;
        if (item.disabled || item.isDisabled) {
          return;
        }
        if (_this._processingTouch && onItemClick) {
          return onItemClick(item, ev);
        }
        if (executeItemClick) {
          executeItemClick(item, ev);
        }
      };
      _this._onTouchStart = function(ev) {
        if (_this._splitButton && !("onpointerdown" in _this._splitButton)) {
          _this._handleTouchAndPointerEvent(ev);
        }
      };
      _this._onPointerDown = function(ev) {
        if (ev.pointerType === "touch") {
          _this._handleTouchAndPointerEvent(ev);
          ev.preventDefault();
          ev.stopImmediatePropagation();
        }
      };
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      return _this;
    }
    ContextualMenuSplitButton2.prototype.componentDidMount = function() {
      if (this._splitButton && "onpointerdown" in this._splitButton) {
        this._events.on(this._splitButton, "pointerdown", this._onPointerDown, true);
      }
    };
    ContextualMenuSplitButton2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    ContextualMenuSplitButton2.prototype.render = function() {
      var _this = this;
      var _a5;
      var _b3 = this.props, item = _b3.item, classNames2 = _b3.classNames, index = _b3.index, focusableElementIndex = _b3.focusableElementIndex, totalItemCount = _b3.totalItemCount, hasCheckmarks = _b3.hasCheckmarks, hasIcons = _b3.hasIcons, onItemMouseLeave = _b3.onItemMouseLeave, expandedMenuItemKey = _b3.expandedMenuItemKey;
      var itemHasSubmenu = hasSubmenu(item);
      var keytipProps = item.keytipProps;
      if (keytipProps) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      var ariaDescription = item.ariaDescription;
      if (ariaDescription) {
        this._ariaDescriptionId = getId();
      }
      var ariaChecked = (_a5 = getIsChecked(item)) !== null && _a5 !== void 0 ? _a5 : void 0;
      return React22.createElement(KeytipData, { keytipProps, disabled: isItemDisabled(item) }, function(keytipAttributes) {
        return React22.createElement(
          "div",
          { "data-ktp-target": keytipAttributes["data-ktp-target"], ref: function(splitButton) {
            return _this._splitButton = splitButton;
          }, role: getMenuItemAriaRole(item), "aria-label": item.ariaLabel, className: classNames2.splitContainer, "aria-disabled": isItemDisabled(item), "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0, "aria-haspopup": true, "aria-describedby": mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? _this._ariaDescriptionId : void 0, keytipAttributes["aria-describedby"]), "aria-checked": ariaChecked, "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount, onMouseEnter: _this._onItemMouseEnterPrimary, onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(_this, __assign(__assign({}, item), { subMenuProps: null, items: null })) : void 0, onMouseMove: _this._onItemMouseMovePrimary, onKeyDown: _this._onItemKeyDown, onClick: _this._executeItemClick, onTouchStart: _this._onTouchStart, tabIndex: 0, "data-is-focusable": true, "aria-roledescription": item["aria-roledescription"] },
          _this._renderSplitPrimaryButton(item, classNames2, index, hasCheckmarks, hasIcons),
          _this._renderSplitDivider(item),
          _this._renderSplitIconButton(item, classNames2, index, keytipAttributes),
          _this._renderAriaDescription(ariaDescription, classNames2.screenReaderText)
        );
      });
    };
    ContextualMenuSplitButton2.prototype._renderSplitPrimaryButton = function(item, classNames2, index, hasCheckmarks, hasIcons) {
      var _a5 = this.props, _b3 = _a5.contextualMenuItemAs, ChildrenRenderer = _b3 === void 0 ? ContextualMenuItem : _b3, onItemClick = _a5.onItemClick;
      var itemProps = {
        key: item.key,
        disabled: isItemDisabled(item) || item.primaryDisabled,
        /* eslint-disable deprecation/deprecation */
        name: item.name,
        text: item.text || item.name,
        secondaryText: item.secondaryText,
        /* eslint-enable deprecation/deprecation */
        className: classNames2.splitPrimary,
        canCheck: item.canCheck,
        isChecked: item.isChecked,
        checked: item.checked,
        iconProps: item.iconProps,
        onRenderIcon: item.onRenderIcon,
        data: item.data,
        "data-is-focusable": false
      };
      var itemComponentProps = item.itemProps;
      return React22.createElement(
        "button",
        __assign({}, getNativeProps(itemProps, buttonProperties)),
        React22.createElement(ChildrenRenderer, __assign({ "data-is-focusable": false, item: itemProps, classNames: classNames2, index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons }, itemComponentProps))
      );
    };
    ContextualMenuSplitButton2.prototype._renderSplitDivider = function(item) {
      var getDividerClassNames2 = item.getSplitButtonVerticalDividerClassNames || getSplitButtonVerticalDividerClassNames;
      return React22.createElement(VerticalDivider, { getClassNames: getDividerClassNames2 });
    };
    ContextualMenuSplitButton2.prototype._renderSplitIconButton = function(item, classNames2, index, keytipAttributes) {
      var _a5 = this.props, _b3 = _a5.contextualMenuItemAs, ChildrenRenderer = _b3 === void 0 ? ContextualMenuItem : _b3, onItemMouseLeave = _a5.onItemMouseLeave, onItemMouseDown2 = _a5.onItemMouseDown, openSubMenu = _a5.openSubMenu, dismissSubMenu = _a5.dismissSubMenu, dismissMenu = _a5.dismissMenu;
      var itemProps = {
        onClick: this._onIconItemClick,
        disabled: isItemDisabled(item),
        className: classNames2.splitMenu,
        subMenuProps: item.subMenuProps,
        submenuIconProps: item.submenuIconProps,
        split: true,
        key: item.key
      };
      var buttonProps = __assign(__assign({}, getNativeProps(itemProps, buttonProperties)), {
        onMouseEnter: this._onItemMouseEnterIcon,
        onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(this, item) : void 0,
        onMouseDown: function(ev) {
          return onItemMouseDown2 ? onItemMouseDown2(item, ev) : void 0;
        },
        onMouseMove: this._onItemMouseMoveIcon,
        "data-is-focusable": false,
        "data-ktp-execute-target": keytipAttributes["data-ktp-execute-target"],
        "aria-hidden": true
      });
      var itemComponentProps = item.itemProps;
      return React22.createElement(
        "button",
        __assign({}, buttonProps),
        React22.createElement(ChildrenRenderer, __assign({ componentRef: item.componentRef, item: itemProps, classNames: classNames2, index, hasIcons: false, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: this._getSubmenuTarget }, itemComponentProps))
      );
    };
    ContextualMenuSplitButton2.prototype._handleTouchAndPointerEvent = function(ev) {
      var _this = this;
      var onTap = this.props.onTap;
      if (onTap) {
        onTap(ev);
      }
      if (this._lastTouchTimeoutId) {
        this._async.clearTimeout(this._lastTouchTimeoutId);
        this._lastTouchTimeoutId = void 0;
      }
      this._processingTouch = true;
      this._lastTouchTimeoutId = this._async.setTimeout(function() {
        _this._processingTouch = false;
        _this._lastTouchTimeoutId = void 0;
      }, TouchIdleDelay);
    };
    return ContextualMenuSplitButton2;
  }(ContextualMenuItemWrapper)
);

// node_modules/@fluentui/react/lib/utilities/hooks/useResponsiveMode.js
var React25 = __toESM(require_react());

// node_modules/@fluentui/react/lib/utilities/decorators/withResponsiveMode.js
var React24 = __toESM(require_react());

// node_modules/@fluentui/react/lib/utilities/decorators/BaseDecorator.js
var React23 = __toESM(require_react());
var BaseDecorator = (
  /** @class */
  function(_super) {
    __extends(BaseDecorator2, _super);
    function BaseDecorator2(props) {
      var _this = _super.call(this, props) || this;
      _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
      return _this;
    }
    BaseDecorator2.prototype._updateComposedComponentRef = function(composedComponentInstance) {
      this._composedComponentInstance = composedComponentInstance;
      if (composedComponentInstance) {
        this._hoisted = hoistMethods(this, composedComponentInstance);
      } else if (this._hoisted) {
        unhoistMethods(this, this._hoisted);
      }
    };
    return BaseDecorator2;
  }(React23.Component)
);

// node_modules/@fluentui/react/lib/utilities/decorators/withResponsiveMode.js
var ResponsiveMode;
(function(ResponsiveMode2) {
  ResponsiveMode2[ResponsiveMode2["small"] = 0] = "small";
  ResponsiveMode2[ResponsiveMode2["medium"] = 1] = "medium";
  ResponsiveMode2[ResponsiveMode2["large"] = 2] = "large";
  ResponsiveMode2[ResponsiveMode2["xLarge"] = 3] = "xLarge";
  ResponsiveMode2[ResponsiveMode2["xxLarge"] = 4] = "xxLarge";
  ResponsiveMode2[ResponsiveMode2["xxxLarge"] = 5] = "xxxLarge";
  ResponsiveMode2[ResponsiveMode2["unknown"] = 999] = "unknown";
})(ResponsiveMode || (ResponsiveMode = {}));
var RESPONSIVE_MAX_CONSTRAINT = [479, 639, 1023, 1365, 1919, 99999999];
var _defaultMode;
var _lastMode;
function setResponsiveMode(responsiveMode) {
  _defaultMode = responsiveMode;
}
function initializeResponsiveMode(element) {
  var currentWindow = getWindow(element);
  if (currentWindow) {
    getResponsiveMode(currentWindow);
  }
}
function getInitialResponsiveMode() {
  var _a5;
  return (_a5 = _defaultMode !== null && _defaultMode !== void 0 ? _defaultMode : _lastMode) !== null && _a5 !== void 0 ? _a5 : ResponsiveMode.large;
}
function withResponsiveMode(ComposedComponent) {
  var _a5;
  var resultClass = (_a5 = /** @class */
  function(_super) {
    __extends(WithResponsiveMode, _super);
    function WithResponsiveMode(props) {
      var _this = _super.call(this, props) || this;
      _this._onResize = function() {
        var responsiveMode = getResponsiveMode(_this.context.window);
        if (responsiveMode !== _this.state.responsiveMode) {
          _this.setState({
            responsiveMode
          });
        }
      };
      _this._events = new EventGroup(_this);
      _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
      _this.state = {
        responsiveMode: getInitialResponsiveMode()
      };
      return _this;
    }
    WithResponsiveMode.prototype.componentDidMount = function() {
      this._events.on(this.context.window, "resize", this._onResize);
      this._onResize();
    };
    WithResponsiveMode.prototype.componentWillUnmount = function() {
      this._events.dispose();
    };
    WithResponsiveMode.prototype.render = function() {
      var responsiveMode = this.state.responsiveMode;
      return responsiveMode === ResponsiveMode.unknown ? null : React24.createElement(ComposedComponent, __assign({ ref: this._updateComposedComponentRef, responsiveMode }, this.props));
    };
    return WithResponsiveMode;
  }(BaseDecorator), _a5.contextType = WindowContext, _a5);
  return hoistStatics(ComposedComponent, resultClass);
}
function getWidthOfCurrentWindow(currentWindow) {
  try {
    return currentWindow.document.documentElement.clientWidth;
  } catch (e) {
    return currentWindow.innerWidth;
  }
}
function getResponsiveMode(currentWindow) {
  var responsiveMode = ResponsiveMode.small;
  if (currentWindow) {
    try {
      while (getWidthOfCurrentWindow(currentWindow) > RESPONSIVE_MAX_CONSTRAINT[responsiveMode]) {
        responsiveMode++;
      }
    } catch (e) {
      responsiveMode = getInitialResponsiveMode();
    }
    _lastMode = responsiveMode;
  } else {
    if (_defaultMode !== void 0) {
      responsiveMode = _defaultMode;
    } else {
      throw new Error("Content was rendered in a server environment without providing a default responsive mode. Call setResponsiveMode to define what the responsive mode is.");
    }
  }
  return responsiveMode;
}

// node_modules/@fluentui/react/lib/utilities/hooks/useResponsiveMode.js
var useResponsiveMode = function(elementRef, overrideResponsiveMode) {
  var _a5 = React25.useState(getInitialResponsiveMode()), lastResponsiveMode = _a5[0], setLastResponsiveMode = _a5[1];
  var onResize = React25.useCallback(function() {
    var newResponsiveMode = getResponsiveMode(getWindow(elementRef.current));
    if (lastResponsiveMode !== newResponsiveMode) {
      setLastResponsiveMode(newResponsiveMode);
    }
  }, [elementRef, lastResponsiveMode]);
  var win = useWindow();
  useOnEvent(win, "resize", onResize);
  React25.useEffect(function() {
    if (overrideResponsiveMode === void 0) {
      onResize();
    }
  }, [overrideResponsiveMode]);
  return overrideResponsiveMode !== null && overrideResponsiveMode !== void 0 ? overrideResponsiveMode : lastResponsiveMode;
};

// node_modules/@fluentui/react/lib/utilities/MenuContext/MenuContext.js
var React26 = __toESM(require_react());
var MenuContext = React26.createContext({});

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.base.js
var getClassNames7 = classNamesFunction();
var getContextualMenuItemClassNames = classNamesFunction();
var DEFAULT_PROPS3 = {
  items: [],
  shouldFocusOnMount: true,
  gapSpace: 0,
  directionalHint: DirectionalHint.bottomAutoEdge,
  beakWidth: 16
};
function getItemCount(items) {
  var totalItemCount = 0;
  for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
    var item = items_1[_i];
    if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
      var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
      totalItemCount += itemCount;
    }
  }
  return totalItemCount;
}
function getSubmenuItems(item, options) {
  var target = options === null || options === void 0 ? void 0 : options.target;
  var items = item.subMenuProps ? item.subMenuProps.items : item.items;
  if (items) {
    var overrideItems = [];
    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
      var subItem = items_2[_i];
      if (subItem.preferMenuTargetAsEventTarget) {
        var onClick = subItem.onClick, contextItem = __rest(subItem, ["onClick"]);
        overrideItems.push(__assign(__assign({}, contextItem), { onClick: getOnClickWithOverrideTarget(onClick, target) }));
      } else {
        overrideItems.push(subItem);
      }
    }
    return overrideItems;
  }
}
function canAnyMenuItemsCheck(items) {
  return items.some(function(item) {
    if (item.canCheck) {
      return true;
    }
    if (item.sectionProps && item.sectionProps.items.some(function(submenuItem) {
      return submenuItem.canCheck === true;
    })) {
      return true;
    }
    return false;
  });
}
var NavigationIdleDelay = 250;
var COMPONENT_NAME3 = "ContextualMenu";
var _getMenuItemStylesFunction = memoizeFunction(function() {
  var styles = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    styles[_i] = arguments[_i];
  }
  return function(styleProps) {
    return concatStyleSetsWithProps.apply(void 0, __spreadArray([styleProps, getItemStyles], styles, false));
  };
});
function useVisibility(props, targetWindow) {
  var _a5 = props.hidden, hidden = _a5 === void 0 ? false : _a5, onMenuDismissed = props.onMenuDismissed, onMenuOpened = props.onMenuOpened;
  var previousHidden = usePrevious(hidden);
  var onMenuOpenedRef = React27.useRef(onMenuOpened);
  var onMenuClosedRef = React27.useRef(onMenuDismissed);
  var propsRef = React27.useRef(props);
  onMenuOpenedRef.current = onMenuOpened;
  onMenuClosedRef.current = onMenuDismissed;
  propsRef.current = props;
  React27.useEffect(function() {
    var _a6, _b3;
    if (hidden && previousHidden === false) {
      (_a6 = onMenuClosedRef.current) === null || _a6 === void 0 ? void 0 : _a6.call(onMenuClosedRef, propsRef.current);
    } else if (!hidden && previousHidden !== false) {
      (_b3 = onMenuOpenedRef.current) === null || _b3 === void 0 ? void 0 : _b3.call(onMenuOpenedRef, propsRef.current);
    }
  }, [hidden, previousHidden]);
  React27.useEffect(function() {
    return function() {
      var _a6;
      return (_a6 = onMenuClosedRef.current) === null || _a6 === void 0 ? void 0 : _a6.call(onMenuClosedRef, propsRef.current);
    };
  }, []);
}
function useSubMenuState(_a5, dismiss) {
  var hidden = _a5.hidden, items = _a5.items, theme = _a5.theme, className = _a5.className, id = _a5.id, menuTarget = _a5.target;
  var _b3 = React27.useState(), expandedMenuItemKey = _b3[0], setExpandedMenuItemKey = _b3[1];
  var _c3 = React27.useState(), submenuTarget = _c3[0], setSubmenuTarget = _c3[1];
  var _d3 = React27.useState(), shouldFocusOnContainer = _d3[0], setShouldFocusOnContainer = _d3[1];
  var subMenuId = useId(COMPONENT_NAME3, id);
  var closeSubMenu = React27.useCallback(function() {
    setShouldFocusOnContainer(void 0);
    setExpandedMenuItemKey(void 0);
    setSubmenuTarget(void 0);
  }, []);
  var openSubMenu = React27.useCallback(function(_a6, target, focusContainer) {
    var submenuItemKey = _a6.key;
    if (expandedMenuItemKey === submenuItemKey) {
      return;
    }
    target.focus();
    setShouldFocusOnContainer(focusContainer);
    setExpandedMenuItemKey(submenuItemKey);
    setSubmenuTarget(target);
  }, [expandedMenuItemKey]);
  React27.useEffect(function() {
    if (hidden) {
      closeSubMenu();
    }
  }, [hidden, closeSubMenu]);
  var onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);
  var getSubmenuProps = function() {
    var item = findItemByKeyFromItems(expandedMenuItemKey, items);
    var submenuProps = null;
    if (item) {
      submenuProps = {
        items: getSubmenuItems(item, { target: menuTarget }),
        target: submenuTarget,
        onDismiss: onSubMenuDismiss,
        isSubMenu: true,
        id: subMenuId,
        shouldFocusOnMount: true,
        shouldFocusOnContainer,
        directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,
        className,
        gapSpace: 0,
        isBeakVisible: false
      };
      if (item.subMenuProps) {
        assign(submenuProps, item.subMenuProps);
      }
      if (item.preferMenuTargetAsEventTarget) {
        var onItemClick = item.onItemClick;
        submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);
      }
    }
    return submenuProps;
  };
  return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss];
}
function useShouldUpdateFocusOnMouseMove(_a5) {
  var delayUpdateFocusOnHover = _a5.delayUpdateFocusOnHover, hidden = _a5.hidden;
  var shouldUpdateFocusOnMouseEvent = React27.useRef(!delayUpdateFocusOnHover);
  var gotMouseMove = React27.useRef(false);
  React27.useEffect(function() {
    shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;
    gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;
  }, [delayUpdateFocusOnHover, hidden]);
  var onMenuFocusCapture = React27.useCallback(function() {
    if (delayUpdateFocusOnHover) {
      shouldUpdateFocusOnMouseEvent.current = false;
    }
  }, [delayUpdateFocusOnHover]);
  return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture];
}
function usePreviousActiveElement(_a5, targetWindow, hostElement) {
  var hidden = _a5.hidden, onRestoreFocus = _a5.onRestoreFocus;
  var previousActiveElement = React27.useRef();
  var tryFocusPreviousActiveElement = React27.useCallback(function(options) {
    var _a6, _b3;
    if (onRestoreFocus) {
      onRestoreFocus(options);
    } else if (options === null || options === void 0 ? void 0 : options.documentContainsFocus) {
      (_b3 = (_a6 = previousActiveElement.current) === null || _a6 === void 0 ? void 0 : _a6.focus) === null || _b3 === void 0 ? void 0 : _b3.call(_a6);
    }
  }, [onRestoreFocus]);
  useIsomorphicLayoutEffect(function() {
    var _a6, _b3;
    if (!hidden) {
      var newElement = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement;
      if (!((_a6 = hostElement.current) === null || _a6 === void 0 ? void 0 : _a6.contains(newElement)) && newElement.tagName !== "BODY") {
        previousActiveElement.current = newElement;
      }
    } else if (previousActiveElement.current) {
      tryFocusPreviousActiveElement({
        originalElement: previousActiveElement.current,
        containsFocus: true,
        documentContainsFocus: ((_b3 = getDocument()) === null || _b3 === void 0 ? void 0 : _b3.hasFocus()) || false
      });
      previousActiveElement.current = void 0;
    }
  }, [hidden, targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement, tryFocusPreviousActiveElement, hostElement]);
  return [tryFocusPreviousActiveElement];
}
function useKeyHandlers(_a5, dismiss, hostElement, openSubMenu) {
  var theme = _a5.theme, isSubMenu = _a5.isSubMenu, _b3 = _a5.focusZoneProps, _c3 = _b3 === void 0 ? {} : _b3, checkForNoWrap = _c3.checkForNoWrap, _d3 = _c3.direction, focusZoneDirection = _d3 === void 0 ? FocusZoneDirection.vertical : _d3;
  var lastKeyDownWasAltOrMeta = React27.useRef();
  var keyHandler = function(ev, shouldHandleKey, dismissAllMenus) {
    var handled = false;
    if (shouldHandleKey(ev)) {
      dismiss(ev, dismissAllMenus);
      ev.preventDefault();
      ev.stopPropagation();
      handled = true;
    }
    return handled;
  };
  var shouldCloseSubMenu = function(ev) {
    var submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left;
    if (ev.which !== submenuCloseKey || !isSubMenu) {
      return false;
    }
    return !!(focusZoneDirection === FocusZoneDirection.vertical || checkForNoWrap && !shouldWrapFocus(ev.target, "data-no-horizontal-wrap"));
  };
  var shouldHandleKeyDown = function(ev) {
    return (
      // eslint-disable-next-line deprecation/deprecation
      ev.which === KeyCodes.escape || shouldCloseSubMenu(ev) || // eslint-disable-next-line deprecation/deprecation
      ev.which === KeyCodes.up && (ev.altKey || ev.metaKey)
    );
  };
  var onKeyDown = function(ev) {
    lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev);
    var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());
    return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);
  };
  var shouldHandleKeyUp = function(ev) {
    var keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);
    lastKeyDownWasAltOrMeta.current = false;
    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());
  };
  var onKeyUp = function(ev) {
    return keyHandler(
      ev,
      shouldHandleKeyUp,
      true
      /* dismissAllMenus */
    );
  };
  var onMenuKeyDown = function(ev) {
    var handled = onKeyDown(ev);
    if (handled || !hostElement.current) {
      return;
    }
    var hasModifier = !!(ev.altKey || ev.metaKey);
    var isUp = ev.which === KeyCodes.up;
    var isDown = ev.which === KeyCodes.down;
    if (!hasModifier && (isUp || isDown)) {
      var elementToFocus = isUp ? getLastFocusable(hostElement.current, hostElement.current.lastChild, true) : getFirstFocusable(hostElement.current, hostElement.current.firstChild, true);
      if (elementToFocus) {
        elementToFocus.focus();
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  };
  var onItemKeyDown = function(item, ev) {
    var openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;
    if (!item.disabled && // eslint-disable-next-line deprecation/deprecation
    (ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {
      openSubMenu(item, ev.currentTarget);
      ev.preventDefault();
    }
  };
  return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown];
}
function useScrollHandler(asyncTracker) {
  var isScrollIdle = React27.useRef(true);
  var scrollIdleTimeoutId = React27.useRef();
  var onScroll = function() {
    if (!isScrollIdle.current && scrollIdleTimeoutId.current !== void 0) {
      asyncTracker.clearTimeout(scrollIdleTimeoutId.current);
      scrollIdleTimeoutId.current = void 0;
    } else {
      isScrollIdle.current = false;
    }
    scrollIdleTimeoutId.current = asyncTracker.setTimeout(function() {
      isScrollIdle.current = true;
    }, NavigationIdleDelay);
  };
  return [onScroll, isScrollIdle];
}
function useOnSubmenuDismiss(dismiss, closeSubMenu) {
  var isMountedRef = React27.useRef(false);
  React27.useEffect(function() {
    isMountedRef.current = true;
    return function() {
      isMountedRef.current = false;
    };
  }, []);
  var onSubMenuDismiss = function(ev, dismissAll) {
    if (dismissAll) {
      dismiss(ev, dismissAll);
    } else if (isMountedRef.current) {
      closeSubMenu();
    }
  };
  return onSubMenuDismiss;
}
function useSubmenuEnterTimer(_a5, asyncTracker) {
  var _b3 = _a5.subMenuHoverDelay, subMenuHoverDelay = _b3 === void 0 ? NavigationIdleDelay : _b3;
  var enterTimerRef = React27.useRef(void 0);
  var cancelSubMenuTimer = function() {
    if (enterTimerRef.current !== void 0) {
      asyncTracker.clearTimeout(enterTimerRef.current);
      enterTimerRef.current = void 0;
    }
  };
  var startSubmenuTimer = function(onTimerExpired) {
    enterTimerRef.current = asyncTracker.setTimeout(function() {
      onTimerExpired();
      cancelSubMenuTimer();
    }, subMenuHoverDelay);
  };
  return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef];
}
function useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss) {
  var menuTarget = props.target;
  var onItemMouseEnterBase = function(item, ev, target) {
    if (shouldUpdateFocusOnMouseEvent.current) {
      gotMouseMove.current = true;
    }
    if (shouldIgnoreMouseEvent()) {
      return;
    }
    updateFocusOnMouseEvent(item, ev, target);
  };
  var onItemMouseMoveBase = function(item, ev, target) {
    var targetElement = ev.currentTarget;
    if (shouldUpdateFocusOnMouseEvent.current) {
      gotMouseMove.current = true;
    } else {
      return;
    }
    if (!isScrollIdle.current || subMenuEntryTimer.current !== void 0 || targetElement === (targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement)) {
      return;
    }
    updateFocusOnMouseEvent(item, ev, target);
  };
  var shouldIgnoreMouseEvent = function() {
    return !isScrollIdle.current || !gotMouseMove.current;
  };
  var onMouseItemLeave = function(item, ev) {
    var _a5;
    if (shouldIgnoreMouseEvent()) {
      return;
    }
    cancelSubMenuTimer();
    if (expandedMenuItemKey !== void 0) {
      return;
    }
    if (hostElement.current.setActive) {
      try {
        hostElement.current.setActive();
      } catch (e) {
      }
    } else {
      (_a5 = hostElement.current) === null || _a5 === void 0 ? void 0 : _a5.focus();
    }
  };
  var updateFocusOnMouseEvent = function(item, ev, target) {
    var targetElement = target ? target : ev.currentTarget;
    if (item.key === expandedMenuItemKey) {
      return;
    }
    cancelSubMenuTimer();
    if (expandedMenuItemKey === void 0) {
      targetElement.focus();
    }
    if (hasSubmenu(item)) {
      ev.stopPropagation();
      startSubmenuTimer(function() {
        targetElement.focus();
        openSubMenu(item, targetElement, true);
      });
    } else {
      startSubmenuTimer(function() {
        onSubMenuDismiss(ev);
        targetElement.focus();
      });
    }
  };
  var onItemClick = function(item, ev) {
    onItemClickBase(item, ev, ev.currentTarget);
  };
  var onItemClickBase = function(item, ev, target) {
    var items = getSubmenuItems(item, { target: menuTarget });
    cancelSubMenuTimer();
    if (!hasSubmenu(item) && (!items || !items.length)) {
      executeItemClick(item, ev);
    } else {
      if (item.key !== expandedMenuItemKey) {
        var shouldFocusOnContainer = typeof props.shouldFocusOnContainer === "boolean" ? props.shouldFocusOnContainer : ev.nativeEvent.pointerType === "mouse";
        openSubMenu(item, target, shouldFocusOnContainer);
      }
    }
    ev.stopPropagation();
    ev.preventDefault();
  };
  var onAnchorClick = function(item, ev) {
    executeItemClick(item, ev);
    ev.stopPropagation();
  };
  var executeItemClick = function(item, ev) {
    if (item.disabled || item.isDisabled) {
      return;
    }
    if (item.preferMenuTargetAsEventTarget) {
      overrideTarget(ev, menuTarget);
    }
    var shouldDismiss = false;
    if (item.onClick) {
      shouldDismiss = !!item.onClick(ev, item);
    } else if (props.onItemClick) {
      shouldDismiss = !!props.onItemClick(ev, item);
    }
    if (shouldDismiss || !ev.defaultPrevented) {
      dismiss(ev, true);
    }
  };
  return [
    onItemMouseEnterBase,
    onItemMouseMoveBase,
    onMouseItemLeave,
    onItemClick,
    onAnchorClick,
    executeItemClick,
    onItemClickBase
  ];
}
var ContextualMenuBase = React27.memo(React27.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var _a5;
  var _b3 = getPropsWithDefaults(DEFAULT_PROPS3, propsWithoutDefaults), ref = _b3.ref, props = __rest(_b3, ["ref"]);
  var hostElement = React27.useRef(null);
  var asyncTracker = useAsync();
  var menuId = useId(COMPONENT_NAME3, props.id);
  useWarnings({
    name: COMPONENT_NAME3,
    props,
    deprecations: {
      getMenuClassNames: "styles"
    }
  });
  var dismiss = function(ev, dismissAll) {
    var _a6;
    return (_a6 = props.onDismiss) === null || _a6 === void 0 ? void 0 : _a6.call(props, ev, dismissAll);
  };
  var _c3 = useTarget(props.target, hostElement), targetRef = _c3[0], targetWindow = _c3[1];
  var tryFocusPreviousActiveElement = usePreviousActiveElement(props, targetWindow, hostElement)[0];
  var _d3 = useSubMenuState(props, dismiss), expandedMenuItemKey = _d3[0], openSubMenu = _d3[1], getSubmenuProps = _d3[2], onSubMenuDismiss = _d3[3];
  var _e2 = useShouldUpdateFocusOnMouseMove(props), shouldUpdateFocusOnMouseEvent = _e2[0], gotMouseMove = _e2[1], onMenuFocusCapture = _e2[2];
  var _f = useScrollHandler(asyncTracker), onScroll = _f[0], isScrollIdle = _f[1];
  var _g = useSubmenuEnterTimer(props, asyncTracker), cancelSubMenuTimer = _g[0], startSubmenuTimer = _g[1], subMenuEntryTimer = _g[2];
  var responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);
  useVisibility(props, targetWindow);
  var _h = useKeyHandlers(props, dismiss, hostElement, openSubMenu), onKeyDown = _h[0], onKeyUp = _h[1], onMenuKeyDown = _h[2], onItemKeyDown = _h[3];
  var _j = useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss), onItemMouseEnterBase = _j[0], onItemMouseMoveBase = _j[1], onMouseItemLeave = _j[2], onItemClick = _j[3], onAnchorClick = _j[4], executeItemClick = _j[5], onItemClickBase = _j[6];
  var onDefaultRenderMenuList = function(menuListProps, menuClassNames, defaultRender) {
    var indexCorrection = 0;
    var items2 = menuListProps.items, totalItemCount = menuListProps.totalItemCount, hasCheckmarks2 = menuListProps.hasCheckmarks, hasIcons2 = menuListProps.hasIcons;
    return React27.createElement("ul", { className: menuClassNames.list, onKeyDown, onKeyUp, role: "presentation" }, items2.map(function(item, index) {
      var menuItem = renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames);
      if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
        var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
        indexCorrection += indexIncrease;
      }
      return menuItem;
    }));
  };
  var renderFocusZone = function(children, adjustedFocusZoneProps2) {
    var _a6 = props.focusZoneAs, ChildrenRenderer = _a6 === void 0 ? FocusZone : _a6;
    return React27.createElement(ChildrenRenderer, __assign({}, adjustedFocusZoneProps2), children);
  };
  var renderMenuItem = function(item, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames) {
    var _a6;
    var renderedItems = [];
    var iconProps = item.iconProps || { iconName: "None" };
    var getItemClassNames2 = item.getItemClassNames, itemProps = item.itemProps;
    var styles2 = itemProps ? itemProps.styles : void 0;
    var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : void 0;
    var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : "";
    var itemClassNames;
    if (getItemClassNames2) {
      itemClassNames = getItemClassNames2(props.theme, isItemDisabled(item), expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== "None", item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);
    } else {
      var itemStyleProps = {
        theme: props.theme,
        disabled: isItemDisabled(item),
        expanded: expandedMenuItemKey === item.key,
        checked: !!getIsChecked(item),
        isAnchorLink: !!item.href,
        knownIcon: iconProps.iconName !== "None",
        itemClassName: item.className,
        dividerClassName,
        iconClassName: iconProps.className,
        subMenuClassName: subMenuIconClassName,
        primaryDisabled: item.primaryDisabled
      };
      itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a6 = menuClassNames.subComponentStyles) === null || _a6 === void 0 ? void 0 : _a6.menuItem, styles2), itemStyleProps);
    }
    if (item.text === "-" || item.name === "-") {
      item.itemType = ContextualMenuItemType.Divider;
    }
    switch (item.itemType) {
      case ContextualMenuItemType.Divider:
        renderedItems.push(renderSeparator(index, itemClassNames));
        break;
      case ContextualMenuItemType.Header:
        renderedItems.push(renderSeparator(index, itemClassNames));
        var headerItem = renderHeaderMenuItem(item, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2);
        renderedItems.push(renderListItem(headerItem, item.key || index, itemClassNames, item.title));
        break;
      case ContextualMenuItemType.Section:
        renderedItems.push(renderSectionItem(item, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2));
        break;
      default:
        var defaultRenderNormalItem = function() {
          return renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2);
        };
        var menuItem = props.onRenderContextualMenuItem ? props.onRenderContextualMenuItem(item, defaultRenderNormalItem) : defaultRenderNormalItem();
        renderedItems.push(renderListItem(menuItem, item.key || index, itemClassNames, item.title));
        break;
    }
    return React27.createElement(React27.Fragment, { key: item.key }, renderedItems);
  };
  var defaultMenuItemRenderer = function(item, menuClassNames) {
    var index = item.index, focusableElementIndex = item.focusableElementIndex, totalItemCount = item.totalItemCount, hasCheckmarks2 = item.hasCheckmarks, hasIcons2 = item.hasIcons;
    return renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames);
  };
  var renderSectionItem = function(sectionItem, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2) {
    var sectionProps = sectionItem.sectionProps;
    if (!sectionProps) {
      return;
    }
    var headerItem;
    var groupProps;
    if (sectionProps.title) {
      var headerContextualMenuItem = void 0;
      var ariaLabelledby = "";
      if (typeof sectionProps.title === "string") {
        var id_1 = menuId + sectionProps.title.replace(/\s/g, "");
        headerContextualMenuItem = {
          key: "section-".concat(sectionProps.title, "-title"),
          itemType: ContextualMenuItemType.Header,
          text: sectionProps.title,
          id: id_1
        };
        ariaLabelledby = id_1;
      } else {
        var id_2 = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\s/g, "");
        headerContextualMenuItem = __assign(__assign({}, sectionProps.title), { id: id_2 });
        ariaLabelledby = id_2;
      }
      if (headerContextualMenuItem) {
        groupProps = {
          role: "group",
          "aria-labelledby": ariaLabelledby
        };
        headerItem = renderHeaderMenuItem(headerContextualMenuItem, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2);
      }
    }
    if (sectionProps.items && sectionProps.items.length > 0) {
      var correctedIndex_1 = 0;
      return React27.createElement(
        "li",
        { role: "presentation", key: sectionProps.key || sectionItem.key || "section-".concat(index) },
        React27.createElement(
          "div",
          __assign({}, groupProps),
          React27.createElement(
            "ul",
            { className: menuClassNames.list, role: "presentation" },
            sectionProps.topDivider && renderSeparator(index, itemClassNames, true, true),
            headerItem && renderListItem(headerItem, sectionItem.key || index, itemClassNames, sectionItem.title),
            sectionProps.items.map(function(contextualMenuItem, itemsIndex) {
              var menuItem = renderMenuItem(contextualMenuItem, itemsIndex, correctedIndex_1, getItemCount(sectionProps.items), hasCheckmarks2, hasIcons2, menuClassNames);
              if (contextualMenuItem.itemType !== ContextualMenuItemType.Divider && contextualMenuItem.itemType !== ContextualMenuItemType.Header) {
                var indexIncrease = contextualMenuItem.customOnRenderListLength ? contextualMenuItem.customOnRenderListLength : 1;
                correctedIndex_1 += indexIncrease;
              }
              return menuItem;
            }),
            sectionProps.bottomDivider && renderSeparator(index, itemClassNames, false, true)
          )
        )
      );
    }
  };
  var renderListItem = function(content, key, classNames3, title2) {
    return React27.createElement("li", { role: "presentation", title: title2, key, className: classNames3.item }, content);
  };
  var renderSeparator = function(index, classNames3, top, fromSection) {
    if (fromSection || index > 0) {
      return React27.createElement("li", { role: "separator", key: "separator-" + index + (top === void 0 ? "" : top ? "-top" : "-bottom"), className: classNames3.divider, "aria-hidden": "true" });
    }
    return null;
  };
  var renderNormalItem = function(item, classNames3, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2) {
    if (item.onRender) {
      return item.onRender(__assign({ "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount }, item), dismiss);
    }
    var contextualMenuItemAs = props.contextualMenuItemAs;
    var commonProps = {
      item,
      classNames: classNames3,
      index,
      focusableElementIndex,
      totalItemCount,
      hasCheckmarks: hasCheckmarks2,
      hasIcons: hasIcons2,
      contextualMenuItemAs,
      onItemMouseEnter: onItemMouseEnterBase,
      onItemMouseLeave: onMouseItemLeave,
      onItemMouseMove: onItemMouseMoveBase,
      onItemMouseDown,
      executeItemClick,
      onItemKeyDown,
      expandedMenuItemKey,
      openSubMenu,
      dismissSubMenu: onSubMenuDismiss,
      dismissMenu: dismiss
    };
    if (item.href) {
      return React27.createElement(ContextualMenuAnchor, __assign({}, commonProps, { onItemClick: onAnchorClick }));
    }
    if (item.split && hasSubmenu(item)) {
      return React27.createElement(ContextualMenuSplitButton, __assign({}, commonProps, { onItemClick, onItemClickBase, onTap: cancelSubMenuTimer }));
    }
    return React27.createElement(ContextualMenuButton, __assign({}, commonProps, { onItemClick, onItemClickBase }));
  };
  var renderHeaderMenuItem = function(item, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2) {
    var _a6 = props.contextualMenuItemAs, ChildrenRenderer = _a6 === void 0 ? ContextualMenuItem : _a6;
    var itemProps = item.itemProps, id2 = item.id;
    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);
    return (
      // eslint-disable-next-line deprecation/deprecation
      React27.createElement(
        "div",
        __assign({ id: id2, className: menuClassNames.header }, divHtmlProperties, { style: item.style }),
        React27.createElement(ChildrenRenderer, __assign({ item, classNames: itemClassNames, index, onCheckmarkClick: hasCheckmarks2 ? onItemClick : void 0, hasIcons: hasIcons2 }, itemProps))
      )
    );
  };
  var isBeakVisible = props.isBeakVisible;
  var items = props.items, labelElementId = props.labelElementId, id = props.id, className = props.className, beakWidth = props.beakWidth, directionalHint = props.directionalHint, directionalHintForRTL = props.directionalHintForRTL, alignTargetEdge = props.alignTargetEdge, gapSpace = props.gapSpace, coverTarget = props.coverTarget, ariaLabel = props.ariaLabel, doNotLayer = props.doNotLayer, target = props.target, bounds = props.bounds, useTargetWidth = props.useTargetWidth, useTargetAsMinWidth = props.useTargetAsMinWidth, directionalHintFixed = props.directionalHintFixed, shouldFocusOnMount = props.shouldFocusOnMount, shouldFocusOnContainer = props.shouldFocusOnContainer, title = props.title, styles = props.styles, theme = props.theme, calloutProps = props.calloutProps, _k = props.onRenderSubMenu, onRenderSubMenu2 = _k === void 0 ? onDefaultRenderSubMenu : _k, _l = props.onRenderMenuList, onRenderMenuList = _l === void 0 ? function(menuListProps, defaultRender) {
    return onDefaultRenderMenuList(menuListProps, classNames2, defaultRender);
  } : _l, focusZoneProps = props.focusZoneProps, getMenuClassNames = props.getMenuClassNames;
  var classNames2 = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames7(styles, {
    theme,
    className
  });
  var hasIcons = itemsHaveIcons(items);
  function itemsHaveIcons(contextualMenuItems) {
    for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {
      var item = contextualMenuItems_1[_i];
      if (item.iconProps) {
        return true;
      }
      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {
        return true;
      }
    }
    return false;
  }
  var adjustedFocusZoneProps = __assign(__assign({ direction: FocusZoneDirection.vertical, handleTabKey: FocusZoneTabbableElements.all, isCircularNavigation: true }, focusZoneProps), { className: css(classNames2.root, (_a5 = props.focusZoneProps) === null || _a5 === void 0 ? void 0 : _a5.className) });
  var hasCheckmarks = canAnyMenuItemsCheck(items);
  var submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;
  isBeakVisible = isBeakVisible === void 0 ? responsiveMode <= ResponsiveMode.medium : isBeakVisible;
  var contextMenuStyle;
  var targetAsHtmlElement = targetRef.current;
  if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {
    var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();
    var targetWidth = targetBoundingRect.width - 2;
    if (useTargetWidth) {
      contextMenuStyle = {
        width: targetWidth
      };
    } else if (useTargetAsMinWidth) {
      contextMenuStyle = {
        minWidth: targetWidth
      };
    }
  }
  if (items && items.length > 0) {
    var totalItemCount_1 = getItemCount(items);
    var calloutStyles_1 = classNames2.subComponentStyles ? classNames2.subComponentStyles.callout : void 0;
    return React27.createElement(MenuContext.Consumer, null, function(menuContext) {
      return React27.createElement(
        Callout,
        __assign({ styles: calloutStyles_1, onRestoreFocus: tryFocusPreviousActiveElement }, calloutProps, { target: target || menuContext.target, isBeakVisible, beakWidth, directionalHint, directionalHintForRTL, gapSpace, coverTarget, doNotLayer, className: css("ms-ContextualMenu-Callout", calloutProps && calloutProps.className), setInitialFocus: shouldFocusOnMount, onDismiss: props.onDismiss || menuContext.onDismiss, onScroll, bounds, directionalHintFixed, alignTargetEdge, hidden: props.hidden || menuContext.hidden, ref: forwardedRef }),
        React27.createElement(
          "div",
          { style: contextMenuStyle, ref: hostElement, id, className: classNames2.container, tabIndex: shouldFocusOnContainer ? 0 : -1, onKeyDown: onMenuKeyDown, onKeyUp, onFocusCapture: onMenuFocusCapture, "aria-label": ariaLabel, "aria-labelledby": labelElementId, role: "menu" },
          title && React27.createElement(
            "div",
            { className: classNames2.title },
            " ",
            title,
            " "
          ),
          items && items.length ? renderFocusZone(onRenderMenuList({
            ariaLabel,
            items,
            totalItemCount: totalItemCount_1,
            hasCheckmarks,
            hasIcons,
            defaultMenuItemRenderer: function(item) {
              return defaultMenuItemRenderer(item, classNames2);
            },
            labelElementId
          }, function(menuListProps, defaultRender) {
            return onDefaultRenderMenuList(menuListProps, classNames2, defaultRender);
          }), adjustedFocusZoneProps) : null,
          submenuProps && onRenderSubMenu2(submenuProps, onDefaultRenderSubMenu)
        ),
        React27.createElement(FocusRects, null)
      );
    });
  } else {
    return null;
  }
}), function(prevProps, newProps) {
  if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {
    return true;
  }
  return shallowCompare(prevProps, newProps);
});
ContextualMenuBase.displayName = "ContextualMenuBase";
function isAltOrMeta(ev) {
  return ev.which === KeyCodes.alt || ev.key === "Meta";
}
function onItemMouseDown(item, ev) {
  var _a5;
  (_a5 = item.onMouseDown) === null || _a5 === void 0 ? void 0 : _a5.call(item, item, ev);
}
function onDefaultRenderSubMenu(subMenuProps, defaultRender) {
  throw Error("ContextualMenuBase: onRenderSubMenu callback is null or undefined. Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.");
}
function findItemByKeyFromItems(key, items) {
  for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {
    var item = items_3[_i];
    if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {
      var match = findItemByKeyFromItems(key, item.sectionProps.items);
      if (match) {
        return match;
      }
    } else if (item.key && item.key === key) {
      return item;
    }
  }
}
function getOnClickWithOverrideTarget(onClick, target) {
  return onClick ? function(ev, item) {
    overrideTarget(ev, target);
    return onClick(ev, item);
  } : onClick;
}
function overrideTarget(ev, target) {
  if (ev && target) {
    ev.persist();
    if (target instanceof Event) {
      ev.target = target.target;
    } else if (target instanceof Element) {
      ev.target = target;
    }
  }
}

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.styles.js
var GlobalClassNames6 = {
  root: "ms-ContextualMenu",
  container: "ms-ContextualMenu-container",
  list: "ms-ContextualMenu-list",
  header: "ms-ContextualMenu-header",
  title: "ms-ContextualMenu-title",
  isopen: "is-open"
};
var getStyles7 = function(props) {
  var className = props.className, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames6, theme);
  var fonts = theme.fonts, semanticColors = theme.semanticColors, effects = theme.effects;
  return {
    root: [
      theme.fonts.medium,
      classNames2.root,
      classNames2.isopen,
      {
        backgroundColor: semanticColors.menuBackground,
        minWidth: "180px"
      },
      className
    ],
    container: [
      classNames2.container,
      {
        selectors: {
          ":focus": { outline: 0 }
        }
      }
    ],
    list: [
      classNames2.list,
      classNames2.isopen,
      {
        listStyleType: "none",
        margin: "0",
        padding: "0"
      }
    ],
    header: [
      classNames2.header,
      fonts.small,
      {
        fontWeight: FontWeights.semibold,
        color: semanticColors.menuHeader,
        background: "none",
        backgroundColor: "transparent",
        border: "none",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
        cursor: "default",
        padding: "0px 6px",
        userSelect: "none",
        textAlign: "left"
      }
    ],
    title: [
      classNames2.title,
      {
        fontSize: fonts.mediumPlus.fontSize,
        paddingRight: "14px",
        paddingLeft: "14px",
        paddingBottom: "5px",
        paddingTop: "5px",
        backgroundColor: semanticColors.menuItemBackgroundPressed
      }
    ],
    subComponentStyles: {
      callout: {
        root: {
          boxShadow: effects.elevation8
        }
      },
      menuItem: {}
    }
  };
};

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.js
function onRenderSubMenu(subMenuProps) {
  return React28.createElement(LocalContextualMenu, __assign({}, subMenuProps));
}
var LocalContextualMenu = styled(ContextualMenuBase, getStyles7, function(props) {
  return {
    onRenderSubMenu: props.onRenderSubMenu ? composeRenderFunction(props.onRenderSubMenu, onRenderSubMenu) : onRenderSubMenu
  };
}, { scope: "ContextualMenu" });
var ContextualMenu = LocalContextualMenu;
ContextualMenu.displayName = "ContextualMenu";

// node_modules/@fluentui/react/lib/components/Button/BaseButton.classNames.js
var ButtonGlobalClassNames = {
  msButton: "ms-Button",
  msButtonHasMenu: "ms-Button--hasMenu",
  msButtonIcon: "ms-Button-icon",
  msButtonMenuIcon: "ms-Button-menuIcon",
  msButtonLabel: "ms-Button-label",
  msButtonDescription: "ms-Button-description",
  msButtonScreenReaderText: "ms-Button-screenReaderText",
  msButtonFlexContainer: "ms-Button-flexContainer",
  msButtonTextContainer: "ms-Button-textContainer"
};
var getBaseButtonClassNames = memoizeFunction(function(theme, styles, className, variantClassName, iconClassName, menuIconClassName, disabled, hasMenu, checked, expanded, isSplit) {
  var _a5, _b3;
  var classNames2 = getGlobalClassNames(ButtonGlobalClassNames, theme || {});
  var isExpanded = expanded && !isSplit;
  return mergeStyleSets({
    root: [
      classNames2.msButton,
      styles.root,
      variantClassName,
      checked && ["is-checked", styles.rootChecked],
      isExpanded && [
        "is-expanded",
        styles.rootExpanded,
        {
          selectors: (_a5 = {}, _a5[":hover .".concat(classNames2.msButtonIcon)] = styles.iconExpandedHovered, // menuIcon falls back to rootExpandedHovered to support original behavior
          _a5[":hover .".concat(classNames2.msButtonMenuIcon)] = styles.menuIconExpandedHovered || styles.rootExpandedHovered, _a5[":hover"] = styles.rootExpandedHovered, _a5)
        }
      ],
      hasMenu && [ButtonGlobalClassNames.msButtonHasMenu, styles.rootHasMenu],
      disabled && ["is-disabled", styles.rootDisabled],
      !disabled && !isExpanded && !checked && {
        selectors: (_b3 = {
          ":hover": styles.rootHovered
        }, _b3[":hover .".concat(classNames2.msButtonLabel)] = styles.labelHovered, _b3[":hover .".concat(classNames2.msButtonIcon)] = styles.iconHovered, _b3[":hover .".concat(classNames2.msButtonDescription)] = styles.descriptionHovered, _b3[":hover .".concat(classNames2.msButtonMenuIcon)] = styles.menuIconHovered, _b3[":focus"] = styles.rootFocused, _b3[":active"] = styles.rootPressed, _b3[":active .".concat(classNames2.msButtonIcon)] = styles.iconPressed, _b3[":active .".concat(classNames2.msButtonDescription)] = styles.descriptionPressed, _b3[":active .".concat(classNames2.msButtonMenuIcon)] = styles.menuIconPressed, _b3)
      },
      disabled && checked && [styles.rootCheckedDisabled],
      !disabled && checked && {
        selectors: {
          ":hover": styles.rootCheckedHovered,
          ":active": styles.rootCheckedPressed
        }
      },
      className
    ],
    flexContainer: [classNames2.msButtonFlexContainer, styles.flexContainer],
    textContainer: [classNames2.msButtonTextContainer, styles.textContainer],
    icon: [
      classNames2.msButtonIcon,
      iconClassName,
      styles.icon,
      isExpanded && styles.iconExpanded,
      checked && styles.iconChecked,
      disabled && styles.iconDisabled
    ],
    label: [classNames2.msButtonLabel, styles.label, checked && styles.labelChecked, disabled && styles.labelDisabled],
    menuIcon: [
      classNames2.msButtonMenuIcon,
      menuIconClassName,
      styles.menuIcon,
      checked && styles.menuIconChecked,
      disabled && !isSplit && styles.menuIconDisabled,
      !disabled && !isExpanded && !checked && {
        selectors: {
          ":hover": styles.menuIconHovered,
          ":active": styles.menuIconPressed
        }
      },
      isExpanded && ["is-expanded", styles.menuIconExpanded]
    ],
    description: [
      classNames2.msButtonDescription,
      styles.description,
      checked && styles.descriptionChecked,
      disabled && styles.descriptionDisabled
    ],
    screenReaderText: [classNames2.msButtonScreenReaderText, styles.screenReaderText]
  });
});

// node_modules/@fluentui/react/lib/components/Button/SplitButton/SplitButton.classNames.js
var getSplitButtonClassNames = memoizeFunction(function(styles, disabled, expanded, checked, primaryDisabled) {
  return {
    root: mergeStyles(styles.splitButtonMenuButton, expanded && [styles.splitButtonMenuButtonExpanded], disabled && [styles.splitButtonMenuButtonDisabled], checked && !disabled && [styles.splitButtonMenuButtonChecked], primaryDisabled && !disabled && [
      {
        selectors: {
          ":focus": styles.splitButtonMenuFocused
        }
      }
    ]),
    splitButtonContainer: mergeStyles(styles.splitButtonContainer, !disabled && checked && [
      styles.splitButtonContainerChecked,
      {
        selectors: {
          ":hover": styles.splitButtonContainerCheckedHovered
        }
      }
    ], !disabled && !checked && [
      {
        selectors: {
          ":hover": styles.splitButtonContainerHovered,
          ":focus": styles.splitButtonContainerFocused
        }
      }
    ], disabled && styles.splitButtonContainerDisabled),
    icon: mergeStyles(styles.splitButtonMenuIcon, disabled && styles.splitButtonMenuIconDisabled, !disabled && primaryDisabled && styles.splitButtonMenuIcon),
    flexContainer: mergeStyles(styles.splitButtonFlexContainer),
    divider: mergeStyles(styles.splitButtonDivider, (primaryDisabled || disabled) && styles.splitButtonDividerDisabled)
  };
});

// node_modules/@fluentui/react/lib/components/Button/BaseButton.js
var TouchIdleDelay2 = 500;
var COMPONENT_NAME4 = "BaseButton";
var BaseButton = (
  /** @class */
  function(_super) {
    __extends(BaseButton2, _super);
    function BaseButton2(props) {
      var _this = _super.call(this, props) || this;
      _this._buttonElement = React29.createRef();
      _this._splitButtonContainer = React29.createRef();
      _this._mergedRef = createMergedRef();
      _this._renderedVisibleMenu = false;
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign(__assign({}, keytipProps), { hasMenu: true });
      });
      _this._onRenderIcon = function(buttonProps, defaultRender) {
        var iconProps = _this.props.iconProps;
        if (iconProps && (iconProps.iconName !== void 0 || iconProps.imageProps)) {
          var className = iconProps.className, imageProps = iconProps.imageProps, rest = __rest(iconProps, ["className", "imageProps"]);
          if (iconProps.styles) {
            return React29.createElement(Icon, __assign({ className: css(_this._classNames.icon, className), imageProps }, rest));
          }
          if (iconProps.iconName) {
            return React29.createElement(FontIcon, __assign({ className: css(_this._classNames.icon, className) }, rest));
          }
          if (imageProps) {
            return React29.createElement(ImageIcon, __assign({ className: css(_this._classNames.icon, className), imageProps }, rest));
          }
        }
        return null;
      };
      _this._onRenderTextContents = function() {
        var _a5 = _this.props, text = _a5.text, children = _a5.children, _b3 = _a5.secondaryText, secondaryText = _b3 === void 0 ? _this.props.description : _b3, _c3 = _a5.onRenderText, onRenderText = _c3 === void 0 ? _this._onRenderText : _c3, _d3 = _a5.onRenderDescription, onRenderDescription = _d3 === void 0 ? _this._onRenderDescription : _d3;
        if (text || typeof children === "string" || secondaryText) {
          return React29.createElement(
            "span",
            { className: _this._classNames.textContainer },
            onRenderText(_this.props, _this._onRenderText),
            onRenderDescription(_this.props, _this._onRenderDescription)
          );
        }
        return [onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription)];
      };
      _this._onRenderText = function() {
        var text = _this.props.text;
        var children = _this.props.children;
        if (text === void 0 && typeof children === "string") {
          text = children;
        }
        if (_this._hasText()) {
          return React29.createElement("span", { key: _this._labelId, className: _this._classNames.label, id: _this._labelId }, text);
        }
        return null;
      };
      _this._onRenderChildren = function() {
        var children = _this.props.children;
        if (typeof children === "string") {
          return null;
        }
        return children;
      };
      _this._onRenderDescription = function(props2) {
        var _a5 = props2.secondaryText, secondaryText = _a5 === void 0 ? _this.props.description : _a5;
        return secondaryText ? React29.createElement("span", { key: _this._descriptionId, className: _this._classNames.description, id: _this._descriptionId }, secondaryText) : null;
      };
      _this._onRenderAriaDescription = function() {
        var ariaDescription = _this.props.ariaDescription;
        return ariaDescription ? React29.createElement("span", { className: _this._classNames.screenReaderText, id: _this._ariaDescriptionId }, ariaDescription) : null;
      };
      _this._onRenderMenuIcon = function(props2) {
        var menuIconProps = _this.props.menuIconProps;
        return React29.createElement(FontIcon, __assign({ iconName: "ChevronDown" }, menuIconProps, { className: _this._classNames.menuIcon }));
      };
      _this._onRenderMenu = function(menuProps) {
        var MenuType = _this.props.menuAs ? composeComponentAs(_this.props.menuAs, ContextualMenu) : ContextualMenu;
        return React29.createElement(MenuType, __assign({}, menuProps));
      };
      _this._onDismissMenu = function(ev) {
        var menuProps = _this.props.menuProps;
        if (menuProps && menuProps.onDismiss) {
          menuProps.onDismiss(ev);
        }
        if (!ev || !ev.defaultPrevented) {
          _this._dismissMenu();
        }
      };
      _this._dismissMenu = function() {
        _this._menuShouldFocusOnMount = void 0;
        _this._menuShouldFocusOnContainer = void 0;
        _this.setState({ menuHidden: true });
      };
      _this._openMenu = function(shouldFocusOnContainer, shouldFocusOnMount) {
        if (shouldFocusOnMount === void 0) {
          shouldFocusOnMount = true;
        }
        if (_this.props.menuProps) {
          _this._menuShouldFocusOnContainer = shouldFocusOnContainer;
          _this._menuShouldFocusOnMount = shouldFocusOnMount;
          _this._renderedVisibleMenu = true;
          _this.setState({ menuHidden: false });
        }
      };
      _this._onToggleMenu = function(shouldFocusOnContainer) {
        var shouldFocusOnMount = true;
        if (_this.props.menuProps && _this.props.menuProps.shouldFocusOnMount === false) {
          shouldFocusOnMount = false;
        }
        _this.state.menuHidden ? _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : _this._dismissMenu();
      };
      _this._onSplitContainerFocusCapture = function(ev) {
        var container = _this._splitButtonContainer.current;
        if (!container || ev.target && portalContainsElement(ev.target, container)) {
          return;
        }
        container.focus();
      };
      _this._onSplitButtonPrimaryClick = function(ev) {
        if (!_this.state.menuHidden) {
          _this._dismissMenu();
        }
        if (!_this._processingTouch && _this.props.onClick) {
          _this.props.onClick(ev);
        } else if (_this._processingTouch) {
          _this._onMenuClick(ev);
        }
      };
      _this._onKeyDown = function(ev) {
        if (_this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {
          ev.preventDefault();
          ev.stopPropagation();
        } else if (!_this.props.disabled) {
          if (_this.props.menuProps) {
            _this._onMenuKeyDown(ev);
          } else if (_this.props.onKeyDown !== void 0) {
            _this.props.onKeyDown(ev);
          }
        }
      };
      _this._onKeyUp = function(ev) {
        if (!_this.props.disabled && _this.props.onKeyUp !== void 0) {
          _this.props.onKeyUp(ev);
        }
      };
      _this._onKeyPress = function(ev) {
        if (!_this.props.disabled && _this.props.onKeyPress !== void 0) {
          _this.props.onKeyPress(ev);
        }
      };
      _this._onMouseUp = function(ev) {
        if (!_this.props.disabled && _this.props.onMouseUp !== void 0) {
          _this.props.onMouseUp(ev);
        }
      };
      _this._onMouseDown = function(ev) {
        if (!_this.props.disabled && _this.props.onMouseDown !== void 0) {
          _this.props.onMouseDown(ev);
        }
      };
      _this._onClick = function(ev) {
        if (!_this.props.disabled) {
          if (_this.props.menuProps) {
            _this._onMenuClick(ev);
          } else if (_this.props.onClick !== void 0) {
            _this.props.onClick(ev);
          }
        }
      };
      _this._onSplitButtonContainerKeyDown = function(ev) {
        if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
          if (_this._buttonElement.current) {
            _this._buttonElement.current.click();
            ev.preventDefault();
            ev.stopPropagation();
          }
        } else {
          _this._onMenuKeyDown(ev);
        }
      };
      _this._onMenuKeyDown = function(ev) {
        var _a5;
        if (_this.props.disabled) {
          return;
        }
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(ev);
        }
        var isUp = ev.which === KeyCodes.up;
        var isDown = ev.which === KeyCodes.down;
        if (!ev.defaultPrevented && _this._isValidMenuOpenKey(ev)) {
          var onMenuClick = _this.props.onMenuClick;
          if (onMenuClick) {
            onMenuClick(ev, _this.props);
          }
          _this._onToggleMenu(false);
          ev.preventDefault();
          ev.stopPropagation();
        }
        if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
          setFocusVisibility(true, ev.target, (_a5 = _this.context) === null || _a5 === void 0 ? void 0 : _a5.registeredProviders);
        }
        if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {
          if (!_this.state.menuHidden && _this.props.menuProps) {
            var currentShouldFocusOnMount = _this._menuShouldFocusOnMount !== void 0 ? _this._menuShouldFocusOnMount : _this.props.menuProps.shouldFocusOnMount;
            if (!currentShouldFocusOnMount) {
              ev.preventDefault();
              ev.stopPropagation();
              _this._menuShouldFocusOnMount = true;
              _this.forceUpdate();
            }
          }
        }
      };
      _this._onTouchStart = function() {
        if (_this._isSplitButton && _this._splitButtonContainer.current && !("onpointerdown" in _this._splitButtonContainer.current)) {
          _this._handleTouchAndPointerEvent();
        }
      };
      _this._onMenuClick = function(ev) {
        var _a5 = _this.props, onMenuClick = _a5.onMenuClick, menuProps = _a5.menuProps;
        if (onMenuClick) {
          onMenuClick(ev, _this.props);
        }
        var shouldFocusOnContainer = typeof (menuProps === null || menuProps === void 0 ? void 0 : menuProps.shouldFocusOnContainer) === "boolean" ? menuProps.shouldFocusOnContainer : ev.nativeEvent.pointerType === "mouse";
        if (!ev.defaultPrevented) {
          _this._onToggleMenu(shouldFocusOnContainer);
          ev.preventDefault();
          ev.stopPropagation();
        }
      };
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      warnConditionallyRequiredProps(COMPONENT_NAME4, props, ["menuProps", "onClick"], "split", _this.props.split);
      warnDeprecations(COMPONENT_NAME4, props, {
        rootProps: void 0,
        description: "secondaryText",
        toggled: "checked"
      });
      _this._labelId = getId();
      _this._descriptionId = getId();
      _this._ariaDescriptionId = getId();
      _this.state = {
        menuHidden: true
      };
      return _this;
    }
    Object.defineProperty(BaseButton2.prototype, "_isSplitButton", {
      get: function() {
        return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;
      },
      enumerable: false,
      configurable: true
    });
    BaseButton2.prototype.render = function() {
      var _a5;
      var _b3 = this.props, ariaDescription = _b3.ariaDescription, ariaLabel = _b3.ariaLabel, ariaHidden = _b3.ariaHidden, className = _b3.className, disabled = _b3.disabled, allowDisabledFocus = _b3.allowDisabledFocus, primaryDisabled = _b3.primaryDisabled, _c3 = _b3.secondaryText, secondaryText = _c3 === void 0 ? this.props.description : _c3, href = _b3.href, iconProps = _b3.iconProps, menuIconProps = _b3.menuIconProps, styles = _b3.styles, checked = _b3.checked, variantClassName = _b3.variantClassName, theme = _b3.theme, toggle = _b3.toggle, getClassNames13 = _b3.getClassNames, role = _b3.role;
      var menuHidden = this.state.menuHidden;
      var isPrimaryButtonDisabled = disabled || primaryDisabled;
      this._classNames = getClassNames13 ? getClassNames13(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !menuHidden, !!this.props.menuProps, this.props.split, !!allowDisabledFocus) : getBaseButtonClassNames(theme, styles, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, !!this.props.menuProps, checked, !menuHidden, this.props.split);
      var _d3 = this, _ariaDescriptionId = _d3._ariaDescriptionId, _labelId = _d3._labelId, _descriptionId = _d3._descriptionId;
      var renderAsAnchor = !isPrimaryButtonDisabled && !!href;
      var tag = renderAsAnchor ? "a" : "button";
      var nativeProps = getNativeProps(
        // eslint-disable-next-line deprecation/deprecation
        assign(renderAsAnchor ? {} : { type: "button" }, this.props.rootProps, this.props),
        renderAsAnchor ? anchorProperties : buttonProperties,
        [
          "disabled"
          // let disabled buttons be focused and styled as disabled.
        ]
      );
      var resolvedAriaLabel = ariaLabel || nativeProps["aria-label"];
      var ariaDescribedBy = void 0;
      if (ariaDescription) {
        ariaDescribedBy = _ariaDescriptionId;
      } else if (secondaryText && this.props.onRenderDescription !== nullRender) {
        ariaDescribedBy = _descriptionId;
      } else if (nativeProps["aria-describedby"]) {
        ariaDescribedBy = nativeProps["aria-describedby"];
      }
      var ariaLabelledBy = void 0;
      if (nativeProps["aria-labelledby"]) {
        ariaLabelledBy = nativeProps["aria-labelledby"];
      } else if (ariaDescribedBy && !resolvedAriaLabel) {
        ariaLabelledBy = this._hasText() ? _labelId : void 0;
      }
      var dataIsFocusable = this.props["data-is-focusable"] === false || disabled && !allowDisabledFocus || this._isSplitButton ? false : true;
      var isCheckboxTypeRole = role === "menuitemcheckbox" || role === "checkbox";
      var checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : void 0;
      var buttonProps = assign(nativeProps, (_a5 = {
        className: this._classNames.root,
        // eslint-disable-next-line deprecation/deprecation
        ref: this._mergedRef(this.props.elementRef, this._buttonElement),
        disabled: isPrimaryButtonDisabled && !allowDisabledFocus,
        onKeyDown: this._onKeyDown,
        onKeyPress: this._onKeyPress,
        onKeyUp: this._onKeyUp,
        onMouseDown: this._onMouseDown,
        onMouseUp: this._onMouseUp,
        onClick: this._onClick,
        "aria-label": resolvedAriaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy,
        "aria-disabled": isPrimaryButtonDisabled,
        "data-is-focusable": dataIsFocusable
      }, // aria-pressed attribute should only be present for toggle buttons
      // aria-checked attribute should only be present for toggle buttons with checkbox type role
      _a5[isCheckboxTypeRole ? "aria-checked" : "aria-pressed"] = checkedOrPressedValue, _a5));
      if (ariaHidden) {
        buttonProps["aria-hidden"] = true;
      }
      if (this._isSplitButton) {
        return this._onRenderSplitButtonContent(tag, buttonProps);
      } else if (this.props.menuProps) {
        var _e2 = this.props.menuProps.id, id = _e2 === void 0 ? "".concat(this._labelId, "-menu") : _e2;
        assign(buttonProps, {
          "aria-expanded": !menuHidden,
          "aria-controls": !menuHidden ? id : null,
          "aria-haspopup": true
        });
      }
      return this._onRenderContent(tag, buttonProps);
    };
    BaseButton2.prototype.componentDidMount = function() {
      if (this._isSplitButton && this._splitButtonContainer.current) {
        if ("onpointerdown" in this._splitButtonContainer.current) {
          this._events.on(this._splitButtonContainer.current, "pointerdown", this._onPointerDown, true);
        }
        if ("onpointerup" in this._splitButtonContainer.current && this.props.onPointerUp) {
          this._events.on(this._splitButtonContainer.current, "pointerup", this.props.onPointerUp, true);
        }
      }
    };
    BaseButton2.prototype.componentDidUpdate = function(prevProps, prevState) {
      if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {
        this.props.onAfterMenuDismiss();
      }
    };
    BaseButton2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    BaseButton2.prototype.focus = function() {
      var _a5, _b3;
      if (this._isSplitButton && this._splitButtonContainer.current) {
        setFocusVisibility(true, void 0, (_a5 = this.context) === null || _a5 === void 0 ? void 0 : _a5.registeredProviders);
        this._splitButtonContainer.current.focus();
      } else if (this._buttonElement.current) {
        setFocusVisibility(true, void 0, (_b3 = this.context) === null || _b3 === void 0 ? void 0 : _b3.registeredProviders);
        this._buttonElement.current.focus();
      }
    };
    BaseButton2.prototype.dismissMenu = function() {
      this._dismissMenu();
    };
    BaseButton2.prototype.openMenu = function(shouldFocusOnContainer, shouldFocusOnMount) {
      this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);
    };
    BaseButton2.prototype._onRenderContent = function(tag, buttonProps) {
      var _this = this;
      var props = this.props;
      var Tag = tag;
      var menuIconProps = props.menuIconProps, menuProps = props.menuProps, _a5 = props.onRenderIcon, onRenderIcon = _a5 === void 0 ? this._onRenderIcon : _a5, _b3 = props.onRenderAriaDescription, onRenderAriaDescription = _b3 === void 0 ? this._onRenderAriaDescription : _b3, _c3 = props.onRenderChildren, onRenderChildren = _c3 === void 0 ? this._onRenderChildren : _c3, _d3 = props.onRenderMenu, onRenderMenu = _d3 === void 0 ? this._onRenderMenu : _d3, _e2 = props.onRenderMenuIcon, onRenderMenuIcon = _e2 === void 0 ? this._onRenderMenuIcon : _e2, disabled = props.disabled;
      var keytipProps = props.keytipProps;
      if (keytipProps && menuProps) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      var Button2 = function(keytipAttributes) {
        return React29.createElement(
          Tag,
          __assign({}, buttonProps, keytipAttributes),
          React29.createElement(
            "span",
            { className: _this._classNames.flexContainer, "data-automationid": "splitbuttonprimary" },
            onRenderIcon(props, _this._onRenderIcon),
            _this._onRenderTextContents(),
            onRenderAriaDescription(props, _this._onRenderAriaDescription),
            onRenderChildren(props, _this._onRenderChildren),
            !_this._isSplitButton && (menuProps || menuIconProps || _this.props.onRenderMenuIcon) && onRenderMenuIcon(_this.props, _this._onRenderMenuIcon),
            menuProps && !menuProps.doNotLayer && _this._shouldRenderMenu() && onRenderMenu(_this._getMenuProps(menuProps), _this._onRenderMenu)
          )
        );
      };
      var Content = keytipProps ? (
        // If we're making a split button, we won't put the keytip here
        React29.createElement(KeytipData, { keytipProps: !this._isSplitButton ? keytipProps : void 0, ariaDescribedBy: buttonProps["aria-describedby"], disabled }, function(keytipAttributes) {
          return Button2(keytipAttributes);
        })
      ) : Button2();
      if (menuProps && menuProps.doNotLayer) {
        return React29.createElement(
          React29.Fragment,
          null,
          Content,
          this._shouldRenderMenu() && onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu)
        );
      }
      return React29.createElement(
        React29.Fragment,
        null,
        Content,
        React29.createElement(FocusRects, null)
      );
    };
    BaseButton2.prototype._shouldRenderMenu = function() {
      var menuHidden = this.state.menuHidden;
      var _a5 = this.props, persistMenu = _a5.persistMenu, renderPersistedMenuHiddenOnMount = _a5.renderPersistedMenuHiddenOnMount;
      if (!menuHidden) {
        return true;
      } else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {
        return true;
      }
      return false;
    };
    BaseButton2.prototype._hasText = function() {
      return this.props.text !== null && (this.props.text !== void 0 || typeof this.props.children === "string");
    };
    BaseButton2.prototype._getMenuProps = function(menuProps) {
      var persistMenu = this.props.persistMenu;
      var menuHidden = this.state.menuHidden;
      if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {
        menuProps = __assign(__assign({}, menuProps), { labelElementId: this._labelId });
      }
      return __assign(__assign({ id: this._labelId + "-menu", directionalHint: DirectionalHint.bottomLeftEdge }, menuProps), { shouldFocusOnContainer: this._menuShouldFocusOnContainer, shouldFocusOnMount: this._menuShouldFocusOnMount, hidden: persistMenu ? menuHidden : void 0, className: css("ms-BaseButton-menuhost", menuProps.className), target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current, onDismiss: this._onDismissMenu });
    };
    BaseButton2.prototype._onRenderSplitButtonContent = function(tag, buttonProps) {
      var _this = this;
      var _a5 = this.props, _b3 = _a5.styles, styles = _b3 === void 0 ? {} : _b3, disabled = _a5.disabled, allowDisabledFocus = _a5.allowDisabledFocus, checked = _a5.checked, getSplitButtonClassNames2 = _a5.getSplitButtonClassNames, primaryDisabled = _a5.primaryDisabled, menuProps = _a5.menuProps, toggle = _a5.toggle, role = _a5.role, primaryActionButtonProps = _a5.primaryActionButtonProps;
      var keytipProps = this.props.keytipProps;
      var menuHidden = this.state.menuHidden;
      var classNames2 = getSplitButtonClassNames2 ? getSplitButtonClassNames2(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus) : styles && getSplitButtonClassNames(styles, !!disabled, !menuHidden, !!checked, !!primaryDisabled);
      assign(buttonProps, {
        onClick: void 0,
        onPointerDown: void 0,
        onPointerUp: void 0,
        tabIndex: -1,
        "data-is-focusable": false
      });
      if (keytipProps && menuProps) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      var containerProps = getNativeProps(buttonProps, [], ["disabled"]);
      if (primaryActionButtonProps) {
        assign(buttonProps, primaryActionButtonProps);
      }
      var SplitButton = function(keytipAttributes) {
        return React29.createElement(
          "div",
          __assign({}, containerProps, { "data-ktp-target": keytipAttributes ? keytipAttributes["data-ktp-target"] : void 0, role: role ? role : "button", "aria-disabled": disabled, "aria-haspopup": true, "aria-expanded": !menuHidden, "aria-pressed": toggle ? !!checked : void 0, "aria-describedby": mergeAriaAttributeValues(buttonProps["aria-describedby"], keytipAttributes ? keytipAttributes["aria-describedby"] : void 0), className: classNames2 && classNames2.splitButtonContainer, onKeyDown: _this._onSplitButtonContainerKeyDown, onTouchStart: _this._onTouchStart, ref: _this._splitButtonContainer, "data-is-focusable": true, onClick: !disabled && !primaryDisabled ? _this._onSplitButtonPrimaryClick : void 0, tabIndex: !disabled && !primaryDisabled || allowDisabledFocus ? 0 : void 0, "aria-roledescription": buttonProps["aria-roledescription"], onFocusCapture: _this._onSplitContainerFocusCapture }),
          React29.createElement(
            "span",
            { style: { display: "flex", width: "100%" } },
            _this._onRenderContent(tag, buttonProps),
            _this._onRenderSplitButtonMenuButton(classNames2, keytipAttributes),
            _this._onRenderSplitButtonDivider(classNames2)
          )
        );
      };
      return keytipProps ? React29.createElement(KeytipData, { keytipProps, disabled }, function(keytipAttributes) {
        return SplitButton(keytipAttributes);
      }) : SplitButton();
    };
    BaseButton2.prototype._onRenderSplitButtonDivider = function(classNames2) {
      if (classNames2 && classNames2.divider) {
        var onClick = function(ev) {
          ev.stopPropagation();
        };
        return React29.createElement("span", { className: classNames2.divider, "aria-hidden": true, onClick });
      }
      return null;
    };
    BaseButton2.prototype._onRenderSplitButtonMenuButton = function(classNames2, keytipAttributes) {
      var _a5 = this.props, allowDisabledFocus = _a5.allowDisabledFocus, checked = _a5.checked, disabled = _a5.disabled, splitButtonMenuProps = _a5.splitButtonMenuProps, splitButtonAriaLabel = _a5.splitButtonAriaLabel, primaryDisabled = _a5.primaryDisabled;
      var menuHidden = this.state.menuHidden;
      var menuIconProps = this.props.menuIconProps;
      if (menuIconProps === void 0) {
        menuIconProps = {
          iconName: "ChevronDown"
        };
      }
      var splitButtonProps = __assign(__assign({}, splitButtonMenuProps), { styles: classNames2, checked, disabled, allowDisabledFocus, onClick: this._onMenuClick, menuProps: void 0, iconProps: __assign(__assign({}, menuIconProps), { className: this._classNames.menuIcon }), ariaLabel: splitButtonAriaLabel, "aria-haspopup": true, "aria-expanded": !menuHidden, "data-is-focusable": false });
      return React29.createElement(BaseButton2, __assign({}, splitButtonProps, { "data-ktp-execute-target": keytipAttributes ? keytipAttributes["data-ktp-execute-target"] : keytipAttributes, onMouseDown: this._onMouseDown, tabIndex: primaryDisabled && !allowDisabledFocus ? 0 : -1 }));
    };
    BaseButton2.prototype._onPointerDown = function(ev) {
      var onPointerDown = this.props.onPointerDown;
      if (onPointerDown) {
        onPointerDown(ev);
      }
      if (ev.pointerType === "touch") {
        this._handleTouchAndPointerEvent();
        ev.preventDefault();
        ev.stopImmediatePropagation();
      }
    };
    BaseButton2.prototype._handleTouchAndPointerEvent = function() {
      var _this = this;
      if (this._lastTouchTimeoutId !== void 0) {
        this._async.clearTimeout(this._lastTouchTimeoutId);
        this._lastTouchTimeoutId = void 0;
      }
      this._processingTouch = true;
      this._lastTouchTimeoutId = this._async.setTimeout(function() {
        _this._processingTouch = false;
        _this._lastTouchTimeoutId = void 0;
        if (_this.state.menuHidden) {
          _this.focus();
        }
      }, TouchIdleDelay2);
    };
    BaseButton2.prototype._isValidMenuOpenKey = function(ev) {
      if (this.props.menuTriggerKeyCode) {
        return ev.which === this.props.menuTriggerKeyCode;
      } else if (this.props.menuProps) {
        return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);
      }
      return false;
    };
    BaseButton2.defaultProps = {
      baseClassName: "ms-Button",
      styles: {},
      split: false
    };
    BaseButton2.contextType = FocusRectsContext;
    return BaseButton2;
  }(React29.Component)
);

// node_modules/@fluentui/react/lib/components/Button/Button.types.js
var ElementType;
(function(ElementType2) {
  ElementType2[ElementType2["button"] = 0] = "button";
  ElementType2[ElementType2["anchor"] = 1] = "anchor";
})(ElementType || (ElementType = {}));
var ButtonType;
(function(ButtonType2) {
  ButtonType2[ButtonType2["normal"] = 0] = "normal";
  ButtonType2[ButtonType2["primary"] = 1] = "primary";
  ButtonType2[ButtonType2["hero"] = 2] = "hero";
  ButtonType2[ButtonType2["compound"] = 3] = "compound";
  ButtonType2[ButtonType2["command"] = 4] = "command";
  ButtonType2[ButtonType2["icon"] = 5] = "icon";
  ButtonType2[ButtonType2["default"] = 6] = "default";
})(ButtonType || (ButtonType = {}));

// node_modules/@fluentui/react/lib/components/Button/Button.js
var React35 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/DefaultButton/DefaultButton.js
var React30 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/BaseButton.styles.js
var noOutline = {
  outline: 0
};
var iconStyle = function(fontSize) {
  return {
    fontSize,
    margin: "0 4px",
    height: "16px",
    lineHeight: "16px",
    textAlign: "center",
    flexShrink: 0
  };
};
var getStyles8 = memoizeFunction(function(theme) {
  var _a5, _b3;
  var semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
  var border = semanticColors.buttonBorder;
  var disabledBackground = semanticColors.disabledBackground;
  var disabledText = semanticColors.disabledText;
  var buttonHighContrastFocus = {
    left: -2,
    top: -2,
    bottom: -2,
    right: -2,
    outlineColor: "ButtonText"
  };
  return {
    root: [
      getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: "transparent" }),
      theme.fonts.medium,
      {
        border: "1px solid " + border,
        borderRadius: effects.roundedCorner2,
        boxSizing: "border-box",
        cursor: "pointer",
        display: "inline-block",
        padding: "0 16px",
        textDecoration: "none",
        textAlign: "center",
        userSelect: "none",
        selectors: {
          // IE11 workaround for preventing shift of child elements of a button when active.
          ":active > span": {
            position: "relative",
            left: 0,
            top: 0
          }
        }
      }
    ],
    rootDisabled: [
      getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: "transparent" }),
      {
        backgroundColor: disabledBackground,
        borderColor: disabledBackground,
        color: disabledText,
        cursor: "default",
        selectors: {
          ":hover": noOutline,
          ":focus": noOutline
        }
      }
    ],
    iconDisabled: {
      color: disabledText,
      selectors: (_a5 = {}, _a5[HighContrastSelector] = {
        color: "GrayText"
      }, _a5)
    },
    menuIconDisabled: {
      color: disabledText,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        color: "GrayText"
      }, _b3)
    },
    flexContainer: {
      display: "flex",
      height: "100%",
      flexWrap: "nowrap",
      justifyContent: "center",
      alignItems: "center"
    },
    description: {
      display: "block"
    },
    textContainer: {
      flexGrow: 1,
      display: "block"
    },
    icon: iconStyle(fonts.mediumPlus.fontSize),
    menuIcon: iconStyle(fonts.small.fontSize),
    label: {
      margin: "0 4px",
      lineHeight: "100%",
      display: "block"
    },
    screenReaderText: hiddenContentStyle
  };
});

// node_modules/@fluentui/react/lib/components/Button/SplitButton/SplitButton.styles.js
var getStyles9 = memoizeFunction(function(theme, customStyles) {
  var _a5, _b3, _c3, _d3, _e2, _f, _g, _h, _j, _k, _l, _m, _o;
  var effects = theme.effects, palette = theme.palette, semanticColors = theme.semanticColors;
  var buttonHighContrastFocus = {
    left: -2,
    top: -2,
    bottom: -2,
    right: -2,
    border: "none"
  };
  var splitButtonDividerBaseStyles2 = {
    position: "absolute",
    width: 1,
    right: 31,
    top: 8,
    bottom: 8
  };
  var splitButtonStyles = {
    splitButtonContainer: [
      getFocusStyle(theme, { highContrastStyle: buttonHighContrastFocus, inset: 2, pointerEvents: "none" }),
      {
        display: "inline-flex",
        selectors: {
          ".ms-Button--default": {
            borderTopRightRadius: "0",
            borderBottomRightRadius: "0",
            borderRight: "none",
            flexGrow: "1"
          },
          ".ms-Button--primary": {
            borderTopRightRadius: "0",
            borderBottomRightRadius: "0",
            border: "none",
            flexGrow: "1",
            selectors: (_a5 = {}, _a5[HighContrastSelector] = __assign({ color: "WindowText", backgroundColor: "Window", border: "1px solid WindowText", borderRightWidth: "0" }, getHighContrastNoAdjustStyle()), _a5[":hover"] = {
              border: "none"
            }, _a5[":active"] = {
              border: "none"
            }, _a5)
          },
          ".ms-Button--primary + .ms-Button": {
            border: "none",
            selectors: (_b3 = {}, _b3[HighContrastSelector] = {
              border: "1px solid WindowText",
              borderLeftWidth: "0"
            }, _b3)
          }
        }
      }
    ],
    splitButtonContainerHovered: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_c3 = {}, _c3[HighContrastSelector] = {
            color: "Window",
            backgroundColor: "Highlight"
          }, _c3)
        },
        ".ms-Button.is-disabled": {
          color: semanticColors.buttonTextDisabled,
          selectors: (_d3 = {}, _d3[HighContrastSelector] = {
            color: "GrayText",
            borderColor: "GrayText",
            backgroundColor: "Window"
          }, _d3)
        }
      }
    },
    splitButtonContainerChecked: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_e2 = {}, _e2[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _e2)
        }
      }
    },
    splitButtonContainerCheckedHovered: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_f = {}, _f[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _f)
        }
      }
    },
    splitButtonContainerFocused: {
      outline: "none!important"
    },
    splitButtonMenuButton: (_g = {
      padding: 6,
      height: "auto",
      boxSizing: "border-box",
      borderRadius: 0,
      borderTopRightRadius: effects.roundedCorner2,
      borderBottomRightRadius: effects.roundedCorner2,
      border: "1px solid ".concat(palette.neutralSecondaryAlt),
      borderLeft: "none",
      outline: "transparent",
      userSelect: "none",
      display: "inline-block",
      textDecoration: "none",
      textAlign: "center",
      cursor: "pointer",
      verticalAlign: "top",
      width: 32,
      marginLeft: -1,
      marginTop: 0,
      marginRight: 0,
      marginBottom: 0
    }, _g[HighContrastSelector] = {
      ".ms-Button-menuIcon": {
        color: "WindowText"
      }
    }, _g),
    splitButtonDivider: __assign(__assign({}, splitButtonDividerBaseStyles2), { selectors: (_h = {}, _h[HighContrastSelector] = {
      backgroundColor: "WindowText"
    }, _h) }),
    splitButtonDividerDisabled: __assign(__assign({}, splitButtonDividerBaseStyles2), { selectors: (_j = {}, _j[HighContrastSelector] = {
      backgroundColor: "GrayText"
    }, _j) }),
    splitButtonMenuButtonDisabled: {
      pointerEvents: "none",
      border: "none",
      selectors: (_k = {
        ":hover": {
          cursor: "default"
        },
        ".ms-Button--primary": {
          selectors: (_l = {}, _l[HighContrastSelector] = {
            color: "GrayText",
            borderColor: "GrayText",
            backgroundColor: "Window"
          }, _l)
        },
        ".ms-Button-menuIcon": {
          selectors: (_m = {}, _m[HighContrastSelector] = {
            color: "GrayText"
          }, _m)
        }
      }, _k[HighContrastSelector] = {
        color: "GrayText",
        border: "1px solid GrayText",
        backgroundColor: "Window"
      }, _k)
    },
    splitButtonFlexContainer: {
      display: "flex",
      height: "100%",
      flexWrap: "nowrap",
      justifyContent: "center",
      alignItems: "center"
    },
    splitButtonContainerDisabled: {
      outline: "none",
      border: "none",
      selectors: (_o = {}, _o[HighContrastSelector] = __assign({ color: "GrayText", borderColor: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _o)
    },
    splitButtonMenuFocused: __assign({}, getFocusStyle(theme, { highContrastStyle: buttonHighContrastFocus, inset: 2 }))
  };
  return concatStyleSets(splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/ButtonThemes.js
var splitButtonDividerBaseStyles = function() {
  return {
    position: "absolute",
    width: 1,
    right: 31,
    top: 8,
    bottom: 8
  };
};
function standardStyles(theme) {
  var _a5, _b3, _c3, _d3, _e2;
  var s = theme.semanticColors, p = theme.palette;
  var buttonBackground = s.buttonBackground;
  var buttonBackgroundPressed = s.buttonBackgroundPressed;
  var buttonBackgroundHovered = s.buttonBackgroundHovered;
  var buttonBackgroundDisabled = s.buttonBackgroundDisabled;
  var buttonText = s.buttonText;
  var buttonTextHovered = s.buttonTextHovered;
  var buttonTextDisabled = s.buttonTextDisabled;
  var buttonTextChecked = s.buttonTextChecked;
  var buttonTextCheckedHovered = s.buttonTextCheckedHovered;
  return {
    root: {
      backgroundColor: buttonBackground,
      color: buttonText
    },
    rootHovered: {
      backgroundColor: buttonBackgroundHovered,
      color: buttonTextHovered,
      selectors: (_a5 = {}, _a5[HighContrastSelector] = {
        borderColor: "Highlight",
        color: "Highlight"
      }, _a5)
    },
    rootPressed: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootExpanded: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootChecked: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootCheckedHovered: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextCheckedHovered
    },
    rootDisabled: {
      color: buttonTextDisabled,
      backgroundColor: buttonBackgroundDisabled,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        color: "GrayText",
        borderColor: "GrayText",
        backgroundColor: "Window"
      }, _b3)
    },
    // Split button styles
    splitButtonContainer: {
      selectors: (_c3 = {}, _c3[HighContrastSelector] = {
        border: "none"
      }, _c3)
    },
    splitButtonMenuButton: {
      color: p.white,
      backgroundColor: "transparent",
      selectors: {
        ":hover": {
          backgroundColor: p.neutralLight,
          selectors: (_d3 = {}, _d3[HighContrastSelector] = {
            color: "Highlight"
          }, _d3)
        }
      }
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: s.buttonBackgroundDisabled,
      selectors: {
        ":hover": {
          backgroundColor: s.buttonBackgroundDisabled
        }
      }
    },
    splitButtonDivider: __assign(__assign({}, splitButtonDividerBaseStyles()), { backgroundColor: p.neutralTertiaryAlt, selectors: (_e2 = {}, _e2[HighContrastSelector] = {
      backgroundColor: "WindowText"
    }, _e2) }),
    splitButtonDividerDisabled: {
      backgroundColor: theme.palette.neutralTertiaryAlt
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuIcon: {
      color: s.buttonText
    },
    splitButtonMenuIconDisabled: {
      color: s.buttonTextDisabled
    }
  };
}
function primaryStyles(theme) {
  var _a5, _b3, _c3, _d3, _e2, _f, _g, _h, _j;
  var p = theme.palette, s = theme.semanticColors;
  return {
    root: {
      backgroundColor: s.primaryButtonBackground,
      border: "1px solid ".concat(s.primaryButtonBackground),
      color: s.primaryButtonText,
      selectors: (_a5 = {}, _a5[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText", borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _a5[".".concat(IsFocusVisibleClassName, " &:focus")] = {
        selectors: {
          ":after": {
            border: "none",
            outlineColor: p.white
          }
        }
      }, _a5)
    },
    rootHovered: {
      backgroundColor: s.primaryButtonBackgroundHovered,
      border: "1px solid ".concat(s.primaryButtonBackgroundHovered),
      color: s.primaryButtonTextHovered,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        color: "Window",
        backgroundColor: "Highlight",
        borderColor: "Highlight"
      }, _b3)
    },
    rootPressed: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      border: "1px solid ".concat(s.primaryButtonBackgroundPressed),
      color: s.primaryButtonTextPressed,
      selectors: (_c3 = {}, _c3[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText", borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _c3)
    },
    rootExpanded: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootChecked: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootCheckedHovered: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootDisabled: {
      color: s.primaryButtonTextDisabled,
      backgroundColor: s.primaryButtonBackgroundDisabled,
      selectors: (_d3 = {}, _d3[HighContrastSelector] = {
        color: "GrayText",
        borderColor: "GrayText",
        backgroundColor: "Window"
      }, _d3)
    },
    // Split button styles
    splitButtonContainer: {
      selectors: (_e2 = {}, _e2[HighContrastSelector] = {
        border: "none"
      }, _e2)
    },
    splitButtonDivider: __assign(__assign({}, splitButtonDividerBaseStyles()), { backgroundColor: p.white, selectors: (_f = {}, _f[HighContrastSelector] = {
      backgroundColor: "Window"
    }, _f) }),
    splitButtonMenuButton: {
      backgroundColor: s.primaryButtonBackground,
      color: s.primaryButtonText,
      selectors: (_g = {}, _g[HighContrastSelector] = {
        backgroundColor: "Canvas"
      }, _g[":hover"] = {
        backgroundColor: s.primaryButtonBackgroundHovered,
        selectors: (_h = {}, _h[HighContrastSelector] = {
          color: "Highlight"
        }, _h)
      }, _g)
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: s.primaryButtonBackgroundDisabled,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundDisabled
        }
      }
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundPressed
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundPressed
        }
      }
    },
    splitButtonMenuIcon: {
      color: s.primaryButtonText
    },
    splitButtonMenuIconDisabled: {
      color: p.neutralTertiary,
      selectors: (_j = {}, _j[HighContrastSelector] = {
        color: "GrayText"
      }, _j)
    }
  };
}

// node_modules/@fluentui/react/lib/components/Button/DefaultButton/DefaultButton.styles.js
var DEFAULT_BUTTON_HEIGHT = "32px";
var DEFAULT_BUTTON_MIN_WIDTH = "80px";
var getStyles10 = memoizeFunction(function(theme, customStyles, primary) {
  var baseButtonStyles = getStyles8(theme);
  var splitButtonStyles = getStyles9(theme);
  var defaultButtonStyles = {
    root: {
      minWidth: DEFAULT_BUTTON_MIN_WIDTH,
      height: DEFAULT_BUTTON_HEIGHT
    },
    label: {
      fontWeight: FontWeights.semibold
    }
  };
  return concatStyleSets(baseButtonStyles, defaultButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/DefaultButton/DefaultButton.js
var DefaultButton = (
  /** @class */
  function(_super) {
    __extends(DefaultButton2, _super);
    function DefaultButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultButton2.prototype.render = function() {
      var _a5 = this.props, _b3 = _a5.primary, primary = _b3 === void 0 ? false : _b3, styles = _a5.styles, theme = _a5.theme;
      return React30.createElement(BaseButton, __assign({}, this.props, { variantClassName: primary ? "ms-Button--primary" : "ms-Button--default", styles: getStyles10(theme, styles, primary), onRenderDescription: nullRender }));
    };
    DefaultButton2 = __decorate([
      customizable("DefaultButton", ["theme", "styles"], true)
    ], DefaultButton2);
    return DefaultButton2;
  }(React30.Component)
);

// node_modules/@fluentui/react/lib/components/Button/ActionButton/ActionButton.js
var React31 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/ActionButton/ActionButton.styles.js
var DEFAULT_BUTTON_HEIGHT2 = "40px";
var DEFAULT_PADDING = "0 4px";
var getStyles11 = memoizeFunction(function(theme, customStyles) {
  var _a5, _b3, _c3;
  var baseButtonStyles = getStyles8(theme);
  var actionButtonStyles = {
    root: {
      padding: DEFAULT_PADDING,
      height: DEFAULT_BUTTON_HEIGHT2,
      color: theme.palette.neutralPrimary,
      backgroundColor: "transparent",
      border: "1px solid transparent",
      selectors: (_a5 = {}, _a5[HighContrastSelector] = {
        borderColor: "Window"
      }, _a5)
    },
    rootHovered: {
      color: theme.palette.themePrimary,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        color: "Highlight"
      }, _b3)
    },
    iconHovered: {
      color: theme.palette.themePrimary
    },
    rootPressed: {
      color: theme.palette.black
    },
    rootExpanded: {
      color: theme.palette.themePrimary
    },
    iconPressed: {
      color: theme.palette.themeDarker
    },
    rootDisabled: {
      color: theme.palette.neutralTertiary,
      backgroundColor: "transparent",
      borderColor: "transparent",
      selectors: (_c3 = {}, _c3[HighContrastSelector] = {
        color: "GrayText"
      }, _c3)
    },
    rootChecked: {
      color: theme.palette.black
    },
    iconChecked: {
      color: theme.palette.themeDarker
    },
    flexContainer: {
      justifyContent: "flex-start"
    },
    icon: {
      color: theme.palette.themeDarkAlt
    },
    iconDisabled: {
      color: "inherit"
    },
    menuIcon: {
      color: theme.palette.neutralSecondary
    },
    textContainer: {
      flexGrow: 0
    }
  };
  return concatStyleSets(baseButtonStyles, actionButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/ActionButton/ActionButton.js
var ActionButton = (
  /** @class */
  function(_super) {
    __extends(ActionButton2, _super);
    function ActionButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ActionButton2.prototype.render = function() {
      var _a5 = this.props, styles = _a5.styles, theme = _a5.theme;
      return React31.createElement(BaseButton, __assign({}, this.props, { variantClassName: "ms-Button--action ms-Button--command", styles: getStyles11(theme, styles), onRenderDescription: nullRender }));
    };
    ActionButton2 = __decorate([
      customizable("ActionButton", ["theme", "styles"], true)
    ], ActionButton2);
    return ActionButton2;
  }(React31.Component)
);

// node_modules/@fluentui/react/lib/components/Button/CompoundButton/CompoundButton.js
var React32 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/CompoundButton/CompoundButton.styles.js
var getStyles12 = memoizeFunction(function(theme, customStyles, primary) {
  var _a5, _b3, _c3, _d3, _e2;
  var fonts = theme.fonts, palette = theme.palette;
  var baseButtonStyles = getStyles8(theme);
  var splitButtonStyles = getStyles9(theme);
  var compoundButtonStyles = {
    root: {
      maxWidth: "280px",
      minHeight: "72px",
      height: "auto",
      padding: "16px 12px"
    },
    flexContainer: {
      flexDirection: "row",
      alignItems: "flex-start",
      minWidth: "100%",
      margin: ""
    },
    textContainer: {
      textAlign: "left"
    },
    icon: {
      fontSize: "2em",
      lineHeight: "1em",
      height: "1em",
      margin: "0px 8px 0px 0px",
      flexBasis: "1em",
      flexShrink: "0"
    },
    label: {
      margin: "0 0 5px",
      lineHeight: "100%",
      fontWeight: FontWeights.semibold
    },
    description: [
      fonts.small,
      {
        lineHeight: "100%"
      }
    ]
  };
  var standardCompoundTheme = {
    description: {
      color: palette.neutralSecondary
    },
    descriptionHovered: {
      color: palette.neutralDark
    },
    descriptionPressed: {
      color: "inherit"
    },
    descriptionChecked: {
      color: "inherit"
    },
    descriptionDisabled: {
      color: "inherit"
    }
  };
  var primaryCompoundTheme = {
    description: {
      color: palette.white,
      selectors: (_a5 = {}, _a5[HighContrastSelector] = __assign({ backgroundColor: "WindowText", color: "Window" }, getHighContrastNoAdjustStyle()), _a5)
    },
    descriptionHovered: {
      color: palette.white,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        backgroundColor: "Highlight",
        color: "Window"
      }, _b3)
    },
    descriptionPressed: {
      color: "inherit",
      selectors: (_c3 = {}, _c3[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _c3)
    },
    descriptionChecked: {
      color: "inherit",
      selectors: (_d3 = {}, _d3[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _d3)
    },
    descriptionDisabled: {
      color: "inherit",
      selectors: (_e2 = {}, _e2[HighContrastSelector] = {
        color: "inherit"
      }, _e2)
    }
  };
  return concatStyleSets(baseButtonStyles, compoundButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), primary ? primaryCompoundTheme : standardCompoundTheme, splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/CompoundButton/CompoundButton.js
var CompoundButton = (
  /** @class */
  function(_super) {
    __extends(CompoundButton2, _super);
    function CompoundButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CompoundButton2.prototype.render = function() {
      var _a5 = this.props, _b3 = _a5.primary, primary = _b3 === void 0 ? false : _b3, styles = _a5.styles, theme = _a5.theme;
      return React32.createElement(BaseButton, __assign({}, this.props, { variantClassName: primary ? "ms-Button--compoundPrimary" : "ms-Button--compound", styles: getStyles12(theme, styles, primary) }));
    };
    CompoundButton2 = __decorate([
      customizable("CompoundButton", ["theme", "styles"], true)
    ], CompoundButton2);
    return CompoundButton2;
  }(React32.Component)
);

// node_modules/@fluentui/react/lib/components/Button/IconButton/IconButton.js
var React33 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/IconButton/IconButton.styles.js
var getStyles13 = memoizeFunction(function(theme, customStyles) {
  var _a5;
  var baseButtonStyles = getStyles8(theme);
  var splitButtonStyles = getStyles9(theme);
  var palette = theme.palette, semanticColors = theme.semanticColors;
  var iconButtonStyles = {
    root: {
      padding: "0 4px",
      width: "32px",
      height: "32px",
      backgroundColor: "transparent",
      border: "none",
      color: semanticColors.link
    },
    rootHovered: {
      color: palette.themeDarkAlt,
      backgroundColor: palette.neutralLighter,
      selectors: (_a5 = {}, _a5[HighContrastSelector] = {
        borderColor: "Highlight",
        color: "Highlight"
      }, _a5)
    },
    rootHasMenu: {
      width: "auto"
    },
    rootPressed: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootExpanded: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootChecked: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootCheckedHovered: {
      color: palette.themeDark,
      backgroundColor: palette.neutralQuaternaryAlt
    },
    rootDisabled: {
      color: palette.neutralTertiaryAlt
    }
  };
  return concatStyleSets(baseButtonStyles, iconButtonStyles, splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/IconButton/IconButton.js
var IconButton = (
  /** @class */
  function(_super) {
    __extends(IconButton2, _super);
    function IconButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IconButton2.prototype.render = function() {
      var _a5 = this.props, styles = _a5.styles, theme = _a5.theme;
      return React33.createElement(BaseButton, __assign({}, this.props, { variantClassName: "ms-Button--icon", styles: getStyles13(theme, styles), onRenderText: nullRender, onRenderDescription: nullRender }));
    };
    IconButton2 = __decorate([
      customizable("IconButton", ["theme", "styles"], true)
    ], IconButton2);
    return IconButton2;
  }(React33.Component)
);

// node_modules/@fluentui/react/lib/components/Button/PrimaryButton/PrimaryButton.js
var React34 = __toESM(require_react());
var PrimaryButton = (
  /** @class */
  function(_super) {
    __extends(PrimaryButton2, _super);
    function PrimaryButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PrimaryButton2.prototype.render = function() {
      return React34.createElement(DefaultButton, __assign({}, this.props, { primary: true, onRenderDescription: nullRender }));
    };
    PrimaryButton2 = __decorate([
      customizable("PrimaryButton", ["theme", "styles"], true)
    ], PrimaryButton2);
    return PrimaryButton2;
  }(React34.Component)
);

// node_modules/@fluentui/react/lib/components/Button/Button.js
var Button = (
  /** @class */
  function(_super) {
    __extends(Button2, _super);
    function Button2(props) {
      var _this = _super.call(this, props) || this;
      warn("The Button component has been deprecated. Use specific variants instead. (PrimaryButton, DefaultButton, IconButton, ActionButton, etc.)");
      return _this;
    }
    Button2.prototype.render = function() {
      var props = this.props;
      switch (props.buttonType) {
        case ButtonType.command:
          return React35.createElement(ActionButton, __assign({}, props));
        case ButtonType.compound:
          return React35.createElement(CompoundButton, __assign({}, props));
        case ButtonType.icon:
          return React35.createElement(IconButton, __assign({}, props));
        case ButtonType.primary:
          return React35.createElement(PrimaryButton, __assign({}, props));
        default:
          return React35.createElement(DefaultButton, __assign({}, props));
      }
    };
    return Button2;
  }(React35.Component)
);

// node_modules/@fluentui/react/lib/components/Button/CommandBarButton/CommandBarButton.js
var React36 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/CommandBarButton/CommandBarButton.styles.js
var getStyles14 = memoizeFunction(function(theme, customStyles, focusInset, focusColor) {
  var _a5, _b3, _c3, _d3, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p;
  var baseButtonStyles = getStyles8(theme);
  var baseSplitButtonStyles = getStyles9(theme);
  var p = theme.palette, semanticColors = theme.semanticColors;
  var commandButtonHighContrastFocus = {
    left: 4,
    top: 4,
    bottom: 4,
    right: 4,
    border: "none"
  };
  var commandButtonStyles = {
    root: [
      getFocusStyle(theme, {
        inset: 2,
        highContrastStyle: commandButtonHighContrastFocus,
        borderColor: "transparent"
      }),
      theme.fonts.medium,
      {
        minWidth: "40px",
        backgroundColor: p.white,
        color: p.neutralPrimary,
        padding: "0 4px",
        border: "none",
        borderRadius: 0,
        selectors: (_a5 = {}, _a5[HighContrastSelector] = {
          border: "none"
        }, _a5)
      }
    ],
    rootHovered: {
      backgroundColor: p.neutralLighter,
      color: p.neutralDark,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        color: "Highlight"
      }, _b3[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDarkAlt
      }, _b3[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _b3)
    },
    rootPressed: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_c3 = {}, _c3[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDark
      }, _c3[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _c3)
    },
    rootChecked: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_d3 = {}, _d3[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDark
      }, _d3[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _d3)
    },
    rootCheckedHovered: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: (_e2 = {}, _e2[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDark
      }, _e2[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _e2)
    },
    rootExpanded: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_f = {}, _f[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDark
      }, _f[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _f)
    },
    rootExpandedHovered: {
      backgroundColor: p.neutralQuaternaryAlt
    },
    rootDisabled: {
      backgroundColor: p.white,
      selectors: (_g = {}, _g[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: semanticColors.disabledBodySubtext,
        selectors: (_h = {}, _h[HighContrastSelector] = __assign({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _h)
      }, _g[HighContrastSelector] = __assign({ color: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _g)
    },
    // Split button styles
    splitButtonContainer: {
      height: "100%",
      selectors: (_j = {}, _j[HighContrastSelector] = {
        border: "none"
      }, _j)
    },
    splitButtonDividerDisabled: {
      selectors: (_k = {}, _k[HighContrastSelector] = {
        backgroundColor: "Window"
      }, _k)
    },
    splitButtonDivider: {
      backgroundColor: p.neutralTertiaryAlt
    },
    splitButtonMenuButton: {
      backgroundColor: p.white,
      border: "none",
      borderTopRightRadius: "0",
      borderBottomRightRadius: "0",
      color: p.neutralSecondary,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralLighter,
          color: p.neutralDark,
          selectors: (_l = {}, _l[HighContrastSelector] = {
            color: "Highlight"
          }, _l[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
            color: p.neutralPrimary
          }, _l)
        },
        ":active": {
          backgroundColor: p.neutralLight,
          selectors: (_m = {}, _m[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
            color: p.neutralPrimary
          }, _m)
        }
      }
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: p.white,
      selectors: (_o = {}, _o[HighContrastSelector] = __assign({ color: "GrayText", border: "none", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _o)
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: p.neutralLight,
      color: p.black,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuIcon: {
      color: p.neutralPrimary
    },
    splitButtonMenuIconDisabled: {
      color: p.neutralTertiary
    },
    label: {
      fontWeight: "normal"
      // theme.fontWeights.semibold,
    },
    icon: {
      color: p.themePrimary
    },
    menuIcon: (_p = {
      color: p.neutralSecondary
    }, _p[HighContrastSelector] = {
      color: "GrayText"
    }, _p)
  };
  return concatStyleSets(baseButtonStyles, baseSplitButtonStyles, commandButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/CommandBarButton/CommandBarButton.js
var CommandBarButton = (
  /** @class */
  function(_super) {
    __extends(CommandBarButton2, _super);
    function CommandBarButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CommandBarButton2.prototype.render = function() {
      var _a5 = this.props, styles = _a5.styles, theme = _a5.theme;
      return React36.createElement(BaseButton, __assign({}, this.props, { variantClassName: "ms-Button--commandBar", styles: getStyles14(theme, styles), onRenderDescription: nullRender }));
    };
    CommandBarButton2 = __decorate([
      customizable("CommandBarButton", ["theme", "styles"], true)
    ], CommandBarButton2);
    return CommandBarButton2;
  }(React36.Component)
);

// node_modules/@fluentui/react/lib/components/Button/CommandButton/CommandButton.js
var CommandButton = ActionButton;

// node_modules/@fluentui/react/lib/components/Button/MessageBarButton/MessageBarButton.js
var React37 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/MessageBarButton/MessageBarButton.styles.js
var getStyles15 = memoizeFunction(function(theme, customStyles) {
  return concatStyleSets({
    root: [
      getFocusStyle(theme, {
        inset: 1,
        highContrastStyle: {
          outlineOffset: "-4px",
          outline: "1px solid Window"
        },
        borderColor: "transparent"
      }),
      {
        height: 24
      }
    ]
  }, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/MessageBarButton/MessageBarButton.js
var MessageBarButton = (
  /** @class */
  function(_super) {
    __extends(MessageBarButton2, _super);
    function MessageBarButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MessageBarButton2.prototype.render = function() {
      var _a5 = this.props, styles = _a5.styles, theme = _a5.theme;
      return React37.createElement(DefaultButton, __assign({}, this.props, { styles: getStyles15(theme, styles), onRenderDescription: nullRender }));
    };
    MessageBarButton2 = __decorate([
      customizable("MessageBarButton", ["theme", "styles"], true)
    ], MessageBarButton2);
    return MessageBarButton2;
  }(React37.Component)
);

// node_modules/@fluentui/react/lib/utilities/selectableOption/SelectableOption.js
function getAllSelectedOptions(options, selectedIndices) {
  var selectedOptions = [];
  for (var _i = 0, selectedIndices_1 = selectedIndices; _i < selectedIndices_1.length; _i++) {
    var index = selectedIndices_1[_i];
    var option = options[index];
    if (option) {
      selectedOptions.push(option);
    }
  }
  return selectedOptions;
}

// node_modules/@fluentui/react/lib/utilities/selectableOption/SelectableOption.types.js
var SelectableOptionMenuItemType;
(function(SelectableOptionMenuItemType2) {
  SelectableOptionMenuItemType2[SelectableOptionMenuItemType2["Normal"] = 0] = "Normal";
  SelectableOptionMenuItemType2[SelectableOptionMenuItemType2["Divider"] = 1] = "Divider";
  SelectableOptionMenuItemType2[SelectableOptionMenuItemType2["Header"] = 2] = "Header";
  SelectableOptionMenuItemType2[SelectableOptionMenuItemType2["SelectAll"] = 3] = "SelectAll";
})(SelectableOptionMenuItemType || (SelectableOptionMenuItemType = {}));

// node_modules/@fluentui/react/lib/components/Dropdown/utilities/DropdownSizePosCache.js
var DropdownSizePosCache = (
  /** @class */
  function() {
    function DropdownSizePosCache2() {
      this._size = 0;
    }
    DropdownSizePosCache2.prototype.updateOptions = function(options) {
      var displayOnlyOptionsCache = [];
      var notSelectableOptionsCache = [];
      var size = 0;
      for (var i = 0; i < options.length; i++) {
        var _a5 = options[i], itemType = _a5.itemType, hidden = _a5.hidden;
        if (itemType === SelectableOptionMenuItemType.Divider || itemType === SelectableOptionMenuItemType.Header) {
          displayOnlyOptionsCache.push(i);
          notSelectableOptionsCache.push(i);
        } else if (hidden) {
          notSelectableOptionsCache.push(i);
        } else {
          size++;
        }
      }
      this._size = size;
      this._displayOnlyOptionsCache = displayOnlyOptionsCache;
      this._notSelectableOptionsCache = notSelectableOptionsCache;
      this._cachedOptions = __spreadArray([], options, true);
    };
    Object.defineProperty(DropdownSizePosCache2.prototype, "optionSetSize", {
      /**
       * The size of all the selectable options.
       */
      get: function() {
        return this._size;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DropdownSizePosCache2.prototype, "cachedOptions", {
      /**
       * The chached options array.
       */
      get: function() {
        return this._cachedOptions;
      },
      enumerable: false,
      configurable: true
    });
    DropdownSizePosCache2.prototype.positionInSet = function(index) {
      if (index === void 0) {
        return void 0;
      }
      var offset = 0;
      while (index > this._notSelectableOptionsCache[offset]) {
        offset++;
      }
      if (this._displayOnlyOptionsCache[offset] === index) {
        throw new Error("Unexpected: Option at index ".concat(index, " is not a selectable element."));
      }
      if (this._notSelectableOptionsCache[offset] === index) {
        return void 0;
      }
      return index - offset + 1;
    };
    return DropdownSizePosCache2;
  }()
);

// node_modules/@fluentui/react/lib/components/Label/Label.base.js
var React38 = __toESM(require_react());
var getClassNames8 = classNamesFunction({
  // Label is used a lot by other components.
  // It's likely to see expected cases which pass different className to the Label.
  // Therefore setting a larger cache size.
  cacheSize: 100
});
var LabelBase = (
  /** @class */
  function(_super) {
    __extends(LabelBase2, _super);
    function LabelBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LabelBase2.prototype.render = function() {
      var _a5 = this.props, _b3 = _a5.as, RootType = _b3 === void 0 ? "label" : _b3, children = _a5.children, className = _a5.className, disabled = _a5.disabled, styles = _a5.styles, required = _a5.required, theme = _a5.theme;
      var classNames2 = getClassNames8(styles, {
        className,
        disabled,
        required,
        theme
      });
      return React38.createElement(RootType, __assign({}, getNativeProps(this.props, divProperties), { className: classNames2.root }), children);
    };
    return LabelBase2;
  }(React38.Component)
);

// node_modules/@fluentui/react/lib/components/Label/Label.styles.js
var getStyles16 = function(props) {
  var _a5;
  var theme = props.theme, className = props.className, disabled = props.disabled, required = props.required;
  var semanticColors = theme.semanticColors;
  var labelFontWeight = FontWeights.semibold;
  var labelColor = semanticColors.bodyText;
  var labelDisabledColor = semanticColors.disabledBodyText;
  var labelRequiredStarColor = semanticColors.errorText;
  return {
    root: [
      "ms-Label",
      theme.fonts.medium,
      {
        fontWeight: labelFontWeight,
        color: labelColor,
        boxSizing: "border-box",
        boxShadow: "none",
        margin: 0,
        display: "block",
        padding: "5px 0",
        wordWrap: "break-word",
        overflowWrap: "break-word"
      },
      disabled && {
        color: labelDisabledColor,
        selectors: (_a5 = {}, _a5[HighContrastSelector] = __assign({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _a5)
      },
      required && {
        selectors: {
          "::after": {
            content: "' *'",
            color: labelRequiredStarColor,
            paddingRight: 12
          }
        }
      },
      className
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Label/Label.js
var Label = styled(LabelBase, getStyles16, void 0, {
  scope: "Label"
});

// node_modules/@fluentui/react/lib/components/Panel/Panel.base.js
var React40 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Overlay/Overlay.base.js
var React39 = __toESM(require_react());
var getClassNames9 = classNamesFunction();
var OverlayBase = (
  /** @class */
  function(_super) {
    __extends(OverlayBase2, _super);
    function OverlayBase2(props) {
      var _this = _super.call(this, props) || this;
      initializeComponentRef(_this);
      var _a5 = _this.props.allowTouchBodyScroll, allowTouchBodyScroll = _a5 === void 0 ? false : _a5;
      _this._allowTouchBodyScroll = allowTouchBodyScroll;
      return _this;
    }
    OverlayBase2.prototype.componentDidMount = function() {
      !this._allowTouchBodyScroll && disableBodyScroll();
    };
    OverlayBase2.prototype.componentWillUnmount = function() {
      !this._allowTouchBodyScroll && enableBodyScroll();
    };
    OverlayBase2.prototype.render = function() {
      var _a5 = this.props, isDark = _a5.isDarkThemed, className = _a5.className, theme = _a5.theme, styles = _a5.styles;
      var divProps = getNativeProps(this.props, divProperties);
      var classNames2 = getClassNames9(styles, {
        theme,
        className,
        isDark
      });
      return React39.createElement("div", __assign({}, divProps, { className: classNames2.root }));
    };
    return OverlayBase2;
  }(React39.Component)
);

// node_modules/@fluentui/react/lib/components/Overlay/Overlay.styles.js
var GlobalClassNames7 = {
  root: "ms-Overlay",
  rootDark: "ms-Overlay--dark"
};
var getStyles17 = function(props) {
  var _a5;
  var className = props.className, theme = props.theme, isNone = props.isNone, isDark = props.isDark;
  var palette = theme.palette;
  var classNames2 = getGlobalClassNames(GlobalClassNames7, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        backgroundColor: palette.whiteTranslucent40,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        position: "absolute",
        selectors: (_a5 = {}, _a5[HighContrastSelector] = {
          border: "1px solid WindowText",
          opacity: 0
        }, _a5)
      },
      isNone && {
        visibility: "hidden"
      },
      isDark && [
        classNames2.rootDark,
        {
          backgroundColor: palette.blackTranslucent40
        }
      ],
      className
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Overlay/Overlay.js
var Overlay = styled(OverlayBase, getStyles17, void 0, {
  scope: "Overlay"
});

// node_modules/@fluentui/react/lib/components/Panel/Panel.types.js
var PanelType;
(function(PanelType2) {
  PanelType2[PanelType2["smallFluid"] = 0] = "smallFluid";
  PanelType2[PanelType2["smallFixedFar"] = 1] = "smallFixedFar";
  PanelType2[PanelType2["smallFixedNear"] = 2] = "smallFixedNear";
  PanelType2[PanelType2["medium"] = 3] = "medium";
  PanelType2[PanelType2["large"] = 4] = "large";
  PanelType2[PanelType2["largeFixed"] = 5] = "largeFixed";
  PanelType2[PanelType2["extraLarge"] = 6] = "extraLarge";
  PanelType2[PanelType2["custom"] = 7] = "custom";
  PanelType2[PanelType2["customNear"] = 8] = "customNear";
})(PanelType || (PanelType = {}));

// node_modules/@fluentui/react/lib/components/Panel/Panel.base.js
var getClassNames10 = classNamesFunction();
var COMPONENT_NAME5 = "Panel";
var PanelVisibilityState;
(function(PanelVisibilityState2) {
  PanelVisibilityState2[PanelVisibilityState2["closed"] = 0] = "closed";
  PanelVisibilityState2[PanelVisibilityState2["animatingOpen"] = 1] = "animatingOpen";
  PanelVisibilityState2[PanelVisibilityState2["open"] = 2] = "open";
  PanelVisibilityState2[PanelVisibilityState2["animatingClosed"] = 3] = "animatingClosed";
})(PanelVisibilityState || (PanelVisibilityState = {}));
var PanelBase = (
  /** @class */
  function(_super) {
    __extends(PanelBase2, _super);
    function PanelBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._panel = React40.createRef();
      _this._animationCallback = null;
      _this._hasCustomNavigation = !!(_this.props.onRenderNavigation || _this.props.onRenderNavigationContent);
      _this.dismiss = function(ev) {
        if (_this.props.onDismiss && _this.isActive) {
          _this.props.onDismiss(ev);
        }
        if (!ev || ev && !ev.defaultPrevented) {
          _this.close();
        }
      };
      _this._allowScrollOnPanel = function(elt) {
        if (elt) {
          if (_this._allowTouchBodyScroll) {
            allowOverscrollOnElement(elt, _this._events);
          } else {
            allowScrollOnElement(elt, _this._events);
          }
        } else {
          _this._events.off(_this._scrollableContent);
        }
        _this._scrollableContent = elt;
      };
      _this._onRenderNavigation = function(props2) {
        if (!_this.props.onRenderNavigationContent && !_this.props.onRenderNavigation && !_this.props.hasCloseButton) {
          return null;
        }
        var _a6 = _this.props.onRenderNavigationContent, onRenderNavigationContent = _a6 === void 0 ? _this._onRenderNavigationContent : _a6;
        return React40.createElement("div", { className: _this._classNames.navigation }, onRenderNavigationContent(props2, _this._onRenderNavigationContent));
      };
      _this._onRenderNavigationContent = function(props2) {
        var _a6;
        var closeButtonAriaLabel = props2.closeButtonAriaLabel, hasCloseButton = props2.hasCloseButton, _b3 = props2.onRenderHeader, onRenderHeader = _b3 === void 0 ? _this._onRenderHeader : _b3;
        if (hasCloseButton) {
          var iconButtonStyles = (_a6 = _this._classNames.subComponentStyles) === null || _a6 === void 0 ? void 0 : _a6.closeButton();
          return React40.createElement(
            React40.Fragment,
            null,
            !_this._hasCustomNavigation && onRenderHeader(_this.props, _this._onRenderHeader, _this._headerTextId),
            React40.createElement(IconButton, { styles: iconButtonStyles, className: _this._classNames.closeButton, onClick: _this._onPanelClick, ariaLabel: closeButtonAriaLabel, title: closeButtonAriaLabel, "data-is-visible": true, iconProps: { iconName: "Cancel" } })
          );
        }
        return null;
      };
      _this._onRenderHeader = function(props2, defaultRender, headerTextId) {
        var headerText = props2.headerText, _a6 = props2.headerTextProps, headerTextProps = _a6 === void 0 ? {} : _a6;
        if (headerText) {
          return React40.createElement(
            "div",
            { className: _this._classNames.header },
            React40.createElement("div", __assign({ id: headerTextId, role: "heading", "aria-level": 1 }, headerTextProps, { className: css(_this._classNames.headerText, headerTextProps.className) }), headerText)
          );
        }
        return null;
      };
      _this._onRenderBody = function(props2) {
        return React40.createElement("div", { className: _this._classNames.content }, props2.children);
      };
      _this._onRenderFooter = function(props2) {
        var _a6 = _this.props.onRenderFooterContent, onRenderFooterContent = _a6 === void 0 ? null : _a6;
        if (onRenderFooterContent) {
          return React40.createElement(
            "div",
            { className: _this._classNames.footer },
            React40.createElement("div", { className: _this._classNames.footerInner }, onRenderFooterContent())
          );
        }
        return null;
      };
      _this._animateTo = function(newVisibilityState) {
        if (newVisibilityState === PanelVisibilityState.open && _this.props.onOpen) {
          _this.props.onOpen();
        }
        _this._animationCallback = _this._async.setTimeout(function() {
          _this.setState({ visibility: newVisibilityState });
          _this._onTransitionComplete(newVisibilityState);
        }, 200);
      };
      _this._clearExistingAnimationTimer = function() {
        if (_this._animationCallback !== null) {
          _this._async.clearTimeout(_this._animationCallback);
        }
      };
      _this._onPanelClick = function(ev) {
        _this.dismiss(ev);
      };
      _this._onTransitionComplete = function(newVisibilityState) {
        _this._updateFooterPosition();
        if (newVisibilityState === PanelVisibilityState.open && _this.props.onOpened) {
          _this.props.onOpened();
        }
        if (newVisibilityState === PanelVisibilityState.closed && _this.props.onDismissed) {
          _this.props.onDismissed();
        }
      };
      var _a5 = _this.props.allowTouchBodyScroll, allowTouchBodyScroll = _a5 === void 0 ? false : _a5;
      _this._allowTouchBodyScroll = allowTouchBodyScroll;
      initializeComponentRef(_this);
      warnDeprecations(COMPONENT_NAME5, props, {
        ignoreExternalFocusing: "focusTrapZoneProps",
        forceFocusInsideTrap: "focusTrapZoneProps",
        firstFocusableSelector: "focusTrapZoneProps"
      });
      _this.state = {
        isFooterSticky: false,
        // intentionally ignore props so animation takes place during componentDidMount
        visibility: PanelVisibilityState.closed,
        id: getId("Panel")
      };
      return _this;
    }
    PanelBase2.getDerivedStateFromProps = function(nextProps, prevState) {
      if (nextProps.isOpen === void 0) {
        return null;
      }
      if (nextProps.isOpen && (prevState.visibility === PanelVisibilityState.closed || prevState.visibility === PanelVisibilityState.animatingClosed)) {
        return { visibility: PanelVisibilityState.animatingOpen };
      }
      if (!nextProps.isOpen && (prevState.visibility === PanelVisibilityState.open || prevState.visibility === PanelVisibilityState.animatingOpen)) {
        return { visibility: PanelVisibilityState.animatingClosed };
      }
      return null;
    };
    PanelBase2.prototype.componentDidMount = function() {
      this._async = new Async(this);
      this._events = new EventGroup(this);
      this._events.on(window, "resize", this._updateFooterPosition);
      if (this._shouldListenForOuterClick(this.props)) {
        this._events.on(document.body, "mousedown", this._dismissOnOuterClick, true);
      }
      if (this.props.isOpen) {
        this.setState({ visibility: PanelVisibilityState.animatingOpen });
      }
    };
    PanelBase2.prototype.componentDidUpdate = function(previousProps, previousState) {
      var shouldListenOnOuterClick = this._shouldListenForOuterClick(this.props);
      var previousShouldListenOnOuterClick = this._shouldListenForOuterClick(previousProps);
      if (this.state.visibility !== previousState.visibility) {
        this._clearExistingAnimationTimer();
        if (this.state.visibility === PanelVisibilityState.animatingOpen) {
          this._animateTo(PanelVisibilityState.open);
        } else if (this.state.visibility === PanelVisibilityState.animatingClosed) {
          this._animateTo(PanelVisibilityState.closed);
        }
      }
      if (shouldListenOnOuterClick && !previousShouldListenOnOuterClick) {
        this._events.on(document.body, "mousedown", this._dismissOnOuterClick, true);
      } else if (!shouldListenOnOuterClick && previousShouldListenOnOuterClick) {
        this._events.off(document.body, "mousedown", this._dismissOnOuterClick, true);
      }
    };
    PanelBase2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    PanelBase2.prototype.render = function() {
      var _a5 = this.props, _b3 = _a5.className, className = _b3 === void 0 ? "" : _b3, elementToFocusOnDismiss = _a5.elementToFocusOnDismiss, firstFocusableSelector = _a5.firstFocusableSelector, focusTrapZoneProps = _a5.focusTrapZoneProps, forceFocusInsideTrap = _a5.forceFocusInsideTrap, hasCloseButton = _a5.hasCloseButton, headerText = _a5.headerText, _c3 = _a5.headerClassName, headerClassName = _c3 === void 0 ? "" : _c3, ignoreExternalFocusing = _a5.ignoreExternalFocusing, isBlocking = _a5.isBlocking, isFooterAtBottom = _a5.isFooterAtBottom, isLightDismiss = _a5.isLightDismiss, isHiddenOnDismiss = _a5.isHiddenOnDismiss, layerProps = _a5.layerProps, overlayProps = _a5.overlayProps, popupProps = _a5.popupProps, type = _a5.type, styles = _a5.styles, theme = _a5.theme, customWidth = _a5.customWidth, _d3 = _a5.onLightDismissClick, onLightDismissClick = _d3 === void 0 ? this._onPanelClick : _d3, _e2 = _a5.onRenderNavigation, onRenderNavigation = _e2 === void 0 ? this._onRenderNavigation : _e2, _f = _a5.onRenderHeader, onRenderHeader = _f === void 0 ? this._onRenderHeader : _f, _g = _a5.onRenderBody, onRenderBody = _g === void 0 ? this._onRenderBody : _g, _h = _a5.onRenderFooter, onRenderFooter = _h === void 0 ? this._onRenderFooter : _h;
      var _j = this.state, isFooterSticky = _j.isFooterSticky, visibility = _j.visibility, id = _j.id;
      var isLeft = type === PanelType.smallFixedNear || type === PanelType.customNear ? true : false;
      var isRTL = getRTL(theme);
      var isOnRightSide = isRTL ? isLeft : !isLeft;
      var customWidthStyles = type === PanelType.custom || type === PanelType.customNear ? { width: customWidth } : {};
      var nativeProps = getNativeProps(this.props, divProperties);
      var isOpen = this.isActive;
      var isAnimating = visibility === PanelVisibilityState.animatingClosed || visibility === PanelVisibilityState.animatingOpen;
      this._headerTextId = headerText && id + "-headerText";
      if (!isOpen && !isAnimating && !isHiddenOnDismiss) {
        return null;
      }
      this._classNames = getClassNames10(styles, {
        theme,
        className,
        focusTrapZoneClassName: focusTrapZoneProps ? focusTrapZoneProps.className : void 0,
        hasCloseButton,
        headerClassName,
        isAnimating,
        isFooterSticky,
        isFooterAtBottom,
        isOnRightSide,
        isOpen,
        isHiddenOnDismiss,
        type,
        hasCustomNavigation: this._hasCustomNavigation
      });
      var _k = this, _classNames = _k._classNames, _allowTouchBodyScroll = _k._allowTouchBodyScroll;
      var overlay;
      if (isBlocking && isOpen) {
        overlay = React40.createElement(Overlay, __assign({ className: _classNames.overlay, isDarkThemed: false, onClick: isLightDismiss ? onLightDismissClick : void 0, allowTouchBodyScroll: _allowTouchBodyScroll }, overlayProps));
      }
      return React40.createElement(
        Layer,
        __assign({}, layerProps),
        React40.createElement(
          Popup,
          __assign({ role: "dialog", "aria-modal": isBlocking ? "true" : void 0, ariaLabelledBy: this._headerTextId ? this._headerTextId : void 0, onDismiss: this.dismiss, className: _classNames.hiddenPanel, enableAriaHiddenSiblings: isOpen ? true : false }, popupProps),
          React40.createElement(
            "div",
            __assign({ "aria-hidden": !isOpen && isAnimating }, nativeProps, { ref: this._panel, className: _classNames.root }),
            overlay,
            React40.createElement(
              FocusTrapZone,
              __assign({ ignoreExternalFocusing, forceFocusInsideTrap: !isBlocking || isHiddenOnDismiss && !isOpen ? false : forceFocusInsideTrap, firstFocusableSelector, isClickableOutsideFocusTrap: true }, focusTrapZoneProps, { className: _classNames.main, style: customWidthStyles, elementToFocusOnDismiss }),
              React40.createElement(
                "div",
                { className: _classNames.contentInner },
                React40.createElement(
                  "div",
                  { ref: this._allowScrollOnPanel, className: _classNames.scrollableContent, "data-is-scrollable": true },
                  React40.createElement("div", { className: _classNames.commands, "data-is-visible": true }, onRenderNavigation(this.props, this._onRenderNavigation)),
                  (this._hasCustomNavigation || !hasCloseButton) && onRenderHeader(this.props, this._onRenderHeader, this._headerTextId),
                  onRenderBody(this.props, this._onRenderBody),
                  onRenderFooter(this.props, this._onRenderFooter)
                )
              )
            )
          )
        )
      );
    };
    PanelBase2.prototype.open = function() {
      if (this.props.isOpen !== void 0) {
        return;
      }
      if (this.isActive) {
        return;
      }
      this.setState({ visibility: PanelVisibilityState.animatingOpen });
    };
    PanelBase2.prototype.close = function() {
      if (this.props.isOpen !== void 0) {
        return;
      }
      if (!this.isActive) {
        return;
      }
      this.setState({ visibility: PanelVisibilityState.animatingClosed });
    };
    Object.defineProperty(PanelBase2.prototype, "isActive", {
      /** isActive is true when panel is open or opening. */
      get: function() {
        return this.state.visibility === PanelVisibilityState.open || this.state.visibility === PanelVisibilityState.animatingOpen;
      },
      enumerable: false,
      configurable: true
    });
    PanelBase2.prototype._shouldListenForOuterClick = function(props) {
      return !!props.isBlocking && !!props.isOpen;
    };
    PanelBase2.prototype._updateFooterPosition = function() {
      var scrollableContent = this._scrollableContent;
      if (scrollableContent) {
        var height = scrollableContent.clientHeight;
        var innerHeight_1 = scrollableContent.scrollHeight;
        this.setState({
          isFooterSticky: height < innerHeight_1 ? true : false
        });
      }
    };
    PanelBase2.prototype._dismissOnOuterClick = function(ev) {
      var panel = this._panel.current;
      if (this.isActive && panel && !ev.defaultPrevented) {
        if (!elementContains(panel, ev.target)) {
          if (this.props.onOuterClick) {
            this.props.onOuterClick(ev);
          } else {
            this.dismiss(ev);
          }
        }
      }
    };
    PanelBase2.defaultProps = {
      isHiddenOnDismiss: false,
      isOpen: void 0,
      isBlocking: true,
      hasCloseButton: true,
      type: PanelType.smallFixedFar
    };
    return PanelBase2;
  }(React40.Component)
);

// node_modules/@fluentui/react/lib/components/Panel/Panel.styles.js
var _a3;
var _b;
var _c;
var _d;
var _e;
var GlobalClassNames8 = {
  root: "ms-Panel",
  main: "ms-Panel-main",
  commands: "ms-Panel-commands",
  contentInner: "ms-Panel-contentInner",
  scrollableContent: "ms-Panel-scrollableContent",
  navigation: "ms-Panel-navigation",
  closeButton: "ms-Panel-closeButton ms-PanelAction-close",
  header: "ms-Panel-header",
  headerText: "ms-Panel-headerText",
  content: "ms-Panel-content",
  footer: "ms-Panel-footer",
  footerInner: "ms-Panel-footerInner",
  isOpen: "is-open",
  hasCloseButton: "ms-Panel--hasCloseButton",
  smallFluid: "ms-Panel--smFluid",
  smallFixedNear: "ms-Panel--smLeft",
  smallFixedFar: "ms-Panel--sm",
  medium: "ms-Panel--md",
  large: "ms-Panel--lg",
  largeFixed: "ms-Panel--fixed",
  extraLarge: "ms-Panel--xl",
  custom: "ms-Panel--custom",
  customNear: "ms-Panel--customLeft"
};
var panelWidth = {
  full: "100%",
  auto: "auto",
  xs: 272,
  sm: 340,
  md1: 592,
  md2: 644,
  lg: 940
};
var panelMargin = {
  auto: "auto",
  none: 0,
  md: 48,
  lg: 428,
  xl: 176
};
var smallPanelSelectors = (_a3 = {}, _a3["@media (min-width: ".concat(ScreenWidthMinMedium, "px)")] = {
  width: panelWidth.sm
}, _a3);
var mediumPanelSelectors = (_b = {}, _b["@media (min-width: ".concat(ScreenWidthMinLarge, "px)")] = {
  width: panelWidth.md1
}, _b["@media (min-width: ".concat(ScreenWidthMinXLarge, "px)")] = {
  width: panelWidth.md2
}, _b);
var largePanelSelectors = (_c = {}, _c["@media (min-width: ".concat(ScreenWidthMinUhfMobile, "px)")] = {
  left: panelMargin.md,
  width: panelWidth.auto
}, _c["@media (min-width: ".concat(ScreenWidthMinXXLarge, "px)")] = {
  left: panelMargin.lg
}, _c);
var largeFixedPanelSelectors = (_d = {}, _d["@media (min-width: ".concat(ScreenWidthMinXXLarge, "px)")] = {
  left: panelMargin.auto,
  width: panelWidth.lg
}, _d);
var extraLargePanelSelectors = (_e = {}, _e["@media (min-width: ".concat(ScreenWidthMinXXLarge, "px)")] = {
  left: panelMargin.xl
}, _e);
var getPanelBreakpoints = function(type) {
  var selectors;
  switch (type) {
    case PanelType.smallFixedFar:
      selectors = __assign({}, smallPanelSelectors);
      break;
    case PanelType.medium:
      selectors = __assign(__assign({}, smallPanelSelectors), mediumPanelSelectors);
      break;
    case PanelType.large:
      selectors = __assign(__assign(__assign({}, smallPanelSelectors), mediumPanelSelectors), largePanelSelectors);
      break;
    case PanelType.largeFixed:
      selectors = __assign(__assign(__assign(__assign({}, smallPanelSelectors), mediumPanelSelectors), largePanelSelectors), largeFixedPanelSelectors);
      break;
    case PanelType.extraLarge:
      selectors = __assign(__assign(__assign(__assign({}, smallPanelSelectors), mediumPanelSelectors), largePanelSelectors), extraLargePanelSelectors);
      break;
    default:
      break;
  }
  return selectors;
};
var commandBarHeight = "44px";
var sharedPaddingStyles = {
  paddingLeft: "24px",
  paddingRight: "24px"
};
var getStyles18 = function(props) {
  var _a5, _b3, _c3, _d3;
  var className = props.className, focusTrapZoneClassName = props.focusTrapZoneClassName, hasCloseButton = props.hasCloseButton, headerClassName = props.headerClassName, isAnimating = props.isAnimating, isFooterSticky = props.isFooterSticky, isFooterAtBottom = props.isFooterAtBottom, isOnRightSide = props.isOnRightSide, isOpen = props.isOpen, isHiddenOnDismiss = props.isHiddenOnDismiss, hasCustomNavigation = props.hasCustomNavigation, theme = props.theme, _e2 = props.type, type = _e2 === void 0 ? PanelType.smallFixedFar : _e2;
  var effects = theme.effects, fonts = theme.fonts, semanticColors = theme.semanticColors;
  var classNames2 = getGlobalClassNames(GlobalClassNames8, theme);
  var isCustomPanel = type === PanelType.custom || type === PanelType.customNear;
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      isOpen && classNames2.isOpen,
      hasCloseButton && classNames2.hasCloseButton,
      {
        pointerEvents: "none",
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      isCustomPanel && isOnRightSide && classNames2.custom,
      isCustomPanel && !isOnRightSide && classNames2.customNear,
      className
    ],
    overlay: [
      {
        pointerEvents: "auto",
        cursor: "pointer"
      },
      isOpen && isAnimating && AnimationClassNames.fadeIn100,
      !isOpen && isAnimating && AnimationClassNames.fadeOut100
    ],
    hiddenPanel: [
      !isOpen && !isAnimating && isHiddenOnDismiss && {
        visibility: "hidden"
      }
    ],
    main: [
      classNames2.main,
      {
        backgroundColor: semanticColors.bodyBackground,
        boxShadow: effects.elevation64,
        pointerEvents: "auto",
        position: "absolute",
        display: "flex",
        flexDirection: "column",
        overflowX: "hidden",
        overflowY: "auto",
        WebkitOverflowScrolling: "touch",
        bottom: 0,
        top: 0,
        // left, right, width are overridden depending on the type of the Panel and the screen breakpoint.
        left: panelMargin.auto,
        right: panelMargin.none,
        width: panelWidth.full,
        selectors: __assign((_a5 = {}, _a5[HighContrastSelector] = {
          borderLeft: "3px solid ".concat(semanticColors.variantBorder),
          borderRight: "3px solid ".concat(semanticColors.variantBorder)
        }, _a5), getPanelBreakpoints(type))
      },
      type === PanelType.smallFluid && {
        left: panelMargin.none
      },
      type === PanelType.smallFixedNear && {
        left: panelMargin.none,
        right: panelMargin.auto,
        width: panelWidth.xs
      },
      type === PanelType.customNear && {
        right: "auto",
        left: 0
      },
      isCustomPanel && {
        maxWidth: "100vw"
      },
      isOpen && isAnimating && !isOnRightSide && AnimationClassNames.slideRightIn40,
      isOpen && isAnimating && isOnRightSide && AnimationClassNames.slideLeftIn40,
      !isOpen && isAnimating && !isOnRightSide && AnimationClassNames.slideLeftOut40,
      !isOpen && isAnimating && isOnRightSide && AnimationClassNames.slideRightOut40,
      focusTrapZoneClassName
    ],
    commands: [
      classNames2.commands,
      {
        // Ensures that the sticky header always has a background to prevent overlaps on scroll.
        backgroundColor: semanticColors.bodyBackground,
        paddingTop: 18,
        selectors: (_b3 = {}, _b3["@media (min-height: ".concat(ScreenWidthMinMedium, "px)")] = {
          position: "sticky",
          top: 0,
          zIndex: 1
        }, _b3)
      },
      hasCustomNavigation && {
        paddingTop: "inherit"
      }
    ],
    navigation: [
      classNames2.navigation,
      {
        display: "flex",
        justifyContent: "flex-end"
      },
      hasCustomNavigation && {
        height: commandBarHeight
      }
    ],
    contentInner: [
      classNames2.contentInner,
      {
        display: "flex",
        flexDirection: "column",
        flexGrow: 1,
        overflowY: "hidden"
      }
    ],
    header: [
      classNames2.header,
      sharedPaddingStyles,
      {
        alignSelf: "flex-start"
      },
      hasCloseButton && !hasCustomNavigation && {
        flexGrow: 1
      },
      hasCustomNavigation && {
        // Ensure that title doesn't shrink if screen is too small
        flexShrink: 0
      }
    ],
    headerText: [
      classNames2.headerText,
      fonts.xLarge,
      {
        color: semanticColors.bodyText,
        lineHeight: "27px",
        overflowWrap: "break-word",
        wordWrap: "break-word",
        wordBreak: "break-word",
        hyphens: "auto"
      },
      headerClassName
    ],
    scrollableContent: [
      classNames2.scrollableContent,
      {
        overflowY: "auto"
      },
      isFooterAtBottom && {
        flexGrow: 1,
        display: "inherit",
        flexDirection: "inherit"
      }
    ],
    content: [
      classNames2.content,
      sharedPaddingStyles,
      {
        paddingBottom: 20
      },
      isFooterAtBottom && {
        selectors: (_c3 = {}, _c3["@media (min-height: ".concat(ScreenWidthMinMedium, "px)")] = {
          flexGrow: 1
        }, _c3)
      }
    ],
    footer: [
      classNames2.footer,
      {
        // Ensure that footer doesn't shrink if screen is too small
        flexShrink: 0,
        borderTop: "1px solid transparent",
        transition: "opacity ".concat(AnimationVariables.durationValue3, " ").concat(AnimationVariables.easeFunction2),
        selectors: (_d3 = {}, _d3["@media (min-height: ".concat(ScreenWidthMinMedium, "px)")] = {
          position: "sticky",
          bottom: 0
        }, _d3)
      },
      isFooterSticky && {
        backgroundColor: semanticColors.bodyBackground,
        borderTopColor: semanticColors.variantBorder
      }
    ],
    footerInner: [
      classNames2.footerInner,
      sharedPaddingStyles,
      {
        paddingBottom: 16,
        paddingTop: 16
      }
    ],
    subComponentStyles: {
      closeButton: {
        root: [
          classNames2.closeButton,
          {
            marginRight: 14,
            color: theme.palette.neutralSecondary,
            fontSize: IconFontSizes.large
          },
          hasCustomNavigation && {
            marginRight: 0,
            height: "auto",
            width: "44px"
          }
        ],
        rootHovered: {
          color: theme.palette.neutralPrimary
        }
      }
    }
  };
};

// node_modules/@fluentui/react/lib/components/Panel/Panel.js
var Panel = styled(PanelBase, getStyles18, void 0, {
  scope: "Panel"
});

// node_modules/@fluentui/react/lib/components/Checkbox/Checkbox.base.js
var React41 = __toESM(require_react());
var getClassNames11 = classNamesFunction();
var CheckboxBase = React41.forwardRef(function(props, forwardedRef) {
  var disabled = props.disabled, required = props.required, inputProps = props.inputProps, name = props.name, ariaLabel = props.ariaLabel, ariaLabelledBy = props.ariaLabelledBy, ariaDescribedBy = props.ariaDescribedBy, ariaPositionInSet = props.ariaPositionInSet, ariaSetSize = props.ariaSetSize, title = props.title, checkmarkIconProps = props.checkmarkIconProps, styles = props.styles, theme = props.theme, className = props.className, _a5 = props.boxSide, boxSide = _a5 === void 0 ? "start" : _a5;
  var id = useId("checkbox-", props.id);
  var rootRef = React41.useRef(null);
  var mergedRootRefs = useMergedRefs(rootRef, forwardedRef);
  var inputRef = React41.useRef(null);
  var _b3 = useControllableValue(props.checked, props.defaultChecked, props.onChange), isChecked = _b3[0], setIsChecked = _b3[1];
  var _c3 = useControllableValue(props.indeterminate, props.defaultIndeterminate), isIndeterminate = _c3[0], setIsIndeterminate = _c3[1];
  useFocusRects(rootRef);
  useDebugWarning(props);
  var classNames2 = getClassNames11(styles, {
    theme,
    className,
    disabled,
    indeterminate: isIndeterminate,
    checked: isChecked,
    reversed: boxSide !== "start",
    isUsingCustomLabelRender: !!props.onRenderLabel
  });
  var onChange = React41.useCallback(function(event) {
    if (isIndeterminate) {
      setIsChecked(!!isChecked, event);
      setIsIndeterminate(false);
    } else {
      setIsChecked(!isChecked, event);
    }
  }, [setIsChecked, setIsIndeterminate, isIndeterminate, isChecked]);
  var defaultLabelRenderer = React41.useCallback(function(checkboxProps) {
    if (!checkboxProps) {
      return null;
    }
    return checkboxProps.label ? React41.createElement("span", { className: classNames2.text, title: checkboxProps.title }, checkboxProps.label) : null;
  }, [classNames2.text]);
  var setNativeIndeterminate = React41.useCallback(function(indeterminate) {
    if (!inputRef.current) {
      return;
    }
    var value = !!indeterminate;
    inputRef.current.indeterminate = value;
    setIsIndeterminate(value);
  }, [setIsIndeterminate]);
  useComponentRef2(props, isChecked, isIndeterminate, setNativeIndeterminate, inputRef);
  React41.useEffect(function() {
    return setNativeIndeterminate(isIndeterminate);
  }, [setNativeIndeterminate, isIndeterminate]);
  var onRenderLabel = props.onRenderLabel || defaultLabelRenderer;
  var ariaChecked = isIndeterminate ? "mixed" : void 0;
  var mergedInputProps = __assign(__assign({ className: classNames2.input, type: "checkbox" }, inputProps), { checked: !!isChecked, disabled, required, name, id, title, onChange, "aria-disabled": disabled, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, "aria-posinset": ariaPositionInSet, "aria-setsize": ariaSetSize, "aria-checked": ariaChecked });
  return React41.createElement(
    "div",
    { className: classNames2.root, title, ref: mergedRootRefs },
    React41.createElement("input", __assign({}, mergedInputProps, { ref: inputRef, title, "data-ktp-execute-target": true })),
    React41.createElement(
      "label",
      { className: classNames2.label, htmlFor: id },
      React41.createElement(
        "div",
        { className: classNames2.checkbox, "data-ktp-target": true },
        React41.createElement(Icon, __assign({ iconName: "CheckMark" }, checkmarkIconProps, { className: classNames2.checkmark }))
      ),
      onRenderLabel(props, defaultLabelRenderer)
    )
  );
});
CheckboxBase.displayName = "CheckboxBase";
function useDebugWarning(props) {
  if (true) {
    useWarnings({
      name: "Checkbox",
      props,
      mutuallyExclusive: {
        checked: "defaultChecked",
        indeterminate: "defaultIndeterminate"
      }
    });
  }
}
function useComponentRef2(props, isChecked, isIndeterminate, setIndeterminate, checkBoxRef) {
  React41.useImperativeHandle(props.componentRef, function() {
    return {
      get checked() {
        return !!isChecked;
      },
      get indeterminate() {
        return !!isIndeterminate;
      },
      set indeterminate(indeterminate) {
        setIndeterminate(indeterminate);
      },
      focus: function() {
        if (checkBoxRef.current) {
          checkBoxRef.current.focus();
        }
      }
    };
  }, [checkBoxRef, isChecked, isIndeterminate, setIndeterminate]);
}

// node_modules/@fluentui/react/lib/components/Checkbox/Checkbox.styles.js
var GlobalClassNames9 = {
  root: "ms-Checkbox",
  label: "ms-Checkbox-label",
  checkbox: "ms-Checkbox-checkbox",
  checkmark: "ms-Checkbox-checkmark",
  text: "ms-Checkbox-text"
};
var MS_CHECKBOX_LABEL_SIZE = "20px";
var MS_CHECKBOX_TRANSITION_DURATION = "200ms";
var MS_CHECKBOX_TRANSITION_TIMING = "cubic-bezier(.4, 0, .23, 1)";
var getStyles19 = function(props) {
  var _a5, _b3, _c3, _d3, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  var className = props.className, theme = props.theme, reversed = props.reversed, checked = props.checked, disabled = props.disabled, isUsingCustomLabelRender = props.isUsingCustomLabelRender, indeterminate = props.indeterminate;
  var semanticColors = theme.semanticColors, effects = theme.effects, palette = theme.palette, fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(GlobalClassNames9, theme);
  var checkmarkFontColor = semanticColors.inputForegroundChecked;
  var checkmarkFontColorHovered = palette.neutralSecondary;
  var checkboxBorderColor = palette.neutralPrimary;
  var checkboxBorderIndeterminateColor = semanticColors.inputBackgroundChecked;
  var checkboxBorderColorChecked = semanticColors.inputBackgroundChecked;
  var checkboxBorderColorDisabled = semanticColors.disabledBodySubtext;
  var checkboxBorderHoveredColor = semanticColors.inputBorderHovered;
  var checkboxBorderIndeterminateHoveredColor = semanticColors.inputBackgroundCheckedHovered;
  var checkboxBackgroundChecked = semanticColors.inputBackgroundChecked;
  var checkboxBackgroundCheckedHovered = semanticColors.inputBackgroundCheckedHovered;
  var checkboxBorderColorCheckedHovered = semanticColors.inputBackgroundCheckedHovered;
  var checkboxHoveredTextColor = semanticColors.inputTextHovered;
  var checkboxBackgroundDisabledChecked = semanticColors.disabledBodySubtext;
  var checkboxTextColor = semanticColors.bodyText;
  var checkboxTextColorDisabled = semanticColors.disabledText;
  var indeterminateDotStyles = [
    (_a5 = {
      content: '""',
      borderRadius: effects.roundedCorner2,
      position: "absolute",
      width: 10,
      height: 10,
      top: 4,
      left: 4,
      boxSizing: "border-box",
      borderWidth: 5,
      borderStyle: "solid",
      borderColor: disabled ? checkboxBorderColorDisabled : checkboxBorderIndeterminateColor,
      transitionProperty: "border-width, border, border-color",
      transitionDuration: MS_CHECKBOX_TRANSITION_DURATION,
      transitionTimingFunction: MS_CHECKBOX_TRANSITION_TIMING
    }, _a5[HighContrastSelector] = {
      borderColor: "WindowText"
    }, _a5)
  ];
  return {
    root: [
      classNames2.root,
      {
        position: "relative",
        display: "flex"
      },
      reversed && "reversed",
      checked && "is-checked",
      !disabled && "is-enabled",
      disabled && "is-disabled",
      !disabled && [
        !checked && (_b3 = {}, _b3[":hover .".concat(classNames2.checkbox)] = (_c3 = {
          borderColor: checkboxBorderHoveredColor
        }, _c3[HighContrastSelector] = {
          borderColor: "Highlight"
        }, _c3), _b3[":focus .".concat(classNames2.checkbox)] = { borderColor: checkboxBorderHoveredColor }, _b3[":hover .".concat(classNames2.checkmark)] = (_d3 = {
          color: checkmarkFontColorHovered,
          opacity: "1"
        }, _d3[HighContrastSelector] = {
          color: "Highlight"
        }, _d3), _b3),
        checked && !indeterminate && (_e2 = {}, _e2[":hover .".concat(classNames2.checkbox)] = {
          background: checkboxBackgroundCheckedHovered,
          borderColor: checkboxBorderColorCheckedHovered
        }, _e2[":focus .".concat(classNames2.checkbox)] = {
          background: checkboxBackgroundCheckedHovered,
          borderColor: checkboxBorderColorCheckedHovered
        }, _e2[HighContrastSelector] = (_f = {}, _f[":hover .".concat(classNames2.checkbox)] = {
          background: "Highlight",
          borderColor: "Highlight"
        }, _f[":focus .".concat(classNames2.checkbox)] = {
          background: "Highlight"
        }, _f[":focus:hover .".concat(classNames2.checkbox)] = {
          background: "Highlight"
        }, _f[":focus:hover .".concat(classNames2.checkmark)] = {
          color: "Window"
        }, _f[":hover .".concat(classNames2.checkmark)] = {
          color: "Window"
        }, _f), _e2),
        indeterminate && (_g = {}, _g[":hover .".concat(classNames2.checkbox, ", :hover .").concat(classNames2.checkbox, ":after")] = (_h = {
          borderColor: checkboxBorderIndeterminateHoveredColor
        }, _h[HighContrastSelector] = {
          borderColor: "WindowText"
        }, _h), _g[":focus .".concat(classNames2.checkbox)] = {
          borderColor: checkboxBorderIndeterminateHoveredColor
        }, _g[":hover .".concat(classNames2.checkmark)] = {
          opacity: "0"
        }, _g),
        (_j = {}, _j[":hover .".concat(classNames2.text, ", :focus .").concat(classNames2.text)] = (_k = {
          color: checkboxHoveredTextColor
        }, _k[HighContrastSelector] = {
          color: disabled ? "GrayText" : "WindowText"
        }, _k), _j)
      ],
      className
    ],
    input: (_l = {
      position: "absolute",
      background: "none",
      opacity: 0
    }, _l[".".concat(IsFocusVisibleClassName, " &:focus + label::before")] = (_m = {
      outline: "1px solid " + theme.palette.neutralSecondary,
      outlineOffset: "2px"
    }, _m[HighContrastSelector] = {
      outline: "1px solid WindowText"
    }, _m), _l),
    label: [
      classNames2.label,
      theme.fonts.medium,
      {
        display: "flex",
        alignItems: isUsingCustomLabelRender ? "center" : "flex-start",
        cursor: disabled ? "default" : "pointer",
        position: "relative",
        userSelect: "none"
      },
      reversed && {
        flexDirection: "row-reverse",
        justifyContent: "flex-end"
      },
      {
        "&::before": {
          position: "absolute",
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          content: '""',
          pointerEvents: "none"
        }
      }
    ],
    checkbox: [
      classNames2.checkbox,
      (_o = {
        position: "relative",
        display: "flex",
        flexShrink: 0,
        alignItems: "center",
        justifyContent: "center",
        height: MS_CHECKBOX_LABEL_SIZE,
        width: MS_CHECKBOX_LABEL_SIZE,
        border: "1px solid ".concat(checkboxBorderColor),
        borderRadius: effects.roundedCorner2,
        boxSizing: "border-box",
        transitionProperty: "background, border, border-color",
        transitionDuration: MS_CHECKBOX_TRANSITION_DURATION,
        transitionTimingFunction: MS_CHECKBOX_TRANSITION_TIMING,
        /* in case the icon is bigger than the box */
        overflow: "hidden",
        ":after": indeterminate ? indeterminateDotStyles : null
      }, _o[HighContrastSelector] = __assign({ borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _o),
      indeterminate && {
        borderColor: checkboxBorderIndeterminateColor
      },
      !reversed ? (
        // This margin on the checkbox is for backwards compat. Notably it has the effect where a customRender
        // is used, there will be only a 4px margin from checkbox to label. The label by default would have
        // another 4px margin for a total of 8px margin between checkbox and label. We don't combine the two
        // (and move it into the text) to not incur a breaking change for everyone using custom render atm.
        {
          marginRight: 4
        }
      ) : {
        marginLeft: 4
      },
      !disabled && !indeterminate && checked && (_p = {
        background: checkboxBackgroundChecked,
        borderColor: checkboxBorderColorChecked
      }, _p[HighContrastSelector] = {
        background: "Highlight",
        borderColor: "Highlight"
      }, _p),
      disabled && (_q = {
        borderColor: checkboxBorderColorDisabled
      }, _q[HighContrastSelector] = {
        borderColor: "GrayText"
      }, _q),
      checked && disabled && (_r = {
        background: checkboxBackgroundDisabledChecked,
        borderColor: checkboxBorderColorDisabled
      }, _r[HighContrastSelector] = {
        background: "Window"
      }, _r)
    ],
    checkmark: [
      classNames2.checkmark,
      (_s = {
        opacity: checked && !indeterminate ? "1" : "0",
        color: checkmarkFontColor
      }, _s[HighContrastSelector] = __assign({ color: disabled ? "GrayText" : "Window" }, getHighContrastNoAdjustStyle()), _s)
    ],
    text: [
      classNames2.text,
      (_t = {
        color: disabled ? checkboxTextColorDisabled : checkboxTextColor,
        fontSize: fonts.medium.fontSize,
        lineHeight: "20px"
      }, _t[HighContrastSelector] = __assign({ color: disabled ? "GrayText" : "WindowText" }, getHighContrastNoAdjustStyle()), _t),
      !reversed ? {
        marginLeft: 4
      } : {
        marginRight: 4
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Checkbox/Checkbox.js
var Checkbox = styled(CheckboxBase, getStyles19, void 0, { scope: "Checkbox" });

// node_modules/@fluentui/react/lib/components/Dropdown/Dropdown.base.js
var COMPONENT_NAME6 = "Dropdown";
var getClassNames12 = classNamesFunction();
var DEFAULT_PROPS4 = {
  options: []
};
function useSelectedItemsState(_a5) {
  var defaultSelectedKeys = _a5.defaultSelectedKeys, selectedKeys = _a5.selectedKeys, defaultSelectedKey = _a5.defaultSelectedKey, selectedKey = _a5.selectedKey, options = _a5.options, multiSelect = _a5.multiSelect;
  var oldOptions = usePrevious(options);
  var _b3 = React42.useState([]), selectedIndices = _b3[0], setSelectedIndices = _b3[1];
  var selectedKeyPropToUse;
  var didOptionsChange = options !== oldOptions;
  if (multiSelect) {
    if (didOptionsChange && defaultSelectedKeys !== void 0) {
      selectedKeyPropToUse = defaultSelectedKeys;
    } else {
      selectedKeyPropToUse = selectedKeys;
    }
  } else {
    if (didOptionsChange && defaultSelectedKey !== void 0) {
      selectedKeyPropToUse = defaultSelectedKey;
    } else {
      selectedKeyPropToUse = selectedKey;
    }
  }
  var oldSelectedKeyProp = usePrevious(selectedKeyPropToUse);
  React42.useEffect(function() {
    var getSelectedIndexes = function() {
      if (selectedKeyPropToUse === void 0) {
        if (multiSelect) {
          return getAllSelectedIndices();
        }
        var selectedIndex = getSelectedIndex(null);
        return selectedIndex !== -1 ? [selectedIndex] : [];
      } else if (!Array.isArray(selectedKeyPropToUse)) {
        var selectedIndex = getSelectedIndex(selectedKeyPropToUse);
        return selectedIndex !== -1 ? [selectedIndex] : [];
      }
      var returnValue = [];
      for (var _i = 0, selectedKeyPropToUse_1 = selectedKeyPropToUse; _i < selectedKeyPropToUse_1.length; _i++) {
        var key = selectedKeyPropToUse_1[_i];
        var selectedIndex = getSelectedIndex(key);
        selectedIndex !== -1 && returnValue.push(selectedIndex);
      }
      return returnValue;
    };
    var getAllSelectedIndices = function() {
      return options.map(function(option, index) {
        return option.selected ? index : -1;
      }).filter(function(index) {
        return index !== -1;
      });
    };
    var getSelectedIndex = function(searchKey) {
      return findIndex(options, function(option) {
        if (searchKey != null) {
          return option.key === searchKey;
        } else {
          return !!option.selected || !!option.isSelected;
        }
      });
    };
    if ((selectedKeyPropToUse !== void 0 || !oldOptions) && (selectedKeyPropToUse !== oldSelectedKeyProp || didOptionsChange)) {
      setSelectedIndices(getSelectedIndexes());
    }
  }, [didOptionsChange, multiSelect, oldOptions, oldSelectedKeyProp, options, selectedKeyPropToUse]);
  return [selectedIndices, setSelectedIndices];
}
var DropdownBase = React42.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults(DEFAULT_PROPS4, propsWithoutDefaults);
  var rootRef = React42.useRef(null);
  var mergedRootRef = useMergedRefs(forwardedRef, rootRef);
  var responsiveMode = useResponsiveMode(rootRef, props.responsiveMode);
  var _a5 = useSelectedItemsState(props), selectedIndices = _a5[0], setSelectedIndices = _a5[1];
  return React42.createElement(DropdownInternal, __assign({}, props, { responsiveMode, hoisted: { rootRef: mergedRootRef, selectedIndices, setSelectedIndices } }));
});
DropdownBase.displayName = "DropdownBase";
var DropdownInternal = (
  /** @class */
  function(_super) {
    __extends(DropdownInternal2, _super);
    function DropdownInternal2(props) {
      var _this = _super.call(this, props) || this;
      _this._host = React42.createRef();
      _this._focusZone = React42.createRef();
      _this._dropDown = React42.createRef();
      _this._scrollIdleDelay = 250;
      _this._sizePosCache = new DropdownSizePosCache();
      _this._requestAnimationFrame = safeRequestAnimationFrame(_this);
      _this.dismissMenu = function() {
        var isOpen = _this.state.isOpen;
        isOpen && _this.setState({ isOpen: false });
      };
      _this._onChange = function(event, options2, index, checked, multiSelect2) {
        var _a5 = _this.props, onChange = _a5.onChange, onChanged = _a5.onChanged;
        if (onChange || onChanged) {
          var changedOpt = multiSelect2 ? __assign(__assign({}, options2[index]), { selected: !checked }) : options2[index];
          onChange && onChange(__assign(__assign({}, event), { target: _this._dropDown.current }), changedOpt, index);
          onChanged && onChanged(changedOpt, index);
        }
      };
      _this._getPlaceholder = function() {
        return _this.props.placeholder || _this.props.placeHolder;
      };
      _this._getTitle = function(items, _unused) {
        var _a5 = _this.props.multiSelectDelimiter, multiSelectDelimiter = _a5 === void 0 ? ", " : _a5;
        return items.map(function(i) {
          return i.text;
        }).join(multiSelectDelimiter);
      };
      _this._onRenderTitle = function(items) {
        return React42.createElement(React42.Fragment, null, _this._getTitle(items));
      };
      _this._onRenderPlaceholder = function(props2) {
        if (!_this._getPlaceholder()) {
          return null;
        }
        return React42.createElement(React42.Fragment, null, _this._getPlaceholder());
      };
      _this._onRenderContainer = function(props2) {
        var calloutProps = props2.calloutProps, panelProps = props2.panelProps;
        var _a5 = _this.props, responsiveMode = _a5.responsiveMode, dropdownWidth = _a5.dropdownWidth;
        var isSmall = responsiveMode <= ResponsiveMode.medium;
        var focusTrapZoneProps = { firstFocusableTarget: "#".concat(_this._listId, "1") };
        var panelStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.panel : void 0;
        var calloutWidth = void 0;
        var calloutMinWidth = void 0;
        if (dropdownWidth === "auto") {
          calloutMinWidth = _this._dropDown.current ? _this._dropDown.current.clientWidth : 0;
        } else {
          calloutWidth = dropdownWidth || (_this._dropDown.current ? _this._dropDown.current.clientWidth : 0);
        }
        return isSmall ? React42.createElement(Panel, __assign({ closeButtonAriaLabel: "Close", focusTrapZoneProps, hasCloseButton: true, isOpen: true, isLightDismiss: true, onDismiss: _this._onDismiss, styles: panelStyles }, panelProps), _this._renderFocusableList(props2)) : React42.createElement(Callout, __assign({ isBeakVisible: false, gapSpace: 0, doNotLayer: false, directionalHintFixed: false, directionalHint: DirectionalHint.bottomLeftEdge, calloutWidth, calloutMinWidth }, calloutProps, { className: _this._classNames.callout, target: _this._dropDown.current, onDismiss: _this._onDismiss, onScroll: _this._onScroll, onPositioned: _this._onPositioned }), _this._renderFocusableList(props2));
      };
      _this._onRenderCaretDown = function(props2) {
        return React42.createElement(Icon, { className: _this._classNames.caretDown, iconName: "ChevronDown", "aria-hidden": true });
      };
      _this._onRenderList = function(props2) {
        var _a5 = props2.onRenderItem, onRenderItem = _a5 === void 0 ? _this._onRenderItem : _a5;
        var queue = { items: [] };
        var renderedList = [];
        var emptyQueue = function() {
          var newGroup = queue.id ? [
            React42.createElement("div", { role: "group", key: queue.id, "aria-labelledby": queue.id }, queue.items)
          ] : queue.items;
          renderedList = __spreadArray(__spreadArray([], renderedList, true), newGroup, true);
          queue = { items: [] };
        };
        var placeRenderedOptionIntoQueue = function(item, index) {
          switch (item.itemType) {
            case SelectableOptionMenuItemType.Header:
              queue.items.length > 0 && emptyQueue();
              var id = _this._id + item.key;
              queue.items.push(onRenderItem(__assign(__assign({ id }, item), { index }), _this._onRenderItem));
              queue.id = id;
              break;
            case SelectableOptionMenuItemType.Divider:
              index > 0 && queue.items.push(onRenderItem(__assign(__assign({}, item), { index }), _this._onRenderItem));
              queue.items.length > 0 && emptyQueue();
              break;
            default:
              queue.items.push(onRenderItem(__assign(__assign({}, item), { index }), _this._onRenderItem));
          }
        };
        props2.options.forEach(function(item, index) {
          placeRenderedOptionIntoQueue(item, index);
        });
        queue.items.length > 0 && emptyQueue();
        return React42.createElement(React42.Fragment, null, renderedList);
      };
      _this._onRenderItem = function(item) {
        switch (item.itemType) {
          case SelectableOptionMenuItemType.Divider:
            return _this._renderSeparator(item);
          case SelectableOptionMenuItemType.Header:
            return _this._renderHeader(item);
          default:
            return _this._renderOption(item);
        }
      };
      _this._renderOption = function(item) {
        var _a5;
        var _b3 = _this.props, _c3 = _b3.onRenderOption, onRenderOption = _c3 === void 0 ? _this._onRenderOption : _c3, _d3 = _b3.hoisted.selectedIndices, selectedIndices = _d3 === void 0 ? [] : _d3;
        var isItemSelected = item.index !== void 0 && selectedIndices ? selectedIndices.indexOf(item.index) > -1 : false;
        var itemClassName = item.hidden ? _this._classNames.dropdownItemHidden : isItemSelected && item.disabled === true ? _this._classNames.dropdownItemSelectedAndDisabled : isItemSelected ? _this._classNames.dropdownItemSelected : item.disabled === true ? _this._classNames.dropdownItemDisabled : _this._classNames.dropdownItem;
        var title = item.title;
        var id = _this._listId + item.index;
        var labelId = (_a5 = item.id) !== null && _a5 !== void 0 ? _a5 : id + "-label";
        var multiSelectItemStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.multiSelectItem : void 0;
        return !_this.props.multiSelect ? React42.createElement(CommandButton, {
          id,
          key: item.key,
          "data-index": item.index,
          "data-is-focusable": !item.disabled,
          disabled: item.disabled,
          className: itemClassName,
          onClick: _this._onItemClick(item),
          // eslint-disable-next-line react/jsx-no-bind
          onMouseEnter: _this._onItemMouseEnter.bind(_this, item),
          // eslint-disable-next-line react/jsx-no-bind
          onMouseLeave: _this._onMouseItemLeave.bind(_this, item),
          // eslint-disable-next-line react/jsx-no-bind
          onMouseMove: _this._onItemMouseMove.bind(_this, item),
          role: "option",
          "aria-selected": isItemSelected ? "true" : "false",
          ariaLabel: item.ariaLabel,
          title,
          "aria-posinset": _this._sizePosCache.positionInSet(item.index),
          "aria-setsize": _this._sizePosCache.optionSetSize
        }, onRenderOption(item, _this._onRenderOption)) : React42.createElement(Checkbox, {
          id,
          key: item.key,
          disabled: item.disabled,
          onChange: _this._onItemClick(item),
          inputProps: __assign({ "aria-selected": isItemSelected, onMouseEnter: _this._onItemMouseEnter.bind(_this, item), onMouseLeave: _this._onMouseItemLeave.bind(_this, item), onMouseMove: _this._onItemMouseMove.bind(_this, item), role: "option" }, {
            "data-index": item.index,
            "data-is-focusable": !(item.disabled || item.hidden)
          }),
          label: item.text,
          title,
          // eslint-disable-next-line react/jsx-no-bind
          onRenderLabel: _this._onRenderItemLabel.bind(_this, __assign(__assign({}, item), { id: labelId })),
          className: css(itemClassName, "is-multi-select"),
          checked: isItemSelected,
          styles: multiSelectItemStyles,
          ariaPositionInSet: !item.hidden ? _this._sizePosCache.positionInSet(item.index) : void 0,
          ariaSetSize: !item.hidden ? _this._sizePosCache.optionSetSize : void 0,
          ariaLabel: item.ariaLabel,
          ariaLabelledBy: item.ariaLabel ? void 0 : labelId
        });
      };
      _this._onRenderOption = function(item) {
        return React42.createElement("span", { className: _this._classNames.dropdownOptionText }, item.text);
      };
      _this._onRenderMultiselectOption = function(item) {
        return React42.createElement("span", { id: item.id, "aria-hidden": "true", className: _this._classNames.dropdownOptionText }, item.text);
      };
      _this._onRenderItemLabel = function(item) {
        var _a5 = _this.props.onRenderOption, onRenderOption = _a5 === void 0 ? _this._onRenderMultiselectOption : _a5;
        return onRenderOption(item, _this._onRenderMultiselectOption);
      };
      _this._onPositioned = function(positions) {
        if (_this._focusZone.current) {
          _this._requestAnimationFrame(function() {
            var selectedIndices = _this.props.hoisted.selectedIndices;
            if (_this._focusZone.current) {
              if (!_this._hasBeenPositioned && selectedIndices && selectedIndices[0] && !_this.props.options[selectedIndices[0]].disabled) {
                var element = getDocument().getElementById("".concat(_this._id, "-list").concat(selectedIndices[0]));
                if (element) {
                  _this._focusZone.current.focusElement(element);
                }
                _this._hasBeenPositioned = true;
              } else {
                _this._focusZone.current.focus();
              }
            }
          });
        }
        if (!_this.state.calloutRenderEdge || _this.state.calloutRenderEdge !== positions.targetEdge) {
          _this.setState({
            calloutRenderEdge: positions.targetEdge
          });
        }
      };
      _this._onItemClick = function(item) {
        return function(event) {
          if (!item.disabled) {
            _this.setSelectedIndex(event, item.index);
            if (!_this.props.multiSelect) {
              _this.setState({
                isOpen: false
              });
            }
          }
        };
      };
      _this._onScroll = function() {
        if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== void 0) {
          clearTimeout(_this._scrollIdleTimeoutId);
          _this._scrollIdleTimeoutId = void 0;
        } else {
          _this._isScrollIdle = false;
        }
        _this._scrollIdleTimeoutId = window.setTimeout(function() {
          _this._isScrollIdle = true;
        }, _this._scrollIdleDelay);
      };
      _this._onMouseItemLeave = function(item, ev) {
        if (_this._shouldIgnoreMouseEvent()) {
          return;
        }
        if (_this._host.current) {
          if (_this._host.current.setActive) {
            try {
              _this._host.current.setActive();
            } catch (e) {
            }
          } else {
            _this._host.current.focus();
          }
        }
      };
      _this._onDismiss = function() {
        _this.setState({ isOpen: false });
      };
      _this._onDropdownBlur = function(ev) {
        var disabled = _this._isDisabled();
        if (disabled) {
          return;
        }
        if (_this.state.isOpen) {
          return;
        }
        _this.setState({ hasFocus: false });
        if (_this.props.onBlur) {
          _this.props.onBlur(ev);
        }
      };
      _this._onDropdownKeyDown = function(ev) {
        var disabled = _this._isDisabled();
        if (disabled) {
          return;
        }
        _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(ev);
          if (ev.defaultPrevented) {
            return;
          }
        }
        var newIndex;
        var selectedIndex = _this.props.hoisted.selectedIndices.length ? _this.props.hoisted.selectedIndices[0] : -1;
        var containsExpandCollapseModifier = ev.altKey || ev.metaKey;
        var isOpen = _this.state.isOpen;
        switch (ev.which) {
          case KeyCodes.enter:
            _this.setState({
              isOpen: !isOpen
            });
            break;
          case KeyCodes.escape:
            if (!isOpen) {
              return;
            }
            _this.setState({
              isOpen: false
            });
            break;
          case KeyCodes.up:
            if (containsExpandCollapseModifier) {
              if (isOpen) {
                _this.setState({ isOpen: false });
                break;
              }
              return;
            }
            if (_this.props.multiSelect) {
              _this.setState({ isOpen: true });
            } else if (!_this._isDisabled()) {
              newIndex = _this._moveIndex(ev, -1, selectedIndex - 1, selectedIndex);
            }
            break;
          case KeyCodes.down:
            if (containsExpandCollapseModifier) {
              ev.stopPropagation();
              ev.preventDefault();
            }
            if (containsExpandCollapseModifier && !isOpen || _this.props.multiSelect) {
              _this.setState({ isOpen: true });
            } else if (!_this._isDisabled()) {
              newIndex = _this._moveIndex(ev, 1, selectedIndex + 1, selectedIndex);
            }
            break;
          case KeyCodes.home:
            if (!_this.props.multiSelect) {
              newIndex = _this._moveIndex(ev, 1, 0, selectedIndex);
            }
            break;
          case KeyCodes.end:
            if (!_this.props.multiSelect) {
              newIndex = _this._moveIndex(ev, -1, _this.props.options.length - 1, selectedIndex);
            }
            break;
          case KeyCodes.space:
            break;
          default:
            return;
        }
        if (newIndex !== selectedIndex) {
          ev.stopPropagation();
          ev.preventDefault();
        }
      };
      _this._onDropdownKeyUp = function(ev) {
        var disabled = _this._isDisabled();
        if (disabled) {
          return;
        }
        var shouldHandleKey = _this._shouldHandleKeyUp(ev);
        var isOpen = _this.state.isOpen;
        if (_this.props.onKeyUp) {
          _this.props.onKeyUp(ev);
          if (ev.defaultPrevented) {
            return;
          }
        }
        switch (ev.which) {
          case KeyCodes.space:
            _this.setState({
              isOpen: !isOpen
            });
            break;
          default:
            if (shouldHandleKey && isOpen) {
              _this.setState({ isOpen: false });
            }
            return;
        }
        ev.stopPropagation();
        ev.preventDefault();
      };
      _this._onZoneKeyDown = function(ev) {
        var _a5, _b3;
        var elementToFocus;
        _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);
        var containsExpandCollapseModifier = ev.altKey || ev.metaKey;
        switch (ev.which) {
          case KeyCodes.up:
            if (containsExpandCollapseModifier) {
              _this.setState({ isOpen: false });
            } else {
              if (_this._host.current) {
                elementToFocus = getLastFocusable(_this._host.current, _this._host.current.lastChild, true);
              }
            }
            break;
          case KeyCodes.home:
          case KeyCodes.end:
          case KeyCodes.pageUp:
          case KeyCodes.pageDown:
            break;
          case KeyCodes.down:
            if (!containsExpandCollapseModifier && _this._host.current) {
              elementToFocus = getFirstFocusable(_this._host.current, _this._host.current.firstChild, true);
            }
            break;
          case KeyCodes.escape:
            _this.setState({ isOpen: false });
            break;
          case KeyCodes.tab:
            _this.setState({ isOpen: false });
            var document_1 = getDocument();
            if (document_1) {
              if (ev.shiftKey) {
                (_a5 = getPreviousElement(document_1.body, _this._dropDown.current, false, false, true, true)) === null || _a5 === void 0 ? void 0 : _a5.focus();
              } else {
                (_b3 = getNextElement(document_1.body, _this._dropDown.current, false, false, true, true)) === null || _b3 === void 0 ? void 0 : _b3.focus();
              }
            }
            break;
          default:
            return;
        }
        if (elementToFocus) {
          elementToFocus.focus();
        }
        ev.stopPropagation();
        ev.preventDefault();
      };
      _this._onZoneKeyUp = function(ev) {
        var shouldHandleKey = _this._shouldHandleKeyUp(ev);
        if (shouldHandleKey && _this.state.isOpen) {
          _this.setState({ isOpen: false });
          ev.preventDefault();
        }
      };
      _this._onDropdownClick = function(ev) {
        if (_this.props.onClick) {
          _this.props.onClick(ev);
          if (ev.defaultPrevented) {
            return;
          }
        }
        var isOpen = _this.state.isOpen;
        var disabled = _this._isDisabled();
        if (!disabled && !_this._shouldOpenOnFocus()) {
          _this.setState({
            isOpen: !isOpen
          });
        }
        _this._isFocusedByClick = false;
      };
      _this._onDropdownMouseDown = function() {
        _this._isFocusedByClick = true;
      };
      _this._onFocus = function(ev) {
        var disabled = _this._isDisabled();
        if (!disabled) {
          if (_this.props.onFocus) {
            _this.props.onFocus(ev);
          }
          var state = { hasFocus: true };
          if (_this._shouldOpenOnFocus()) {
            state.isOpen = true;
          }
          _this.setState(state);
        }
      };
      _this._isDisabled = function() {
        var disabled = _this.props.disabled;
        var isDisabled = _this.props.isDisabled;
        if (disabled === void 0) {
          disabled = isDisabled;
        }
        return disabled;
      };
      _this._onRenderLabel = function(props2) {
        var label = props2.label, required = props2.required, disabled = props2.disabled;
        var labelStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.label : void 0;
        return label ? React42.createElement(Label, { className: _this._classNames.label, id: _this._labelId, required, styles: labelStyles, disabled }, label) : null;
      };
      initializeComponentRef(_this);
      var multiSelect = props.multiSelect, selectedKey = props.selectedKey, selectedKeys = props.selectedKeys, defaultSelectedKey = props.defaultSelectedKey, defaultSelectedKeys = props.defaultSelectedKeys, options = props.options;
      if (true) {
        warnDeprecations(COMPONENT_NAME6, props, {
          isDisabled: "disabled",
          onChanged: "onChange",
          placeHolder: "placeholder",
          onRenderPlaceHolder: "onRenderPlaceholder"
        });
        warnMutuallyExclusive(COMPONENT_NAME6, props, {
          defaultSelectedKey: "selectedKey",
          defaultSelectedKeys: "selectedKeys",
          selectedKeys: "selectedKey"
        });
        if (multiSelect) {
          var warnMultiSelect = function(prop) {
            return warn("Dropdown property '".concat(prop, "' cannot be used when 'multiSelect' is true. Use '").concat(prop, "s' instead."));
          };
          if (selectedKey !== void 0) {
            warnMultiSelect("selectedKey");
          }
          if (defaultSelectedKey !== void 0) {
            warnMultiSelect("defaultSelectedKey");
          }
        } else {
          var warnNotMultiSelect = function(prop) {
            return warn("Dropdown property '".concat(prop, "s' cannot be used when 'multiSelect' is false/unset. Use '").concat(prop, "' instead."));
          };
          if (selectedKeys !== void 0) {
            warnNotMultiSelect("selectedKey");
          }
          if (defaultSelectedKeys !== void 0) {
            warnNotMultiSelect("defaultSelectedKey");
          }
        }
      }
      _this._id = props.id || getId("Dropdown");
      _this._labelId = _this._id + "-label";
      _this._listId = _this._id + "-list";
      _this._optionId = _this._id + "-option";
      _this._isScrollIdle = true;
      _this._hasBeenPositioned = false;
      _this._sizePosCache.updateOptions(options);
      _this.state = {
        isOpen: false,
        hasFocus: false,
        calloutRenderEdge: void 0
      };
      return _this;
    }
    Object.defineProperty(DropdownInternal2.prototype, "selectedOptions", {
      /**
       * All selected options
       */
      get: function() {
        var _a5 = this.props, options = _a5.options, selectedIndices = _a5.hoisted.selectedIndices;
        return getAllSelectedOptions(options, selectedIndices);
      },
      enumerable: false,
      configurable: true
    });
    DropdownInternal2.prototype.componentWillUnmount = function() {
      clearTimeout(this._scrollIdleTimeoutId);
    };
    DropdownInternal2.prototype.componentDidUpdate = function(prevProps, prevState) {
      if (prevState.isOpen === true && this.state.isOpen === false) {
        this._gotMouseMove = false;
        this._hasBeenPositioned = false;
        if (this.props.onDismiss) {
          this.props.onDismiss();
        }
      }
    };
    DropdownInternal2.prototype.render = function() {
      var id = this._id;
      var props = this.props;
      var className = props.className, label = props.label, options = props.options, ariaLabel = props.ariaLabel, required = props.required, errorMessage = props.errorMessage, propStyles = props.styles, theme = props.theme, panelProps = props.panelProps, calloutProps = props.calloutProps, _a5 = props.onRenderTitle, onRenderTitle = _a5 === void 0 ? this._getTitle : _a5, _b3 = props.onRenderContainer, onRenderContainer = _b3 === void 0 ? this._onRenderContainer : _b3, _c3 = props.onRenderCaretDown, onRenderCaretDown = _c3 === void 0 ? this._onRenderCaretDown : _c3, _d3 = props.onRenderLabel, onRenderLabel = _d3 === void 0 ? this._onRenderLabel : _d3, _e2 = props.onRenderItem, onRenderItem = _e2 === void 0 ? this._onRenderItem : _e2, selectedIndices = props.hoisted.selectedIndices;
      var _f = this.state, isOpen = _f.isOpen, calloutRenderEdge = _f.calloutRenderEdge, hasFocus = _f.hasFocus;
      var onRenderPlaceholder = props.onRenderPlaceholder || props.onRenderPlaceHolder || this._getPlaceholder;
      if (options !== this._sizePosCache.cachedOptions) {
        this._sizePosCache.updateOptions(options);
      }
      var selectedOptions = getAllSelectedOptions(options, selectedIndices);
      var divProps = getNativeProps(props, divProperties);
      var disabled = this._isDisabled();
      var errorMessageId = id + "-errorMessage";
      this._classNames = getClassNames12(propStyles, {
        theme,
        className,
        hasError: !!(errorMessage && errorMessage.length > 0),
        hasLabel: !!label,
        isOpen,
        required,
        disabled,
        isRenderingPlaceholder: !selectedOptions.length,
        panelClassName: panelProps ? panelProps.className : void 0,
        calloutClassName: calloutProps ? calloutProps.className : void 0,
        calloutRenderEdge
      });
      var hasErrorMessage = !!errorMessage && errorMessage.length > 0;
      return React42.createElement(
        "div",
        { className: this._classNames.root, ref: this.props.hoisted.rootRef, "aria-owns": isOpen ? this._listId : void 0 },
        onRenderLabel(this.props, this._onRenderLabel),
        React42.createElement(
          "div",
          __assign({ "data-is-focusable": !disabled, "data-ktp-target": true, ref: this._dropDown, id, tabIndex: disabled ? -1 : 0, role: "combobox", "aria-haspopup": "listbox", "aria-expanded": isOpen ? "true" : "false", "aria-label": ariaLabel, "aria-labelledby": label && !ariaLabel ? mergeAriaAttributeValues(this._labelId, this._optionId) : void 0, "aria-describedby": hasErrorMessage ? this._id + "-errorMessage" : void 0, "aria-required": required, "aria-disabled": disabled, "aria-controls": isOpen ? this._listId : void 0 }, divProps, { className: this._classNames.dropdown, onBlur: this._onDropdownBlur, onKeyDown: this._onDropdownKeyDown, onKeyUp: this._onDropdownKeyUp, onClick: this._onDropdownClick, onMouseDown: this._onDropdownMouseDown, onFocus: this._onFocus }),
          React42.createElement(
            "span",
            { id: this._optionId, className: this._classNames.title, "aria-live": hasFocus ? "polite" : void 0, "aria-atomic": hasFocus ? true : void 0, "aria-invalid": hasErrorMessage },
            // If option is selected render title, otherwise render the placeholder text
            selectedOptions.length ? onRenderTitle(selectedOptions, this._onRenderTitle) : onRenderPlaceholder(props, this._onRenderPlaceholder)
          ),
          React42.createElement("span", { className: this._classNames.caretDownWrapper }, onRenderCaretDown(props, this._onRenderCaretDown))
        ),
        isOpen && onRenderContainer(__assign(__assign({}, props), { onDismiss: this._onDismiss, onRenderItem }), this._onRenderContainer),
        hasErrorMessage && React42.createElement("div", { role: "alert", id: errorMessageId, className: this._classNames.errorMessage }, errorMessage)
      );
    };
    DropdownInternal2.prototype.focus = function(shouldOpenOnFocus) {
      if (this._dropDown.current) {
        this._dropDown.current.focus();
        if (shouldOpenOnFocus) {
          this.setState({
            isOpen: true
          });
        }
      }
    };
    DropdownInternal2.prototype.setSelectedIndex = function(event, index) {
      var _a5 = this.props, options = _a5.options, selectedKey = _a5.selectedKey, selectedKeys = _a5.selectedKeys, multiSelect = _a5.multiSelect, notifyOnReselect = _a5.notifyOnReselect, _b3 = _a5.hoisted.selectedIndices, selectedIndices = _b3 === void 0 ? [] : _b3;
      var checked = selectedIndices ? selectedIndices.indexOf(index) > -1 : false;
      var newIndexes = [];
      index = Math.max(0, Math.min(options.length - 1, index));
      if (selectedKey !== void 0 || selectedKeys !== void 0) {
        this._onChange(event, options, index, checked, multiSelect);
        return;
      }
      if (!multiSelect && !notifyOnReselect && index === selectedIndices[0]) {
        return;
      } else if (multiSelect) {
        newIndexes = selectedIndices ? this._copyArray(selectedIndices) : [];
        if (checked) {
          var position = newIndexes.indexOf(index);
          if (position > -1) {
            newIndexes.splice(position, 1);
          }
        } else {
          newIndexes.push(index);
        }
      } else {
        newIndexes = [index];
      }
      event.persist();
      this.props.hoisted.setSelectedIndices(newIndexes);
      this._onChange(event, options, index, checked, multiSelect);
    };
    DropdownInternal2.prototype._copyArray = function(array) {
      var newArray = [];
      for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var element = array_1[_i];
        newArray.push(element);
      }
      return newArray;
    };
    DropdownInternal2.prototype._moveIndex = function(event, stepValue, index, selectedIndex) {
      var options = this.props.options;
      if (selectedIndex === index || options.length === 0) {
        return selectedIndex;
      }
      if (index >= options.length) {
        index = 0;
      } else if (index < 0) {
        index = options.length - 1;
      }
      var stepCounter = 0;
      while (options[index].itemType === SelectableOptionMenuItemType.Header || options[index].itemType === SelectableOptionMenuItemType.Divider || options[index].disabled) {
        if (stepCounter >= options.length) {
          return selectedIndex;
        }
        if (index + stepValue < 0) {
          index = options.length;
        } else if (index + stepValue >= options.length) {
          index = -1;
        }
        index = index + stepValue;
        stepCounter++;
      }
      this.setSelectedIndex(event, index);
      return index;
    };
    DropdownInternal2.prototype._renderFocusableList = function(props) {
      var _a5 = props.onRenderList, onRenderList = _a5 === void 0 ? this._onRenderList : _a5, label = props.label, ariaLabel = props.ariaLabel, multiSelect = props.multiSelect;
      return React42.createElement(
        "div",
        { className: this._classNames.dropdownItemsWrapper, onKeyDown: this._onZoneKeyDown, onKeyUp: this._onZoneKeyUp, ref: this._host, tabIndex: 0 },
        React42.createElement(FocusZone, { ref: this._focusZone, direction: FocusZoneDirection.vertical, id: this._listId, className: this._classNames.dropdownItems, role: "listbox", "aria-label": ariaLabel, "aria-labelledby": label && !ariaLabel ? this._labelId : void 0, "aria-multiselectable": multiSelect }, onRenderList(props, this._onRenderList))
      );
    };
    DropdownInternal2.prototype._renderSeparator = function(item) {
      var index = item.index, key = item.key;
      var separatorClassName = item.hidden ? this._classNames.dropdownDividerHidden : this._classNames.dropdownDivider;
      if (index > 0) {
        return React42.createElement("div", { role: "separator", key, className: separatorClassName });
      }
      return null;
    };
    DropdownInternal2.prototype._renderHeader = function(item) {
      var _a5 = this.props.onRenderOption, onRenderOption = _a5 === void 0 ? this._onRenderOption : _a5;
      var key = item.key, id = item.id;
      var headerClassName = item.hidden ? this._classNames.dropdownItemHeaderHidden : this._classNames.dropdownItemHeader;
      return React42.createElement("div", { id, key, className: headerClassName }, onRenderOption(item, this._onRenderOption));
    };
    DropdownInternal2.prototype._onItemMouseEnter = function(item, ev) {
      if (this._shouldIgnoreMouseEvent()) {
        return;
      }
      var targetElement = ev.currentTarget;
      targetElement.focus();
    };
    DropdownInternal2.prototype._onItemMouseMove = function(item, ev) {
      var targetElement = ev.currentTarget;
      this._gotMouseMove = true;
      if (!this._isScrollIdle || document.activeElement === targetElement) {
        return;
      }
      targetElement.focus();
    };
    DropdownInternal2.prototype._shouldIgnoreMouseEvent = function() {
      return !this._isScrollIdle || !this._gotMouseMove;
    };
    DropdownInternal2.prototype._isAltOrMeta = function(ev) {
      return ev.which === KeyCodes.alt || ev.key === "Meta";
    };
    DropdownInternal2.prototype._shouldHandleKeyUp = function(ev) {
      var keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);
      this._lastKeyDownWasAltOrMeta = false;
      return !!keyPressIsAltOrMetaAlone && !(isMac() || isIOS());
    };
    DropdownInternal2.prototype._shouldOpenOnFocus = function() {
      var hasFocus = this.state.hasFocus;
      var openOnKeyboardFocus = this.props.openOnKeyboardFocus;
      return !this._isFocusedByClick && openOnKeyboardFocus === true && !hasFocus;
    };
    DropdownInternal2.defaultProps = {
      options: []
    };
    return DropdownInternal2;
  }(React42.Component)
);

// node_modules/@fluentui/react/lib/components/Dropdown/Dropdown.styles.js
var _a4;
var _b2;
var _c2;
var _d2;
var GlobalClassNames10 = {
  root: "ms-Dropdown-container",
  label: "ms-Dropdown-label",
  dropdown: "ms-Dropdown",
  title: "ms-Dropdown-title",
  caretDownWrapper: "ms-Dropdown-caretDownWrapper",
  caretDown: "ms-Dropdown-caretDown",
  callout: "ms-Dropdown-callout",
  panel: "ms-Dropdown-panel",
  dropdownItems: "ms-Dropdown-items",
  dropdownItem: "ms-Dropdown-item",
  dropdownDivider: "ms-Dropdown-divider",
  dropdownOptionText: "ms-Dropdown-optionText",
  dropdownItemHeader: "ms-Dropdown-header",
  titleIsPlaceHolder: "ms-Dropdown-titleIsPlaceHolder",
  titleHasError: "ms-Dropdown-title--hasError"
};
var DROPDOWN_HEIGHT = 32;
var DROPDOWN_ITEM_HEIGHT = 36;
var highContrastAdjustMixin = (_a4 = {}, _a4["".concat(HighContrastSelector, ", ").concat(HighContrastSelectorWhite.replace("@media ", ""))] = __assign({}, getHighContrastNoAdjustStyle()), _a4);
var highContrastItemAndTitleStateMixin = {
  selectors: __assign((_b2 = {}, _b2[HighContrastSelector] = {
    backgroundColor: "Highlight",
    borderColor: "Highlight",
    color: "HighlightText"
  }, _b2[".ms-Checkbox-checkbox"] = (_c2 = {}, _c2[HighContrastSelector] = {
    borderColor: "HighlightText"
  }, _c2), _b2), highContrastAdjustMixin)
};
var highContrastBorderState = {
  selectors: (_d2 = {}, _d2[HighContrastSelector] = {
    borderColor: "Highlight"
  }, _d2)
};
var MinimumScreenSelector = getScreenSelector(0, ScreenWidthMinMedium);
var getStyles20 = function(props) {
  var _a5, _b3, _c3, _d3, _e2, _f, _g, _h, _j, _k, _l, _m;
  var theme = props.theme, hasError = props.hasError, hasLabel = props.hasLabel, className = props.className, isOpen = props.isOpen, disabled = props.disabled, required = props.required, isRenderingPlaceholder = props.isRenderingPlaceholder, panelClassName = props.panelClassName, calloutClassName = props.calloutClassName, calloutRenderEdge = props.calloutRenderEdge;
  if (!theme) {
    throw new Error("theme is undefined or null in base Dropdown getStyles function.");
  }
  var globalClassnames = getGlobalClassNames(GlobalClassNames10, theme);
  var palette = theme.palette, semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
  var rootHoverFocusActiveSelectorNeutralDarkMixin = {
    color: semanticColors.menuItemTextHovered
  };
  var rootHoverFocusActiveSelectorNeutralPrimaryMixin = {
    color: semanticColors.menuItemText
  };
  var borderColorError = {
    borderColor: semanticColors.errorText
  };
  var dropdownItemStyle = [
    globalClassnames.dropdownItem,
    {
      backgroundColor: "transparent",
      boxSizing: "border-box",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      padding: "0 8px",
      width: "100%",
      minHeight: DROPDOWN_ITEM_HEIGHT,
      lineHeight: 20,
      height: 0,
      position: "relative",
      border: "1px solid transparent",
      borderRadius: 0,
      wordWrap: "break-word",
      overflowWrap: "break-word",
      textAlign: "left",
      ".ms-Button-flexContainer": {
        width: "100%"
      }
    }
  ];
  var dropdownHeaderStyle = [
    globalClassnames.dropdownItemHeader,
    __assign(__assign({}, fonts.medium), { fontWeight: FontWeights.semibold, color: semanticColors.menuHeader, background: "none", backgroundColor: "transparent", border: "none", height: DROPDOWN_ITEM_HEIGHT, lineHeight: DROPDOWN_ITEM_HEIGHT, cursor: "default", padding: "0 8px", userSelect: "none", textAlign: "left", selectors: (_a5 = {}, _a5[HighContrastSelector] = __assign({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _a5) })
  ];
  var selectedItemBackgroundColor = semanticColors.menuItemBackgroundPressed;
  var itemSelectors = function(isSelected) {
    var _a6, _b4;
    if (isSelected === void 0) {
      isSelected = false;
    }
    return {
      selectors: (_a6 = {
        "&:hover": [
          {
            color: semanticColors.menuItemTextHovered,
            backgroundColor: !isSelected ? semanticColors.menuItemBackgroundHovered : selectedItemBackgroundColor
          },
          highContrastItemAndTitleStateMixin
        ],
        "&.is-multi-select:hover": [
          { backgroundColor: !isSelected ? "transparent" : selectedItemBackgroundColor },
          highContrastItemAndTitleStateMixin
        ],
        "&:active:hover": [
          {
            color: semanticColors.menuItemTextHovered,
            backgroundColor: !isSelected ? semanticColors.menuItemBackgroundPressed : semanticColors.menuItemBackgroundHovered
          },
          highContrastItemAndTitleStateMixin
        ]
      }, _a6[".".concat(IsFocusVisibleClassName, " &:focus:after")] = (_b4 = {
        left: 0,
        top: 0,
        bottom: 0,
        right: 0
      }, _b4[HighContrastSelector] = {
        inset: "2px"
      }, _b4), _a6[HighContrastSelector] = {
        border: "none"
      }, _a6)
    };
  };
  var dropdownItemSelected = __spreadArray(__spreadArray([], dropdownItemStyle, true), [
    {
      backgroundColor: selectedItemBackgroundColor,
      color: semanticColors.menuItemTextHovered
    },
    itemSelectors(true),
    highContrastItemAndTitleStateMixin
  ], false);
  var dropdownItemDisabled = __spreadArray(__spreadArray([], dropdownItemStyle, true), [
    {
      color: semanticColors.disabledText,
      cursor: "default",
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        color: "GrayText",
        border: "none"
      }, _b3)
    }
  ], false);
  var titleOpenBorderRadius = calloutRenderEdge === RectangleEdge.bottom ? "".concat(effects.roundedCorner2, " ").concat(effects.roundedCorner2, " 0 0") : "0 0 ".concat(effects.roundedCorner2, " ").concat(effects.roundedCorner2);
  var calloutOpenBorderRadius = calloutRenderEdge === RectangleEdge.bottom ? "0 0 ".concat(effects.roundedCorner2, " ").concat(effects.roundedCorner2) : "".concat(effects.roundedCorner2, " ").concat(effects.roundedCorner2, " 0 0");
  return {
    root: [globalClassnames.root, className],
    label: globalClassnames.label,
    dropdown: [
      globalClassnames.dropdown,
      normalize,
      fonts.medium,
      {
        color: semanticColors.menuItemText,
        borderColor: semanticColors.focusBorder,
        position: "relative",
        outline: 0,
        userSelect: "none",
        selectors: (_c3 = {}, _c3["&:hover ." + globalClassnames.title] = [
          !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
          { borderColor: isOpen ? palette.neutralSecondary : palette.neutralPrimary },
          highContrastBorderState
        ], _c3["&:focus ." + globalClassnames.title] = [
          !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
          { selectors: (_d3 = {}, _d3[HighContrastSelector] = { color: "Highlight" }, _d3) }
        ], _c3["&:focus:after"] = [
          {
            pointerEvents: "none",
            content: "''",
            position: "absolute",
            boxSizing: "border-box",
            top: "0px",
            left: "0px",
            width: "100%",
            height: "100%",
            // see https://github.com/microsoft/fluentui/pull/9182 for semantic color disc
            border: !disabled ? "2px solid ".concat(palette.themePrimary) : "none",
            borderRadius: "2px",
            selectors: (_e2 = {}, _e2[HighContrastSelector] = {
              color: "Highlight"
            }, _e2)
          }
        ], _c3["&:active ." + globalClassnames.title] = [
          !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
          { borderColor: palette.themePrimary },
          highContrastBorderState
        ], _c3["&:hover ." + globalClassnames.caretDown] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c3["&:focus ." + globalClassnames.caretDown] = [
          !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin,
          { selectors: (_f = {}, _f[HighContrastSelector] = { color: "Highlight" }, _f) }
        ], _c3["&:active ." + globalClassnames.caretDown] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c3["&:hover ." + globalClassnames.titleIsPlaceHolder] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c3["&:focus ." + globalClassnames.titleIsPlaceHolder] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c3["&:active ." + globalClassnames.titleIsPlaceHolder] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c3["&:hover ." + globalClassnames.titleHasError] = borderColorError, _c3["&:active ." + globalClassnames.titleHasError] = borderColorError, _c3)
      },
      isOpen && "is-open",
      disabled && "is-disabled",
      required && "is-required",
      required && !hasLabel && {
        selectors: (_g = {
          ":before": {
            content: "'*'",
            color: semanticColors.errorText,
            position: "absolute",
            top: -5,
            right: -10
          }
        }, _g[HighContrastSelector] = {
          selectors: {
            ":after": {
              right: -14
              // moving the * 4 pixel to right to alleviate border clipping in HC mode.
            }
          }
        }, _g)
      }
    ],
    title: [
      globalClassnames.title,
      normalize,
      {
        backgroundColor: semanticColors.inputBackground,
        borderWidth: 1,
        borderStyle: "solid",
        borderColor: semanticColors.inputBorder,
        borderRadius: isOpen ? titleOpenBorderRadius : effects.roundedCorner2,
        cursor: "pointer",
        display: "block",
        height: DROPDOWN_HEIGHT,
        lineHeight: DROPDOWN_HEIGHT - 2,
        padding: "0 28px 0 8px",
        position: "relative",
        overflow: "hidden",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis"
      },
      isRenderingPlaceholder && [globalClassnames.titleIsPlaceHolder, { color: semanticColors.inputPlaceholderText }],
      hasError && [globalClassnames.titleHasError, borderColorError],
      disabled && {
        backgroundColor: semanticColors.disabledBackground,
        border: "none",
        color: semanticColors.disabledText,
        cursor: "default",
        selectors: (_h = {}, _h[HighContrastSelector] = __assign({ border: "1px solid GrayText", color: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _h)
      }
    ],
    caretDownWrapper: [
      globalClassnames.caretDownWrapper,
      {
        height: DROPDOWN_HEIGHT,
        lineHeight: DROPDOWN_HEIGHT - 2,
        paddingTop: 1,
        position: "absolute",
        right: 8,
        top: 0
      },
      !disabled && {
        cursor: "pointer"
      }
    ],
    caretDown: [
      globalClassnames.caretDown,
      { color: palette.neutralSecondary, fontSize: fonts.small.fontSize, pointerEvents: "none" },
      disabled && {
        color: semanticColors.disabledText,
        selectors: (_j = {}, _j[HighContrastSelector] = __assign({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _j)
      }
    ],
    errorMessage: __assign(__assign({ color: semanticColors.errorText }, theme.fonts.small), { paddingTop: 5 }),
    callout: [
      globalClassnames.callout,
      {
        boxShadow: effects.elevation8,
        borderRadius: calloutOpenBorderRadius,
        selectors: (_k = {}, _k[".ms-Callout-main"] = { borderRadius: calloutOpenBorderRadius }, _k)
      },
      calloutClassName
    ],
    dropdownItemsWrapper: { selectors: { "&:focus": { outline: 0 } } },
    dropdownItems: [globalClassnames.dropdownItems, { display: "block" }],
    dropdownItem: __spreadArray(__spreadArray([], dropdownItemStyle, true), [itemSelectors()], false),
    dropdownItemSelected,
    dropdownItemDisabled,
    dropdownItemSelectedAndDisabled: [dropdownItemSelected, dropdownItemDisabled, { backgroundColor: "transparent" }],
    dropdownItemHidden: __spreadArray(__spreadArray([], dropdownItemStyle, true), [{ display: "none" }], false),
    dropdownDivider: [globalClassnames.dropdownDivider, { height: 1, backgroundColor: semanticColors.bodyDivider }],
    dropdownDividerHidden: [globalClassnames.dropdownDivider, { display: "none" }],
    dropdownOptionText: [
      globalClassnames.dropdownOptionText,
      {
        overflow: "hidden",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        minWidth: 0,
        maxWidth: "100%",
        wordWrap: "break-word",
        overflowWrap: "break-word",
        margin: "1px"
      }
    ],
    dropdownItemHeader: dropdownHeaderStyle,
    dropdownItemHeaderHidden: __spreadArray(__spreadArray([], dropdownHeaderStyle, true), [{ display: "none" }], false),
    subComponentStyles: {
      label: { root: { display: "inline-block" } },
      multiSelectItem: {
        root: {
          padding: 0
        },
        label: {
          alignSelf: "stretch",
          padding: "0 8px",
          width: "100%"
        },
        input: {
          selectors: (_l = {}, _l[".".concat(IsFocusVisibleClassName, " &:focus + label::before")] = {
            outlineOffset: "0px"
          }, _l)
        }
      },
      panel: {
        root: [panelClassName],
        main: {
          selectors: (_m = {}, // In case of extra small screen sizes
          _m[MinimumScreenSelector] = {
            // panelWidth xs
            width: 272
          }, _m)
        },
        contentInner: { padding: "0 0 20px" }
      }
    }
  };
};

// node_modules/@fluentui/react/lib/components/Dropdown/Dropdown.js
var Dropdown = styled(DropdownBase, getStyles20, void 0, {
  scope: "Dropdown"
});
Dropdown.displayName = "Dropdown";

export {
  DirectionalHint,
  RectangleEdge,
  Position,
  positionElement,
  positionCallout,
  positionCard,
  getMaxHeight,
  getOppositeEdge,
  getBoundsFromTargetWindow,
  Popup,
  buildClassMap,
  registerIcons,
  unregisterIcons,
  registerIconAlias,
  getIcon,
  setIconOptions,
  getIconClassName,
  mergeThemes,
  CommunicationColors,
  NeutralColors,
  SharedColors,
  DefaultPalette,
  Depths,
  DefaultEffects,
  DefaultSpacing,
  MotionDurations,
  MotionTimings,
  MotionAnimations,
  AnimationVariables,
  AnimationStyles,
  LocalizedFontNames,
  LocalizedFontFamilies,
  FontSizes,
  FontWeights,
  IconFontSizes,
  createFontStyles,
  DefaultFontStyles,
  registerDefaultFontFaces,
  createTheme,
  FluentTheme,
  HighContrastSelector,
  HighContrastSelectorWhite,
  HighContrastSelectorBlack,
  EdgeChromiumHighContrastSelector,
  ScreenWidthMinSmall,
  ScreenWidthMinMedium,
  ScreenWidthMinLarge,
  ScreenWidthMinXLarge,
  ScreenWidthMinXXLarge,
  ScreenWidthMinXXXLarge,
  ScreenWidthMaxSmall,
  ScreenWidthMaxMedium,
  ScreenWidthMaxLarge,
  ScreenWidthMaxXLarge,
  ScreenWidthMaxXXLarge,
  ScreenWidthMinUhfMobile,
  getScreenSelector,
  getHighContrastNoAdjustStyle,
  getEdgeChromiumNoHighContrastAdjustSelector,
  ZIndexes,
  getFocusStyle,
  focusClear,
  getFocusOutlineStyle,
  getInputFocusStyle,
  hiddenContentStyle,
  PulsingBeaconAnimationStyles,
  getGlobalClassNames,
  getThemedContext,
  ThemeSettingName,
  getTheme,
  registerOnThemeChangeCallback,
  removeOnThemeChangeCallback,
  loadTheme2 as loadTheme,
  normalize,
  noWrap,
  getFadedOverflowStyle,
  getPlaceholderStyles,
  AnimationClassNames,
  FontClassNames,
  ColorClassNames,
  FLUENT_CDN_BASE_URL,
  CalloutContentBase,
  CalloutContent,
  FabricBase,
  Fabric,
  registerLayer,
  unregisterLayer,
  getLayerCount,
  getLayerHost,
  registerLayerHost,
  unregisterLayerHost,
  createDefaultLayerHost,
  cleanupDefaultLayerHost,
  notifyHostChanged,
  setDefaultTarget,
  getDefaultTarget,
  LayerBase,
  getStyles3 as getStyles,
  Layer,
  LayerHost,
  Callout,
  FocusTrapZone,
  FocusTrapCallout,
  IconType,
  ImageFit,
  ImageCoverStyle,
  ImageLoadState,
  ImageBase,
  Image,
  getIconContent,
  FontIcon,
  getFontIcon,
  IconBase,
  Icon,
  ImageIcon,
  ContextualMenuItemType,
  FocusZoneTabbableElements,
  FocusZoneDirection,
  FocusZone,
  ContextualMenuItemBase,
  getMenuItemStyles,
  getItemClassNames,
  getItemStyles,
  ContextualMenuItem,
  transitionKeysAreEqual,
  transitionKeysContain,
  buildKeytipConfigMap,
  constructKeytip,
  KTP_PREFIX,
  KTP_SEPARATOR,
  KTP_FULL_PREFIX,
  DATAKTP_TARGET,
  DATAKTP_EXECUTE_TARGET,
  DATAKTP_ARIA_TARGET,
  KTP_LAYER_ID,
  KTP_ARIA_SEPARATOR,
  KeytipEvents,
  KeytipManager,
  sequencesToID,
  mergeOverflows,
  ktpTargetFromSequences,
  ktpTargetFromId,
  getAriaDescribedBy,
  KeytipData,
  useKeytipRef,
  VerticalDivider,
  BaseDecorator,
  ResponsiveMode,
  setResponsiveMode,
  initializeResponsiveMode,
  getInitialResponsiveMode,
  withResponsiveMode,
  getResponsiveMode,
  useResponsiveMode,
  getSubmenuItems,
  canAnyMenuItemsCheck,
  ContextualMenuBase,
  ContextualMenu,
  ButtonGlobalClassNames,
  getSplitButtonClassNames,
  BaseButton,
  ElementType,
  ButtonType,
  getStyles8 as getStyles2,
  DefaultButton,
  getStyles11 as getStyles3,
  ActionButton,
  CompoundButton,
  IconButton,
  PrimaryButton,
  Button,
  CommandBarButton,
  CommandButton,
  MessageBarButton,
  getAllSelectedOptions,
  SelectableOptionMenuItemType,
  LabelBase,
  Label,
  OverlayBase,
  Overlay,
  PanelType,
  PanelBase,
  Panel,
  CheckboxBase,
  Checkbox,
  DropdownBase,
  Dropdown
};
//# sourceMappingURL=chunk-5FIHR6N7.js.map
